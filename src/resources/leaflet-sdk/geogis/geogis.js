/*!
 * 
 *          Copyright© 1999 - 2020 Geoway Software Co.Ltd
 *          license: 
 *          version: v1.0.0
 *         
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 37);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = L;

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Proj4Leaflet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);
/**
 * @namespace L
 */

/**
 * @namespace L.geoway
 */

/**
 * Geoway Leaflet SDK
 */


leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.geoway = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.geoway || {};
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.geoway.control = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.geoway.control || {};
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.geoway.format = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.geoway.format || {};
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.geoway.service = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.geoway.service || {};
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Map.mergeOptions({
  crs: leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.CRS.EPSG4326,
  attributionControl: false,
  minZoom: 1
});
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Map.include({
  getScales: function getScales() {
    if (this.options.scales) {
      return this.options.scales;
    } else {
      return this.defaultScales();
    }
  },
  defaultScales: function defaultScales() {
    return [5.916587109091312E8, 2.958293554545656E8, 1.479146777272828E8, 7.39573388636414E7, 3.69786694318207E7, 1.848933471591035E7, 9244667.357955175, 4622333.678977588, 2311166.839488794, 1155583.419744397, 577791.7098721985, 288895.85493609926, 144447.92746804963, 72223.96373402482, 36111.98186701241, 18055.990933506204, 9027.995466753102, 4513.997733376551, 2256.998866688275, 1128.4994333441375, 564.2497166720685];
  }
});

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Deferred; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getJSON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getParamJSON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getBufferData; });
var jx = __webpack_require__(43);

var Deferred = function Deferred() {
  this.promise = new Promise(function (resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
  }.bind(this));
  this.then = this.promise.then.bind(this.promise);
  this["catch"] = this.promise["catch"].bind(this.promise);
};

var getJSON = function getJSON(param) {
  if (!param.type) {
    param.type = 'GET';
  }

  if (!param.dataType) {
    param.dataType = 'json';
  }

  return new Promise(function (resolve, reject) {
    sendAjax(resolve, reject, param);
  });
};

var getBufferData = function getBufferData(param) {
  if (!param.type) {
    param.type = 'GET';
  }

  if (!param.dataType) {
    param.dataType = 'arraybuffer';
  }

  var xhr;
  var promise = new Promise(function (resolve, reject) {
    xhr = sendAjax(resolve, reject, param, true);
  });
  promise.xhr = xhr;
  return promise;
};

var sendAjax = function sendAjax(resolve, reject, param, returnParam) {
  var UType = param.type.toUpperCase();
  var rq;

  if (UType == 'GET') {
    rq = jx.get(param.url);
  }

  if (UType == 'POST') {
    rq = jx.post(param.url, param.data);
  }

  if (param.dataType == "arraybuffer") {
    rq = jx.get(param.url, true);
  }

  var timeout = 30000;
  var time = false; //是否超时

  var timer = setTimeout(function () {
    if (rq.request.status >= 300 || rq.request.status < 200) {
      time = true;
      rq.request.abort(); //请求中止

      console.warn('timeout: ' + param.url);
      reject({
        param: param,
        data: 'getParamJSON: ' + param.url + ' timeout '
      });
    }
  }, timeout);
  rq.success(function (results) {
    if (time) {
      clearTimeout(timer);
      return; //忽略中止请求
    }

    if (param.dataType == 'json' && typeof results == 'string') {
      results = JSON.parse(results);
    }

    if (returnParam) {
      resolve({
        param: param,
        data: results
      });
    } else {
      resolve(results);
    }
  });
  rq.error(function (results, request) {
    if (time) {
      clearTimeout(timer);
      return; //终止请求报错
    }

    reject({
      param: param,
      data: 'getParamJSON: ' + param.url + ' failed with status: ' + request.status + ''
    });
  });
  return rq.request;
};

var getParamJSON = function getParamJSON(param) {
  if (!param.type) {
    param.type = 'GET';
  }

  if (!param.dataType) {
    param.dataType = 'json';
  }

  var xhr;
  var promise = new Promise(function (resolve, reject) {
    xhr = sendAjax(resolve, reject, param, true);
  });
  promise.xhr = xhr;
  return promise;
};



/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var promise_polyfill_dist_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/* harmony import */ var promise_polyfill_dist_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(promise_polyfill_dist_polyfill__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fetch_ie8__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);
/* harmony import */ var fetch_ie8__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fetch_ie8__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }







if (typeof Object.assign != 'function') {
  Object.assign = function (target) {
    'use strict';

    if (target == null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    target = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      var source = arguments[index];

      if (source != null) {
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
    }

    return target;
  };
}

var fetch = (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && window.fetch || node_fetch__WEBPACK_IMPORTED_MODULE_2___default.a;
var fetchJson = {
  request: function request(method, url, data, options) {
    var settings = {
      method: method.toUpperCase(),
      credentials: 'same-origin',
      strictErrors: false
    };
    Object.assign(settings, options);
    var isGetRequest = settings.method === 'GET';
    var jsonHeaders = {
      'Accept': 'application/json'
    };

    if (!isGetRequest && data) {
      jsonHeaders['Content-Type'] = 'application/json';
    }

    settings.headers = Object.assign(jsonHeaders, options && options.headers);

    var toPair = function toPair(key) {
      return key + '=' + encodeURIComponent(data[key]);
    }; //build query string field-value


    var paramKeys = isGetRequest && data && Object.keys(data);

    if (paramKeys && paramKeys.length) {
      url = url + (url.indexOf('?') != -1 ? '&' : '?') + paramKeys.map(toPair).join('&');
    }

    if (!isGetRequest && data) {
      settings.body = JSON.stringify(data);
    }

    var logUrl = url.replace(/[?].*/, ''); //security: prevent logging url parameters

    var logDomain = logUrl.replace(/.*:[/][/]/, '').replace(/[:/].*/, ''); //extract hostname

    var toJson = function toJson(response) {
      var contentType = response.headers.get('content-type');
      var isJson = /json|javascript/.test(contentType); //match "application/json" or "text/javascript"

      var textToObj = function textToObj(httpBody) {
        //rest calls should only return json
        response.error = !response.ok;
        response.contentType = contentType;
        response.bodyText = httpBody;
        return response;
      };

      if (fetchJson.logger) {
        fetchJson.logger(new Date().toISOString(), 'response', settings.method, logDomain, logUrl, response.ok, response.status, response.statusText, contentType);
      }

      if (settings.strictErrors && !response.ok) {
        throw Error('HTTP response status ("strictErrors" mode enabled): ' + response.status);
      }

      return isJson ? response.json() : response.text().then(textToObj);
    };

    if (fetchJson.logger) {
      fetchJson.logger(new Date().toISOString(), 'request', settings.method, logDomain, logUrl);
    }

    return fetch(url, settings).then(toJson);
  },
  get: function get(url, params, options) {
    return fetchJson.request('GET', url, params, options);
  },
  post: function post(url, resource, options) {
    return fetchJson.request('POST', url, resource, options);
  },
  put: function put(url, resource, options) {
    return fetchJson.request('PUT', url, resource, options);
  },
  patch: function patch(url, resource, options) {
    return fetchJson.request('PATCH', url, resource, options);
  },
  "delete": function _delete(url, resource, options) {
    return fetchJson.request('DELETE', url, resource, options);
  },
  logger: null,
  //null or a function
  getLogHeaders: function getLogHeaders() {
    return ['Timestamp', 'HTTP', 'Method', 'Domain', 'URL', 'Ok', 'Status', 'Text', 'Type'];
  },
  getLogHeaderIndex: function getLogHeaderIndex() {
    return {
      timestamp: 0,
      http: 1,
      method: 2,
      domain: 3,
      url: 4,
      ok: 5,
      status: 6,
      text: 7,
      type: 8
    };
  },
  enableLogger: function enableLogger(booleanOrFn) {
    var isFn = typeof booleanOrFn === 'function';
    fetchJson.logger = isFn ? booleanOrFn : booleanOrFn === false ? null : console.log;
    return fetchJson.logger;
  }
};
var FetchRequest = {
  get: function get(url, params, options) {
    return fetchJson.get(url, params, options);
  },
  post: function post(url, resource, options) {
    return fetchJson.post(url, resource, options);
  },
  put: function put(url, resource, options) {
    return fetchJson.put(url, resource, options);
  },
  "delete": function _delete(url, resource, options) {
    return fetchJson["delete"](url, resource, options);
  }
};
/* harmony default export */ __webpack_exports__["a"] = (FetchRequest);
leaflet__WEBPACK_IMPORTED_MODULE_3___default.a.geoway.Request = FetchRequest;

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ datasource_DataSource; });
__webpack_require__.d(__webpack_exports__, "p", function() { return /* reexport */ datasource_URLDataSource; });
__webpack_require__.d(__webpack_exports__, "n", function() { return /* reexport */ datasource_LocalDataSource; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ label_GLabelGrid; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* reexport */ label_GWVTAnno; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ feature_Feature; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* reexport */ stylejs_GStyleItem; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ vector_GDynamicMap; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* reexport */ vector_GVMapGrid; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* reexport */ vector_GXYZ; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ layer_GServiceGroup; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* reexport */ draw_GVMapGridUtil; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ stylejs_GGroup; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ stylejs_GLevels; });
__webpack_require__.d(__webpack_exports__, "q", function() { return /* reexport */ WMTSLayer; });
__webpack_require__.d(__webpack_exports__, "m", function() { return /* reexport */ ImageMapLayer; });
__webpack_require__.d(__webpack_exports__, "o", function() { return /* reexport */ SingleImageLayer; });

// UNUSED EXPORTS: wmtsLayer, imageMapLayer, singleImageLayer

// EXTERNAL MODULE: external "L"
var external_L_ = __webpack_require__(0);
var external_L_default = /*#__PURE__*/__webpack_require__.n(external_L_);

// EXTERNAL MODULE: ./src/core/Base.js
var Base = __webpack_require__(1);

// CONCATENATED MODULE: ./src/layer/TileWMTSLayer.js


var WMTSLayer = external_L_default.a.TileLayer.extend({
  defaultWmtsParams: {
    service: 'WMTS',
    request: 'GetTile',
    version: '1.0.0',
    layer: '',
    style: '',
    tilematrixSet: '',
    format: 'image/jpeg'
  },
  initialize: function initialize(url, options) {
    // (String, Object)
    this._url = url;
    var wmtsParams = external_L_default.a.extend({}, this.defaultWmtsParams),
        tileSize = options.tileSize || this.options.tileSize;
    options.rowSign = options.rowSign || "tl";

    if (options.detectRetina && external_L_default.a.Browser.retina) {
      wmtsParams.width = wmtsParams.height = tileSize * 2;
    } else {
      wmtsParams.width = wmtsParams.height = tileSize;
    }

    for (var i in options) {
      // all keys that are not TileLayer options go to WMTS params
      if (!this.options.hasOwnProperty(i) && i != "matrixIds") {
        wmtsParams[i] = options[i];
      }
    }

    this.wmtsParams = wmtsParams;
    this.matrixIds = options.matrixIds || this.getDefaultMatrix();
    external_L_default.a.setOptions(this, options);
  },

  /**
   * 添加图层到地图
   * @method L.TileLayer.WMTS#onAdd
   * @param {L.Map} map 	- 地图对象
   */
  onAdd: function onAdd(map) {
    external_L_default.a.TileLayer.prototype.onAdd.call(this, map);
  },
  getTileUrl: function getTileUrl(tilePoint) {
    // (Point, Number) -> String
    var map = this._map;
    var crs = map.options.crs;
    var tileSize = this.options.tileSize;
    var nwPoint = tilePoint.multiplyBy(tileSize); //+/-1 in order to be on the tile

    nwPoint.x += 1;
    nwPoint.y -= 1;
    var sePoint = nwPoint.add(new external_L_default.a.Point(tileSize, tileSize));
    var nw = crs.project(map.unproject(nwPoint));
    var se = crs.project(map.unproject(sePoint));
    var tilewidth = se.x - nw.x;
    var zoom = this._getZoomForUrl() - this.getZoomOffset();
    var scale = map.getScales()[zoom]; //用当前的scale去匹配matrixIds

    var matrix = this.getMatrixIdByScale(scale);

    if (!matrix) {
      matrix = this.getMatrixIdByDefaultScale(scale);
    }

    var ident = matrix.identifier;
    var X0 = matrix.topLeftCorner.lng;
    var Y0 = matrix.topLeftCorner.lat;
    var tilecol = Math.round((nw.x - X0) / tilewidth);
    var tilerow;

    if (this.options.rowSign == "tl") {
      tilerow = -Math.round((nw.y - Y0) / tilewidth);
    } else {
      tilerow = -Math.round((Y0 - nw.y) / tilewidth) - 1;
    }

    var url = external_L_default.a.Util.template(this._url, {
      s: this._getSubdomain(tilePoint)
    });
    return url + external_L_default.a.Util.getParamString(this.wmtsParams, url) + "&tilematrix=" + ident + "&tilerow=" + tilerow + "&tilecol=" + tilecol;
  },
  getTileXY: function getTileXY(tilePoint) {
    var map = this._map;
    var crs = map.options.crs;
    var tileSize = this.options.tileSize;
    var nwPoint = tilePoint.multiplyBy(tileSize); //+/-1 in order to be on the tile

    nwPoint.x += 1;
    nwPoint.y -= 1;
    var sePoint = nwPoint.add(new external_L_default.a.Point(tileSize, tileSize));
    var nw = crs.project(map.unproject(nwPoint));
    var se = crs.project(map.unproject(sePoint));
    var tilewidth = se.x - nw.x;
    var zoom = this._getZoomForUrl() - this.getZoomOffset();
    var scale = map.getScales()[zoom]; //用当前的scale去匹配matrixIds

    var matrix = this.getMatrixIdByScale(scale);

    if (!matrix) {
      matrix = this.getMatrixIdByDefaultScale(scale);
    }

    var X0 = matrix.topLeftCorner.lng;
    var Y0 = matrix.topLeftCorner.lat;
    var tilecol = Math.round((nw.x - X0) / tilewidth);
    var tilerow;

    if (this.options.rowSign == "tl") {
      tilerow = -Math.round((nw.y - Y0) / tilewidth);
    } else {
      tilerow = -Math.round((Y0 - nw.y) / tilewidth) - 1;
    }

    return {
      col: tilecol,
      row: tilerow
    };
  },
  setParams: function setParams(params, noRedraw) {
    external_L_default.a.extend(this.wmtsParams, params);

    if (!noRedraw) {
      this.redraw();
    }

    return this;
  },
  getMatrixIdByScale: function getMatrixIdByScale(scale) {
    var matrix;

    for (var i = 0; i < this.matrixIds.length; i++) {
      var scaleDenominator = this.matrixIds[i].scaleDenominator;
      var ratio = parseFloat(scaleDenominator) / parseFloat(scale);

      if (ratio > 0.9 && ratio < 1.1) {
        matrix = this.matrixIds[i];
        break;
      }
    }

    return matrix;
  },
  getZoomOffset: function getZoomOffset() {
    var offset = 0;

    if (this._map.options.scales) {
      var firstScale = this.matrixIds[0].scaleDenominator;

      var defaultSacles = this._map.defauleScales();

      for (var i = 0; i < defaultSacles.length; i++) {
        var scaleDenominator = defaultSacles[i];
        var ratio = parseFloat(scaleDenominator) / parseFloat(firstScale);

        if (ratio > 0.9 && ratio < 1.1) {
          offset = i;
          break;
        }
      }
    }

    return offset;
  },
  get3857Matrix: function get3857Matrix() {
    var scales = this._map.getScales();

    var matrixIds = [];

    for (var i = 0; i < 21; i++) {
      matrixIds[i] = {
        identifier: "" + i,
        scaleDenominator: scales[i],
        topLeftCorner: new external_L_default.a.LatLng(20037508.3428, -20037508.3428)
      };
    }

    return matrixIds;
  },
  get4326Matrix: function get4326Matrix() {
    var scales = this._map.getScales();

    var matrixIds = [];

    for (var i = 0; i < 21; ++i) {
      matrixIds[i] = {
        identifier: "" + i,
        scaleDenominator: scales[i],
        topLeftCorner: new external_L_default.a.LatLng(90, -180)
      };
    }

    return matrixIds;
  },
  getDefaultMatrix: function getDefaultMatrix() {
    var map = this._map;
    var crs = map.options.crs;
    var matrixIds;

    if (crs.code == "EPSG:4326") {
      matrixIds = this.get4326Matrix();
    } else {
      matrixIds = this.get3857Matrix();
    }

    return matrixIds;
  },
  getMatrixIdByDefaultScale: function getMatrixIdByDefaultScale(scale) {
    var matrixIds = this.getDefaultMatrix();
    var matrix;

    for (var i = 0; i < matrixIds.length; i++) {
      var scaleDenominator = matrixIds[i].scaleDenominator;
      var ratio = parseFloat(scaleDenominator) / parseFloat(scale);

      if (ratio > 0.9 && ratio < 1.1) {
        matrix = matrixIds[i];
        break;
      }
    }

    return matrix;
  }
});
var wmtsLayer = function wmtsLayer(url, options) {
  return new WMTSLayer(url, options);
};
external_L_default.a.geoway.wmtsLayer = wmtsLayer;
external_L_default.a.geoway.WMTSLayer = WMTSLayer;
external_L_default.a.TileLayer.WMTS = WMTSLayer;
external_L_default.a.tileLayer.wmts = wmtsLayer;
// EXTERNAL MODULE: ./src/util/FetchRequest.js
var FetchRequest = __webpack_require__(3);

// CONCATENATED MODULE: ./src/layer/TileImageLayer.js



var ImageMapLayer = external_L_default.a.TileLayer.extend({
  initialize: function initialize(url, options) {
    this._url = url;
    external_L_default.a.setOptions(this, options);
  },
  getTileUrl: function getTileUrl(coords) {
    var data = {
      r: external_L_default.a.Browser.retina ? '@2x' : '',
      s: this._getSubdomain(coords),
      x: coords.x,
      y: coords.y,
      z: this._getZoomForUrl()
    };

    if (this._map && !this._map.options.crs.infinite) {
      var invertedY = this._globalTileRange.max.y - coords.y;

      if (this.options.tms) {
        data['y'] = invertedY;
      }

      data['-y'] = invertedY;
    }

    external_L_default.a.extend(data, this.options);
    var url = this._url + "/map/data?tileSize=" + data.tileSize + "&row=" + data.y + "&col=" + data.x + "&level=" + data.z;

    if (data.style) {
      url += "&style=" + data.style;
    }

    if (data.code) {
      url += "&code=" + data.code;
    }

    return url;
  },

  /**
   * 渲染样式保存
   * */
  saveStyle: function saveStyle(json, callback) {
    var url = this._url + "/styleConfig";
    var resource = {
      styleconfigjson: json ? JSON.stringify(json) : ''
    };
    FetchRequest["a" /* default */].post(url, resource).then(function (data) {
      if (callback) {
        callback(data);
      }
    });
  },

  /**
   * 渲染样式临时设置
   * 分四种渲染方式
   *  dem山体阴影
   * 	{"mode":"hillshade","Altidude":50,"Azimuth":210,"ZFactor":1}
   * 	dem坡向
   * 	{"mode":"slope","UsePercent":"true","Scale":15}
   * 	dem坡向
   * 	{"mode":"aspect","ZeroForFlat":"true"}
   * 	dom波段组合
   * 	{"mode":"composite","ReadBandIndex":"2,0,1"}
   *
   * */
  setStyle: function setStyle(json) {
    this.options.style = encodeURIComponent(JSON.stringify(json));
    this.redraw();
  },
  setCode: function setCode(code) {
    this.options.code = code;
    this.redraw();
  },
  clearStyle: function clearStyle() {
    this.options.style = null;
    this.options.code = null;
    this.redraw();
  }
});
var imageMapLayer = function imageMapLayer(url, options) {
  return new ImageMapLayer(url, options);
};
external_L_default.a.geoway.imageMapLayer = imageMapLayer;
external_L_default.a.geoway.ImageMapLayer = ImageMapLayer;
external_L_default.a.ImageMapLayer = ImageMapLayer;
external_L_default.a.tileLayer.image = imageMapLayer;
// CONCATENATED MODULE: ./src/layer/SingleImageLayer.js


var SingleImageLayer = external_L_default.a.Layer.extend({
  options: {
    opacity: 1,
    zIndex: 1,
    pane: 'tilePane'
  },
  _params: null,
  initialize: function initialize(url, params, options) {
    this.url = url;
    this._params = params;
    external_L_default.a.Util.setOptions(this, options);
  },
  onAdd: function onAdd(map) {
    map.on('moveend', this._update, this); // if we had an image loaded and it matches the
    // current bounds show the image otherwise remove it

    if (this._currentImage && this._currentImage._bounds.equals(this._map.getBounds())) {
      map.addLayer(this._currentImage);
    } else if (this._currentImage) {
      this._map.removeLayer(this._currentImage);

      this._currentImage = null;
    }

    this._update();
  },
  onRemove: function onRemove() {
    if (this._currentImage) {
      this._map.removeLayer(this._currentImage);
    }

    this._map.off('moveend', this._update, this);
  },
  getOpacity: function getOpacity() {
    return this.options.opacity;
  },
  setOpacity: function setOpacity(opacity) {
    this.options.opacity = opacity;

    if (this._currentImage) {
      this._currentImage.setOpacity(opacity);
    }

    return this;
  },
  getZIndex: function getZIndex() {
    return this.options.zIndex;
  },
  setZIndex: function setZIndex(zIndex) {
    this.options.zIndex = zIndex;

    if (this._currentImage) {
      this._currentImage.setZIndex(zIndex);
    }

    return this;
  },
  redraw: function redraw() {
    this._update();
  },
  _renderImage: function _renderImage(url, bounds, contentType) {
    if (this._map) {
      // if no output directory has been specified for a service, MIME data will be returned
      if (contentType) {
        url = 'data:' + contentType + ';base64,' + url;
      } // create a new image overlay and add it to the map
      // to start loading the image
      // opacity is 0 while the image is loading


      var image = new external_L_default.a.ImageOverlay(url, bounds, {
        opacity: this.options.opacity,
        crossOrigin: this.options.useCors,
        pane: this.options.pane || this.getPane(),
        interactive: this.options.interactive,
        zIndex: this.options.zIndex
      }).addTo(this._map); // once the image loads

      image.once('load', function (e) {
        if (this._map) {
          var newImage = e.target;
          var oldImage = this._currentImage; // if the bounds of this image matches the bounds that
          // _renderImage was called with and we have a map with the same bounds
          // hide the old image if there is one and set the opacity
          // of the new image otherwise remove the new image

          if (newImage._bounds.equals(bounds) && newImage._bounds.equals(this._map.getBounds())) {
            this._currentImage = newImage;

            if (this._map && this._currentImage._map) {
              this._currentImage.setOpacity(this.options.opacity);

              this._currentImage.setZIndex(this.options.zIndex);
            } else {
              this._currentImage._map.removeLayer(this._currentImage);
            }

            if (oldImage && this._map) {
              this._map.removeLayer(oldImage);
            }

            if (oldImage && oldImage._map) {
              oldImage._map.removeLayer(oldImage);
            }
          } else {
            this._map.removeLayer(newImage);
          }
        }

        this.fire('load', {
          bounds: bounds
        });
      }, this);
      this.fire('loading', {
        bounds: bounds
      });
    }
  },
  _buildExportParams: function _buildExportParams() {
    var bounds = this._map.getBounds();

    var size = this._map.getSize();

    var ne = this._map.options.crs.project(bounds._northEast);

    var sw = this._map.options.crs.project(bounds._southWest);

    var top = this._map.latLngToLayerPoint(bounds._northEast);

    var bottom = this._map.latLngToLayerPoint(bounds._southWest);

    if (top.y > 0 || bottom.y < size.y) {
      size.y = bottom.y - top.y;
    }

    var params = {
      xmin: sw.x,
      ymin: sw.y,
      xmax: ne.x,
      ymax: ne.y,
      width: size.x,
      height: size.y
    };
    return params;
  },
  _update: function _update() {
    if (!this._map) {
      return;
    }

    var zoom = this._map.getZoom();

    var bounds = this._map.getBounds();

    if (this._animatingZoom) {
      return;
    }

    if (this._map._panTransition && this._map._panTransition._inProgress) {
      return;
    }

    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
      if (this._currentImage) {
        this._currentImage._map.removeLayer(this._currentImage);

        this._currentImage = null;
      }

      return;
    }

    var params = this._buildExportParams();

    this._requestExport(params, bounds);
  },
  _requestExport: function _requestExport(params, bounds) {
    var url = external_L_default.a.Util.template(this.url, external_L_default.a.Util.extend(params));

    if (this._params) {
      url += external_L_default.a.Util.getParamString(this._params, url);
    }

    this._renderImage(url, bounds);
  }
});
var singleImageLayer = function singleImageLayer(url, options) {
  return new SingleImageLayer(url, options);
};
external_L_default.a.geoway.singleImageLayer = singleImageLayer;
external_L_default.a.geoway.SingleImageLayer = SingleImageLayer;
// CONCATENATED MODULE: ./src/util/uuid.js
function UUID() {
  this.id = this.createUUID();
}

UUID.prototype.valueOf = function () {
  return this.id;
};

UUID.prototype.toString = function () {
  return this.id;
};

UUID.prototype.createUUID = function () {
  var c = new Date(1582, 10, 15, 0, 0, 0, 0);
  var f = new Date();
  var h = f.getTime() - c.getTime();
  var i = UUID.getIntegerBits(h, 0, 31);
  var g = UUID.getIntegerBits(h, 32, 47);
  var e = UUID.getIntegerBits(h, 48, 59) + "2";
  var b = UUID.getIntegerBits(UUID.rand(4095), 0, 7);
  var d = UUID.getIntegerBits(UUID.rand(4095), 0, 7);
  var a = UUID.getIntegerBits(UUID.rand(8191), 0, 7) + UUID.getIntegerBits(UUID.rand(8191), 8, 15) + UUID.getIntegerBits(UUID.rand(8191), 0, 7) + UUID.getIntegerBits(UUID.rand(8191), 8, 15) + UUID.getIntegerBits(UUID.rand(8191), 0, 15);
  return i + g + e + b + d + a;
};

UUID.getIntegerBits = function (f, g, b) {
  var a = UUID.returnBase(f, 16);
  var d = new Array();
  var e = "";
  var c = 0;

  for (c = 0; c < a.length; c++) {
    d.push(a.substring(c, c + 1));
  }

  for (c = Math.floor(g / 4); c <= Math.floor(b / 4); c++) {
    if (!d[c] || d[c] == "") {
      e += "0";
    } else {
      e += d[c];
    }
  }

  return e;
};

UUID.returnBase = function (c, d) {
  var e = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];

  if (c < d) {
    var b = e[c];
  } else {
    var f = "" + Math.floor(c / d);
    var a = c - f * d;

    if (f >= d) {
      var b = this.returnBase(f, d) + e[a];
    } else {
      var b = e[f] + e[a];
    }
  }

  return b;
};

UUID.rand = function (a) {
  return Math.floor(Math.random() * a);
};

/* harmony default export */ var uuid = (UUID);
// CONCATENATED MODULE: ./src/layer/datasource/DataSource.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Created by kongjian on 2017/6/30.
 */




var DataSource_DataSource = function DataSource() {
  _classCallCheck(this, DataSource);

  //数据源id
  this.id = new uuid().valueOf(); //数据源类型

  this.type = ""; //key为文件名，value为image对象

  this.textures = {};
};

external_L_default.a.geoway.DataSource = DataSource_DataSource;
/* harmony default export */ var datasource_DataSource = (DataSource_DataSource);
// EXTERNAL MODULE: ./src/util/es6-promise.js
var es6_promise = __webpack_require__(2);

// CONCATENATED MODULE: ./src/ext/Version.js
var Version = 'jssdk_bate@ leaflet 3.0.10';
/* harmony default export */ var ext_Version = (Version);
// CONCATENATED MODULE: ./src/layer/datasource/URLDataSource.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function URLDataSource_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Created by kongjian on 2017/6/30.
 */






var URLDataSource_URLDataSource = /*#__PURE__*/function (_DataSource) {
  _inherits(URLDataSource, _DataSource);

  var _super = _createSuper(URLDataSource);

  function URLDataSource() {
    var _this;

    URLDataSource_classCallCheck(this, URLDataSource);

    _this = _super.call(this); //多个服务器url的域名，用于解决一个域名只有6条请求管线的限制

    _this.urlArray = []; //数据源类型

    _this.type = 'URLDataSource'; //注记数据的请求url

    _this.url = null; //样式文件的请求接口url

    _this.styleUrl = null; //样式文件Id

    _this.styleId = 'style'; //过滤条件

    _this.filter = null; //纹理

    _this.textures = {}; //过滤条件字符

    _this.control = null; //过滤的id

    _this.controlId = null; // 不带过滤条件的url

    _this.sourceUrl = null; //域名

    _this.host = ''; //服务名

    _this.servername = '';
    _this.newEngine = false;
    _this.serverInfo = {};
    return _this;
  }
  /**
   * 加载样式文件和纹理数据
   */


  _createClass(URLDataSource, [{
    key: "loadStyle",
    value: function loadStyle(styleType) {
      var def0 = new es6_promise["a" /* Deferred */]();
      var def1 = new es6_promise["a" /* Deferred */]();
      var def2 = new es6_promise["a" /* Deferred */]();
      var def3 = new es6_promise["a" /* Deferred */](); //解析url，获取servername,styleId

      this.parseUrl();

      if (this.newEngine) {
        this.loadServerInfo();
      }

      var queryParam = this.url.split('?')[1];

      if (!this.sourceUrl) {
        this.sourceUrl = this.url + '&clientVersion=' + ext_Version;
        this.url = this.url + '&clientVersion=' + ext_Version;
      }

      if (this.control && this.isIE()) {
        //设置过滤条件
        Object(es6_promise["c" /* getJSON */])({
          type: 'post',
          url: this.host + '/mapserver/vmap/' + this.servername + '/setControl',
          data: 'control=' + this.control,
          dataType: 'json'
        }).then(function (result) {
          this.controlId = result.id;
          this.url = this.sourceUrl + '&controlId=' + result.id;
          def0.resolve();
        }.bind(this));
      } else {
        if (this.control) {
          this.url = this.sourceUrl + '&control=' + encodeURIComponent(this.control);
        } else {
          this.url = this.sourceUrl;
        }

        def0.resolve();
      }

      if (!styleType) {
        styleType = 'label';
      }

      if (this.styleId == '_default__') {
        var styleStr = 'let layers = drawer.getAllLayer(); layers.setStyle(function(level , get){' + ' return {"type":"_default__","_id":"1","show":true,"pointFillStyle":"#ff0000","radius":5,"lineFillStyle":"#00ff00","lineWidth":3 }' + '})';
        this.styleFun = new Function("drawer", "level", styleStr);
        return [def0];
      } //请求样式文件


      Object(es6_promise["c" /* getJSON */])({
        url: this.host + '/mapserver/styleInfo/' + this.servername + '/' + this.styleId + '/' + styleType + '/style.js?' + Math.random() + '&' + queryParam,
        dataType: 'text'
      }).then(function (result) {
        if (this.newEngine) {
          this.styleFun = new Function("render", "level", result);
        } else {
          this.styleFun = new Function("drawer", "level", result);
        }

        def1.resolve();
      }.bind(this)); //请求图标纹理

      Object(es6_promise["c" /* getJSON */])({
        url: this.host + '/mapserver/styleInfo/' + this.servername + '/' + this.styleId + '/label/texture.js?' + Math.random() + '&' + queryParam,
        dataType: 'text'
      }).then(function (result) {
        var textures = JSON.parse(result);
        var totalCount = 0;

        for (var i in textures) {
          if (textures[i]) {
            totalCount++;
          }
        }

        if (totalCount == 0) {
          def2.resolve();
          return;
        }

        var count = 0;

        for (var key in textures) {
          var img = new Image();
          img.name = key;

          img.onload = function (data) {
            count++;
            var name = data.target.name;
            this.textures[name] = data.target;

            if (count == totalCount) {
              def2.resolve();
            }
          }.bind(this);

          img.src = textures[key];
        }
      }.bind(this));
      this.loadFonts(queryParam, def3);
      return [def0, def1, def2, def3];
    }
  }, {
    key: "loadServerInfo",
    value: function loadServerInfo() {
      var _this2 = this;

      if (this.host && this.servername) {
        Object(es6_promise["c" /* getJSON */])({
          type: 'get',
          url: this.host + '/mapserver/serverInfo/' + this.servername + '.json',
          dataType: 'json'
        }).then(function (results) {
          if (results && results.layerMap) {
            for (var key in results.layerMap) {
              _this2.serverInfo[key] = {
                geometryType: results.layerMap[key].geometryType,
                fieldsConfig: results.layerMap[key].fields
              };
            }
          }
        });
      }
    }
  }, {
    key: "loadFonts",
    value: function loadFonts(queryParam, def3) {
      Object(es6_promise["c" /* getJSON */])({
        url: this.host + '/mapserver/styleInfo/fonts/' + this.servername + '/' + this.styleId + '/list.json?' + Math.random() + '&' + queryParam,
        dataType: 'json'
      }).then(function (list) {
        var loadFontRequest = [];

        for (var i = 0; i < list.length; i++) {
          var item = list[i];
          loadFontRequest.push(this.loadFont(item));
        }

        Promise.all(loadFontRequest).then(function () {
          def3.resolve();
        });
      }.bind(this), function (err) {
        def3.resolve();
      });
    }
  }, {
    key: "loadFont",
    value: function loadFont(fontParsm) {
      var def0 = new es6_promise["a" /* Deferred */]();
      var fontFaceName = fontParsm['font-family'];
      var fontFileUrl = this.getBrowserFontUrl(fontParsm['urls']);
      console.log(fontFileUrl);
      var request = new XMLHttpRequest();
      var that = this;
      request.addEventListener('readystatechange', function () {
        if (request.readyState == 4) {
          if ('fonts' in document) {
            var junction_font = new FontFace(fontFaceName, request.response);
            junction_font.load().then(function (loaded_face) {
              document.fonts.add(loaded_face);
              def0.resolve();
            })["catch"](function (error) {
              console.log("加载字体失败" + fontFaceName + error);
            });
          } else {
            if ('head' in document) {
              var base64FontHeader = "data:application/x-font-eot;charset=utf-8;base64,";
              var codes = new Uint8Array(request.response);
              var bin = "";

              for (var i = 0; i < codes.byteLength; i++) {
                bin += String.fromCharCode(codes[i]);
              }

              var base64String = btoa(bin);
              var dataUrl = base64FontHeader + base64String;
              var cssText = "@font-face{font-family:" + fontFaceName + ";src:url('" + dataUrl + "');}";
              that.createStyleTag(cssText);
              def0.resolve();
            }
          }
        }
      });
      request.open('GET', fontFileUrl);
      request.responseType = 'arraybuffer';
      request.send();
      return def0;
    }
  }, {
    key: "checkFont",
    value: function checkFont(name) {
      var values = document.fonts.values();
      var isHave = false;
      var item = values.next();

      while (!item.done && !isHave) {
        var fontFace = item.value;

        if (fontFace.family == name) {
          isHave = true;
        }

        item = values.next();
      }

      return isHave;
    }
  }, {
    key: "createStyleTag",
    value: function createStyleTag(cssText) {
      if (cssText) {
        var head = document.head || document.getElementsByTagName('head')[0];
        var style = document.createElement('style');
        style.appendChild(document.createTextNode(cssText));
        head.appendChild(style);
      }
    }
    /**
     * 解析url
     */

  }, {
    key: "parseUrl",
    value: function parseUrl() {
      var urlParts = this.url.split('?');
      var urlPartOne = urlParts[0].split('/mapserver/');
      this.host = urlPartOne[0];
      this.servername = urlPartOne[1].split('/')[1];
      var params = urlParts[1].split('&');

      for (var i = 0; i < params.length; i++) {
        var param = params[i];
        var keyValue = param.split('=');

        if (keyValue[0] == 'styleId') {
          this.styleId = keyValue[1];
          return;
        }
      }
    }
    /**
     * 设置过滤条件
     */

  }, {
    key: "setFilter",
    value: function setFilter(filter) {
      this.control = null;

      if (!this.url || !filter || filter.layers.length == 0 && filter.order.length == 0) {
        return;
      }

      for (var i = 0; i < filter.layers.length; i++) {
        var filterLayer = filter.layers[i];

        if (!filterLayer.id) {
          filter.layers.splice(i, 1);
        }
      }

      this.control = JSON.stringify(filter);
    }
  }, {
    key: "getTexture",
    value: function getTexture(key) {
      return this.textures[key];
    }
  }, {
    key: "addTexture",
    value: function addTexture(key, texture) {
      this.textures[key] = texture;
    }
    /**
     * 是否为ie浏览器,ie9 除外，ie9无法跨域发送post带数据的请求
     */

  }, {
    key: "isIE",
    value: function isIE() {
      if (!!window.ActiveXObject || "ActiveXObject" in window) {
        //ie9 除外，ie9无法跨域发送post带数据的请求
        var b_version = navigator.appVersion;
        var version = b_version.split(";");

        if (version[1]) {
          var trim_Version = version[1].replace(/[ ]/g, "");

          if (trim_Version == 'MSIE9.0') {
            return false;
          }
        }

        return true;
      } else return false;
    }
  }, {
    key: "getBrowserFontUrl",
    value: function getBrowserFontUrl(urls) {
      var urlHead = this.host + '/mapserver/styleInfo/fonts/';
      var explorer = navigator.userAgent;
      var isIE = !!window.ActiveXObject || "ActiveXObject" in window; //ie

      if (explorer.indexOf("MSIE") > 0 || isIE) {
        return urlHead + urls['eot'].url;
      } //firefox
      else if (explorer.indexOf("Firefox") > 0) {
          return urlHead + urls['woff'].url;
        } //Chrome
        else if (explorer.indexOf("Chrome") > 0) {
            return urlHead + urls['ttf'].url;
          } //Opera
      //else if (explorer.indexOf("Opera") > 0) {}
      //Safari
      //else if (explorer.indexOf("Safari") > 0) {}
      //Netscape
      //else if (explorer.indexOf("Netscape") > 0) {}


      return null;
    }
  }]);

  return URLDataSource;
}(datasource_DataSource);

;
external_L_default.a.geoway.URLDataSource = URLDataSource_URLDataSource;
/* harmony default export */ var datasource_URLDataSource = (URLDataSource_URLDataSource);
// CONCATENATED MODULE: ./src/layer/datasource/LocalDataSource.js
function LocalDataSource_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { LocalDataSource_typeof = function _typeof(obj) { return typeof obj; }; } else { LocalDataSource_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return LocalDataSource_typeof(obj); }

function LocalDataSource_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function LocalDataSource_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function LocalDataSource_createClass(Constructor, protoProps, staticProps) { if (protoProps) LocalDataSource_defineProperties(Constructor.prototype, protoProps); if (staticProps) LocalDataSource_defineProperties(Constructor, staticProps); return Constructor; }

function LocalDataSource_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) LocalDataSource_setPrototypeOf(subClass, superClass); }

function LocalDataSource_setPrototypeOf(o, p) { LocalDataSource_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return LocalDataSource_setPrototypeOf(o, p); }

function LocalDataSource_createSuper(Derived) { var hasNativeReflectConstruct = LocalDataSource_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = LocalDataSource_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = LocalDataSource_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return LocalDataSource_possibleConstructorReturn(this, result); }; }

function LocalDataSource_possibleConstructorReturn(self, call) { if (call && (LocalDataSource_typeof(call) === "object" || typeof call === "function")) { return call; } return LocalDataSource_assertThisInitialized(self); }

function LocalDataSource_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function LocalDataSource_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function LocalDataSource_getPrototypeOf(o) { LocalDataSource_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return LocalDataSource_getPrototypeOf(o); }





/**
 * Created by kongjian on 2017/6/30.
 */

var LocalDataSource_LocalDataSource = /*#__PURE__*/function (_DataSource) {
  LocalDataSource_inherits(LocalDataSource, _DataSource);

  var _super = LocalDataSource_createSuper(LocalDataSource);

  function LocalDataSource() {
    var _this;

    LocalDataSource_classCallCheck(this, LocalDataSource);

    _this = _super.call(this); //数据源类型

    _this.type = 'LocalDataSource'; //本地要素集合

    _this.features = []; //图标url Map：{name:1.png,value:'http://localhost:8080/mapserver/1.png'}

    _this.textureUrls = {};
    return _this;
  }
  /**
   * 添加feature
   * Parameters :
   * feature
   */


  LocalDataSource_createClass(LocalDataSource, [{
    key: "addFeature",
    value: function addFeature(feature) {
      this.features.push(feature);
    }
    /**
     * 添加url图标
     * Parameters :
     * name 图标名称,如：1.png
     * url 图标的请求地址
     */

  }, {
    key: "addTextureUrl",
    value: function addTextureUrl(name, url) {
      this.textureUrls[name] = url;
    }
    /**
     * 移除url图标
     * Parameters :
     * name 图标名称,如：1.png
     */

  }, {
    key: "removeTextureUrl",
    value: function removeTextureUrl(name) {
      delete this.textureUrls[name];
    }
    /**
     * 加载纹理
     */

  }, {
    key: "loadTexture",
    value: function loadTexture() {
      var def = new es6_promise["a" /* Deferred */]();
      var totalCount = 0;

      for (var i in this.textureUrls) {
        if (this.textureUrls[i]) {
          totalCount++;
        }
      }

      if (totalCount == 0) {
        def.resolve();
        return;
      }

      var count = 0;

      for (var key in this.textureUrls) {
        var img = new Image();
        img.name = key;

        img.onload = function (data) {
          count++;
          var name = data.target.name;
          this.textures[name] = data.target;

          if (count == totalCount) {
            def.resolve();
          }
        }.bind(this);

        img.src = this.textureUrls[key];
      }

      return def;
    }
    /**
     * 通过featureId移除feature
     * Parameters :
     * featureId
     */

  }, {
    key: "removeFeatureById",
    value: function removeFeatureById(featureId) {
      for (var i = 0; i < this.features.length; i++) {
        var feature = this.features[i];

        if (feature.id == featureId) {
          this.features.splice(i, 1);
        }
      }
    }
  }]);

  return LocalDataSource;
}(datasource_DataSource);

;
external_L_default.a.geoway.LocalDataSource = LocalDataSource_LocalDataSource;
/* harmony default export */ var datasource_LocalDataSource = (LocalDataSource_LocalDataSource);
// EXTERNAL MODULE: ./src/filter/Filter.js
var Filter = __webpack_require__(19);

// EXTERNAL MODULE: ./src/filter/FilterLayer.js
var FilterLayer = __webpack_require__(16);

// CONCATENATED MODULE: ./src/layer/vector/draw/GXYZUtil.js
function GXYZUtil_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GXYZUtil_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function GXYZUtil_createClass(Constructor, protoProps, staticProps) { if (protoProps) GXYZUtil_defineProperties(Constructor.prototype, protoProps); if (staticProps) GXYZUtil_defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by kongjian on 2017/6/26.
 */







var GXYZUtil_GXYZUtil = /*#__PURE__*/function () {
  function GXYZUtil() {
    GXYZUtil_classCallCheck(this, GXYZUtil);

    this.tileSize = 256;
  }
  /**
   * 设置过滤条件
   */


  GXYZUtil_createClass(GXYZUtil, [{
    key: "setFilter",
    value: function setFilter(filter, callback) {
      for (var i = 0; i < filter.layers.length; i++) {
        var filterLayer = filter.layers[i];

        if (!filterLayer.id) {
          filter.layers.splice(i, 1);
        }
      }

      var control = JSON.stringify(filter);

      if (this.isIE()) {
        //设置过滤条件
        Object(es6_promise["c" /* getJSON */])({
          type: 'post',
          url: this.host + '/mapserver/vmap/' + this.servername + '/setControl',
          data: 'control= ' + control,
          dataType: 'json'
        }).then(function (result) {
          result.isIE = true;
          callback(result);
        }.bind(this));
      } else {
        var result = {
          isIE: false,
          id: encodeURIComponent(control)
        };
        callback(result);
      }
    }
    /**
     * 解析url
     */

  }, {
    key: "parseUrl",
    value: function parseUrl(url) {
      var urlParts = url.split('?'); // var urlPartOne = urlParts[0].split('/mapserver/vmap/');

      var urlPartOne = urlParts[0].split('/mapserver/');
      this.host = urlPartOne[0];
      this.servername = urlPartOne[1].split('/')[1];
      var params = urlParts[1].split('&');

      for (var i = 0; i < params.length; i++) {
        var param = params[i];
        var keyValue = param.split('=');

        if (keyValue[0] == 'styleId') {
          this.styleId = keyValue[1];
          return;
        }
      }
    }
    /**
     * 拾取要素
     * Parameters :
     * level 要拾取的要素所在的层级
     * lat 经纬度值
     * lon 经纬度值
     * callback - 拾取到要素后的回调函数
     */

  }, {
    key: "pickupFeaturesBylatlng",
    value: function pickupFeaturesBylatlng(level, control, controlId, lat, lon, callback) {
      var url = this.host + '/mapserver/' + this.servername + '/' + this.styleId + '/pickup?level=' + level + '&lon=' + lon + '&lat=' + lat + '&clientVersion=' + ext_Version;

      if (control) {
        url = url + '&control=' + control;
      }

      if (controlId) {
        url = url + '&controlId=' + controlId;
      }

      Object(es6_promise["c" /* getJSON */])({
        url: url,
        dataType: "json"
      }).then(function (features) {
        callback(features);
      }, function () {
        callback([]);
      });
    }
    /**
     * 拾取要素
     * Parameters :
     * row - 要拾取的要素所在的行
     * col - 要拾取的要素所在的列
     * level - 要拾取的要素所在的层级
     * x - 要拾取的要素所在瓦片内的x坐标
     * y - 要拾取的要素所在瓦片内y坐标
     * control - 过滤的json对象
     * controlId - 过滤对象在服务器上存的key
     * callback - 拾取到要素后的回调函数
     */

  }, {
    key: "pickupFeatures",
    value: function pickupFeatures(row, col, level, x, y, control, controlId, callback) {
      var url = this.host + '/mapserver/pickup/' + this.servername + '/getData?x=' + col + '&y=' + row + '&l=' + level + '&pixelX=' + x + '&pixelY=' + y + '&styleId=' + this.styleId + '&tilesize=' + this.tileSize + '&clientVersion=' + ext_Version;

      if (control) {
        url = url + '&control=' + control;
      }

      if (controlId) {
        url = url + '&controlId=' + controlId;
      }

      Object(es6_promise["c" /* getJSON */])({
        url: url,
        dataType: "json"
      }).then(function (features) {
        callback(features);
      }, function () {
        callback([]);
      });
    }
    /**
     * 构造高亮的filter
     * Parameters :
     * features - 要素数组
     * style - 高亮样式 如：{color:"red",opacity:0.8};
     */
    // CreateHighlightFilter(layerFeatures,style){
    //     var filter = new Filter();
    //     filter.otherDisplay = false;
    //
    //     for(var layerId in layerFeatures){
    //         var fs = layerFeatures[layerId];
    //         var hasFid = false;
    //         for(var fid in fs){
    //             var filterLayer = new FilterLayer();
    //             filterLayer.id = layerId;
    //             filterLayer.idFilter = fid;
    //             filterLayer.color = style;
    //             filter.addFilterLayer(filterLayer);
    //             hasFid = true;
    //         }
    //         if(!hasFid){
    //             var filterLayer = new FilterLayer();
    //             filterLayer.id = layerId;
    //             filterLayer.color = style;
    //             filter.addFilterLayer(filterLayer);
    //         }
    //     }
    //     return filter;
    // };

  }, {
    key: "CreateHighlightFilter",
    value: function CreateHighlightFilter(layerFeatures, style) {
      var filter = new Filter["a" /* default */]();
      filter.otherDisplay = false;

      for (var layerId in layerFeatures) {
        var fs = layerFeatures[layerId];
        var filterLayer = new FilterLayer["a" /* default */]();
        filterLayer.id = layerId;
        filterLayer.color = style;
        var idFilter = '';

        for (var fid in fs) {
          idFilter = idFilter + fid + ',';
        }

        if (idFilter.length > 0) {
          idFilter = idFilter.substr(0, idFilter.length - 1);
          filterLayer.idFilter = idFilter;
        }

        filter.addFilterLayer(filterLayer);
      }

      return filter;
    }
    /**
     * 构造高亮的filter,每个要素都有高亮样式
     * Parameters :
     * layerFeatures - 要素数组
     */

  }, {
    key: "CreateEveryHighlightFilter",
    value: function CreateEveryHighlightFilter(layerFeatures) {
      var filter = new Filter["a" /* default */]();
      filter.otherDisplay = false;

      for (var layerId in layerFeatures) {
        var fs = layerFeatures[layerId];
        var layerStyle = fs.style;
        var hasFid = false;

        for (var fid in fs) {
          var style = fs[fid].style; // style.color = style.color.replace('#','%23');

          var filterLayer = new FilterLayer["a" /* default */]();
          filterLayer.id = layerId;
          filterLayer.idFilter = fid;
          filterLayer.color = style;
          filter.addFilterLayer(filterLayer);
          hasFid = true;
        }

        if (!hasFid && layerStyle) {
          // layerStyle.color = layerStyle.color.replace('#','%23');
          var filterLayer1 = new FilterLayer["a" /* default */]();
          filterLayer1.id = layerId;
          filterLayer1.color = layerStyle;
          filter.addFilterLayer(filterLayer1);
        }
      }

      return filter;
    }
    /**
     * 是否为ie浏览器,ie9 除外，ie9无法跨域发送post带数据的请求
     */

  }, {
    key: "isIE",
    value: function isIE() {
      if (!!window.ActiveXObject || "ActiveXObject" in window) {
        //ie9 除外，ie9无法跨域发送post带数据的请求
        var b_version = navigator.appVersion;
        var version = b_version.split(";");

        if (version[1]) {
          var trim_Version = version[1].replace(/[ ]/g, "");

          if (trim_Version == 'MSIE9.0') {
            return false;
          }
        }

        return true;
      } else return false;
    }
  }]);

  return GXYZUtil;
}();

external_L_default.a.geoway.GXYZUtil = GXYZUtil_GXYZUtil;
/* harmony default export */ var draw_GXYZUtil = (GXYZUtil_GXYZUtil);
// EXTERNAL MODULE: ./src/layer/label/avoid/GDrawGeomerty.js + 1 modules
var GDrawGeomerty = __webpack_require__(14);

// CONCATENATED MODULE: ./src/layer/label/GLabelGrid.js
/**
 * Created by kongjian on 2017/9/26.
 * 后端避让后的注记，前端绘制显示图层
 */






var GLabelGrid = external_L_default.a.TileLayer.extend({
  //多个服务器url的域名，用于解决一个域名只有6条请求管线的限制
  urlArray: [],
  // 不带过滤条件的url
  sourceUrl: null,
  // 纹理图标集合
  textures: {},
  //瓦片队列
  tileQueue: [],
  //缩放比例
  ratio: 1,
  //瓦片大小
  tilesize: 256,
  //过滤json对象
  control: null,
  //过滤的id
  controlId: null,
  //是否支持注记拾取
  hitDetection: false,
  initialize: function initialize(url, options) {
    if (window.devicePixelRatio > 1.5) {
      this.ratio = 2;
    }

    if (!this.sourceUrl) {
      this.sourceUrl = url;
    }

    if (options && options.tileSize) {
      this.tilesize = options.tileSize;
    }

    this.gxyzUtil = new draw_GXYZUtil();
    this.gxyzUtil.tileSize = this.tilesize;
    this.gxyzUtil.parseUrl(url);
    this._url = url + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version;
    external_L_default.a.setOptions(this, options);

    if (options) {
      this.hitDetection = options.hitDetection;
    }

    this.on('tileunload', this._onTileRemove);
    this.on('tileload', this._onTileLoad);
    this.on('tileerror', this._onTileError);
  },
  _initContainer: function _initContainer() {
    if (this._container) {
      return;
    }

    this._container = external_L_default.a.DomUtil.create('div', 'leaflet-pane leaflet-overlay-pane');
    this.getPane().appendChild(this._container);
  },
  onAdd: function onAdd() {
    if (this.control) {
      this._url = this.sourceUrl + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&control=' + this.control;
    }

    if (this.controlId) {
      this._url = this.sourceUrl + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&controlId=' + this.controlId;
    }

    this._initContainer();

    this._levels = {};
    this._tiles = {}; //请求图标纹理

    Object(es6_promise["c" /* getJSON */])({
      url: this.gxyzUtil.host + '/mapserver/styleInfo/' + this.gxyzUtil.servername + '/' + this.gxyzUtil.styleId + '/label/texture.js',
      dataType: 'text'
    }).then(function (result) {
      var textures = JSON.parse(result);
      var totalCount = 0;

      for (var i in textures) {
        totalCount++;
      }

      if (totalCount == 0) {
        this._resetView();

        this._update();
      }

      var count = 0;

      for (var key in textures) {
        var img = new Image();
        img.name = key;

        img.onload = function (data) {
          count++;
          var name = data.target.name;
          this.textures[name] = data.target;

          if (count == totalCount) {
            this._resetView();

            this._update();
          }
        }.bind(this);

        img.src = textures[key];
      }
    }.bind(this));
  },

  /**
   * 重写构造瓦片的方法
   */
  createTile: function createTile(coords, done) {
    //从队列中取canvas，避免频繁创建canvas
    var tile = this.tileQueue.pop();

    if (!tile) {
      tile = this.initTile();
    } else {
      this._cleanTile(tile);
    }

    var url = this.getTileUrl(coords);
    Object(es6_promise["c" /* getJSON */])({
      url: url,
      dataType: 'json'
    }).then(function (data) {
      tile.data = data;

      this._tileOnLoad.apply(this, [done, tile]);
    }.bind(this), function (error) {
      this._tileOnError.apply(this, [done, tile, error]);
    }.bind(this));
    return tile;
  },

  /**
   * 获取url的方法
   */
  getTileUrl: function getTileUrl(coords) {
    var data = {
      r: external_L_default.a.Browser.retina ? '@2x' : '',
      s: this._getSubdomain(coords),
      x: coords.x,
      y: coords.y,
      z: this._getZoomForUrl()
    };

    if (this._map && !this._map.options.crs.infinite) {
      var invertedY = this._globalTileRange.max.y - coords.y;

      if (this.options.tms) {
        data['y'] = invertedY;
      }

      data['-y'] = invertedY;
    }

    if (this.urlArray.length == 0) {
      return external_L_default.a.Util.template(this._url, external_L_default.a.extend(data, this.options));
    } else {
      //从urlArray中随机取出一个url
      var len = this.urlArray.length - 1;
      var index = Math.round(Math.random() * len);
      var url = this.urlArray[index];

      var array = this._url.split('/mapserver');

      var partUrl = array[1];
      url = url + '/mapserver' + partUrl;
      return external_L_default.a.Util.template(url, external_L_default.a.extend(data, this.options));
    }
  },

  /**
   *  初始化canvas
   */
  initTile: function initTile() {
    // console.time('initTile');
    var tile = document.createElement("canvas");
    tile.style.width = this.tilesize + "px";
    tile.style.height = this.tilesize + "px";
    tile.width = this.tilesize;
    tile.height = this.tilesize;
    var ctx = tile.getContext("2d", {
      isQuality: true
    });
    tile.ctx = ctx;

    if (this.hitDetection) {
      var canvas = document.createElement("canvas");
      canvas.style.width = this.tilesize + "px";
      canvas.style.height = this.tilesize + "px";
      canvas.width = this.tilesize;
      canvas.height = this.tilesize;
      var hitCtx = canvas.getContext("2d", {
        isQuality: true
      });
      tile.hitCtx = hitCtx;
    } // console.timeEnd('initTile');


    return tile;
  },
  //移除瓦片
  _onTileRemove: function _onTileRemove(e) {
    //加入到瓦片队列
    this.tileQueue.push(e.tile);
  },

  /**
   *  重写，取消请求的操作
   */
  _abortLoading: function _abortLoading() {
    var i, tile;

    for (i in this._tiles) {
      if (this._tiles[i].coords.z !== this._tileZoom) {
        tile = this._tiles[i].el; // if (!tile.complete) { // 是否要缩放时，注记放大效果

        external_L_default.a.DomUtil.remove(tile); // }
      }
    }
  },
  _onTileLoad: function _onTileLoad(item) {
    var tile = item.tile;

    this._drawTile(tile, tile.data);

    tile.complete = true;
  },
  _onTileError: function _onTileError(item) {
    var tile = item.tile;
    tile.complete = true;
    this.tileQueue.push(tile);
  },
  _tileOnError: function _tileOnError(done, tile, e) {
    done(e, tile);
  },
  _drawTile: function _drawTile(tile, features) {
    // console.time('_drawTile');
    var ctx = tile.ctx;
    var hitCtx = tile.hitCtx;
    var featureIdMap = {};

    for (var i = 0; i < features.length; i++) {
      var feature = features[i]; //画点注记

      if (feature.type == 1) {
        feature.id = Math.round(Math.random() * 256 * 256 * 256);
        featureIdMap[feature.id] = feature;
        feature.iconImg = this.textures[feature.style.texture];
        GDrawGeomerty["a" /* default */].drawPointIcon(ctx, feature, this.ratio, false, tile.hitCtx, this.hitDetection);
        GDrawGeomerty["a" /* default */].drawPoint(ctx, feature, this.ratio, false, false, tile.hitCtx, this.hitDetection);
        continue;
      } //画线注记


      if (feature.type == 2) {
        GDrawGeomerty["a" /* default */].drawLine(ctx, feature, this.ratio);
      }
    } //用于拾取查找


    tile.featureIdMap = featureIdMap; // console.timeEnd('_drawTile');
  },
  _cleanTile: function _cleanTile(tile) {
    tile.ctx.clearRect(0, 0, this.tilesize, this.tilesize);

    if (tile.hitCtx) {
      tile.hitCtx.clearRect(0, 0, this.tilesize, this.tilesize);
    }
  },

  /**
   * 根据屏幕坐标获取feature
   * Parameters :
   * x
   * y
   */
  getFeatureByXY: function getFeatureByXY(x, y) {
    var feature = null;

    if (this.hitDetection) {
      var featureId;

      var latLng = this._map.containerPointToLatLng(new external_L_default.a.point(x, y));

      var maxBounds = this._map.options.crs.projection.bounds; //地图当前范围

      var bounds = this._map.getBounds();

      var pBounds = this._map.getPixelBounds(); //地图当前分辨率


      var res = (bounds._northEast.lat - bounds._southWest.lat) / (pBounds.max.y - pBounds.min.y);
      var tileSize = this.tilesize;
      var row = (maxBounds.max.y - latLng.lat) / (res * tileSize);
      var col = (latLng.lng - maxBounds.min.x) / (res * tileSize);
      var frow = Math.floor(row);
      var fcol = Math.floor(col);

      var level = this._map.getZoom();

      var tile = this._tiles[fcol + ':' + frow + ':' + level].el;
      var tx = (col - fcol) * tileSize;
      var ty = (row - frow) * tileSize;
      var data = tile.hitCtx.getImageData(tx, ty, 1, 1).data;

      if (data[3] === 255) {
        // antialiased
        var id = data[2] + 256 * (data[1] + 256 * data[0]);

        if (id) {
          featureId = id - 1;

          try {
            feature = tile.featureIdMap[featureId];
          } catch (err) {
            console.log(err);
          }
        }
      }
    }

    return feature;
  },
  _update: function _update(center) {
    if (this.isSetIngFilter) {
      return;
    }

    external_L_default.a.TileLayer.prototype._update.call(this);
  },

  /**
   * 设置过滤条件
   */
  setFilter: function setFilter(filter) {
    this.isSetIngFilter = true;

    if (!this._url || !filter || filter.layers.length == 0 && filter.order.length == 0) {
      this.isSetIngFilter = false;
      this.controlId = null;
      this.control = null;
      this.setUrl(this.sourceUrl + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version);
      return;
    }

    this.gxyzUtil.setFilter(filter, function (result) {
      this.isSetIngFilter = false;

      if (result.isIE) {
        this.controlId = result.id;
        this.setUrl(this.sourceUrl + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&controlId=' + result.id);
      } else {
        this.control = result.id;
        this.setUrl(this.sourceUrl + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&control=' + result.id);
      }
    }.bind(this));
  }
});
external_L_default.a.geoway.GLabelGrid = GLabelGrid;
external_L_default.a.GLabelGrid = GLabelGrid;
/* harmony default export */ var label_GLabelGrid = (GLabelGrid);
// EXTERNAL MODULE: ./src/layer/label/draw/CanvasLayer.js
var CanvasLayer = __webpack_require__(34);

// CONCATENATED MODULE: ./src/layer/label/GWVTAnno.js
/**
 * Created by kongjian on 2017/6/26.
 * 前端注记避让并绘制layer
 */



var GWVTAnno = external_L_default.a.Layer.extend({
  canvasLayer: null,
  currLevel: 2,
  //缩放比例
  ratio: 1,
  //是否允许拾取
  hitDetection: true,
  cellsize: 4,
  options: {
    tileSize: 256,
    //图层透明度
    opacity: 1
  },

  /**
   * 构造方法
   */
  initialize: function initialize(options) {
    external_L_default.a.setOptions(this, options);

    if (this.options.hasOwnProperty('hitDetection')) {
      this.hitDetection = this.options.hitDetection;
    }

    if (this.options.hasOwnProperty('cellsize')) {
      this.cellsize = this.options.cellsize;
    }

    if (window.devicePixelRatio > 1.5) {
      this.ratio = 2;
    }

    this.canvasLayer = new CanvasLayer["a" /* default */]();
    this.canvasLayer.tileSize = this.options.tileSize;

    if (this.options.hasOwnProperty('ableAvoid')) {
      this.canvasLayer.ableAvoid = this.options.ableAvoid;
    }

    if (this.options.hasOwnProperty('debug')) {
      this.debug = this.options.debug;
      this.canvasLayer.setDebug(this.debug);
    }

    this.animating = false;
  },

  /**
   * 图层被添加到地图中调用
   */
  onAdd: function onAdd() {
    this.canvasLayer.hitDetection = this.hitDetection;
    this.canvasLayer.ratio = this.ratio; //地图最大范围

    var maxExtent = this._map.options.crs.projection.bounds;
    this.canvasLayer.init(this._map._size.x, this._map._size.y, this.options.tileSize, this);
    this.canvasLayer.maxExtent = [maxExtent.min.x, maxExtent.min.y, maxExtent.max.x, maxExtent.max.y];
    this._container = this.canvasLayer.root;

    if (this._zoomAnimated) {
      external_L_default.a.DomUtil.addClass(this._container, 'leaflet-zoom-animated');
    }

    this.canvasLayer.root.style.opacity = this.options.opacity;
    this.getPane().appendChild(this.canvasLayer.root);

    this._update();
  },
  setOpacity: function setOpacity(opacity) {
    this.options.opacity = opacity;

    if (this.canvasLayer.root) {
      this.canvasLayer.root.style.opacity = this.options.opacity;
    }
  },
  setAbleAvoid: function setAbleAvoid(ableAvoid) {
    if (this.canvasLayer) {
      this.canvasLayer.ableAvoid = ableAvoid;
      this.redraw();
    }
  },

  /**
   * 注册事件
   */
  getEvents: function getEvents() {
    var events = {
      resize: this.onResize,
      movestart: this.onMoveStart,
      zoom: this._onZoom,
      moveend: this._onMoveend
    };

    if (this._zoomAnimated) {
      events.zoomanim = this._onAnimZoom;
    }

    return events;
  },

  /**
   * 浏览器窗口缩放事件
   */
  onResize: function onResize(e) {
    this.canvasLayer.tileSize = this.options.tileSize;
    this.canvasLayer.gwvtAnno = this;
    this.canvasLayer.initCanvas(this._map._size.x, this._map._size.y);

    this._update();
  },
  _onAnimZoom: function _onAnimZoom(ev) {
    this.updateTransform(ev.center, ev.zoom);
  },
  _onZoom: function _onZoom() {
    this.updateTransform(this._map.getCenter(), this._map.getZoom());
  },
  _onMoveend: function _onMoveend() {
    this.animating = false;

    this._update();
  },

  /**
   * 缩放时更新注记层的位置
   */
  updateTransform: function updateTransform(center, zoom) {
    if (!this._zoom || !this._center) {
      this._zoom = this._map.getZoom();
      this._center = this._map.getCenter();
    }

    var scale = this._map.getZoomScale(zoom, this._zoom),
        position = this.getCanvasXY(),
        viewHalf = this._map.getSize().multiplyBy(0.5),
        currentCenterPoint = this._map.project(this._center, zoom),
        destCenterPoint = this._map.project(center, zoom),
        centerOffset = destCenterPoint.subtract(currentCenterPoint),
        topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

    if (external_L_default.a.Browser.any3d) {
      external_L_default.a.DomUtil.setTransform(this.canvasLayer.root, topLeftOffset, scale);
    } else {
      external_L_default.a.DomUtil.setPosition(this.canvasLayer.root, topLeftOffset);
    }
  },

  /**
   * 缩放，平移完成的回调
   */
  onMoveStart: function onMoveStart() {
    this.animating = true;
  },

  /**
   * 缩放，平移完成的回调
   */
  _update: function _update() {
    var map = this._map;

    if (!map) {
      return;
    } //地图当前范围


    var bounds = map.getBounds();
    var pBounds = map.getPixelBounds();
    var east = map.options.crs.projection.project(bounds._northEast);
    var west = map.options.crs.projection.project(bounds._southWest); //地图当前分辨率

    var res = (east.y - west.y) / (pBounds.max.y - pBounds.min.y); //地图最大范围

    var maxExtent = map.options.crs.projection.bounds; //需要请求行列号

    var minRow = Math.floor((maxExtent.max.y - east.y) / (res * this.options.tileSize));
    var maxRow = Math.ceil((maxExtent.max.y - west.y) / (res * this.options.tileSize));
    var minCol = Math.floor((west.x - maxExtent.min.x) / (res * this.options.tileSize));
    var maxCol = Math.ceil((east.x - maxExtent.min.x) / (res * this.options.tileSize));
    var level = map.getZoom();
    var zoomChanged = this.currLevel != level; //发送请求

    var grid = this.getGrid(minRow, maxRow, minCol, maxCol, level);
    this.canvasLayer.extent = [west.x, west.y, east.x, east.y];
    this.canvasLayer.res = res;
    this.canvasLayer.requestLabelTiles(grid, zoomChanged);
    this.currLevel = level;
  },

  /**
   * 根据当前视口获取要请求的瓦片的行列号
   * Parameters (single argument):
   * bounds - 当前视口范围
   * Returns:
   * grid -  当前范围对应的瓦片层行列号
   */
  getGrid: function getGrid(minRow, maxRow, minCol, maxCol, level) {
    var grid = [];

    for (var col = minCol; col < maxCol; col++) {
      for (var row = minRow; row < maxRow; row++) {
        grid.push({
          "row": row,
          "col": col,
          "level": level
        });
      }
    }

    return grid;
  },

  /**
   * 当图层缩放，平移后，更新canvas的位置
   * 考虑到它的位置信息存到了map中，不同的map sdk实现机制不一样
   * 所以考虑将该方法提到本类中
   */
  resetCanvasDiv: function resetCanvasDiv() {
    var p = this.getCanvasXY();
    external_L_default.a.DomUtil.setPosition(this._container, p);
    this._center = this._map.getCenter();
    this._zoom = this._map.getZoom();
  },

  /**
   * 获取canvas的坐标
   */
  getCanvasXY: function getCanvasXY() {
    var style = this._map.dragging._draggable._element.style;
    var offset;

    if (style.transform) {
      offset = style.transform.match(/(-?\d+\.?\d*)(px)/g);
    } else {
      offset = [style.left, style.top];
    }

    var x = offset[0].replace('px', '');
    var y = offset[1].replace('px', '');
    return {
      x: -x,
      y: -y
    };
  },

  /**
   * 重新绘制注记要素，当动态更改DataSouce数据源后，需要调用redraw方法
   */
  redraw: function redraw() {
    if (this.canvasLayer) {
      this.canvasLayer.redraw();
    }
  },

  /**
   * 添加数据源
   * Parameters :
   * dataSource
   */
  addDataSource: function addDataSource(dataSource) {
    this.canvasLayer.addDataSource(dataSource);
  },

  /**
   * 根据dataSoucceId移除数据源
   * Parameters :
   * dataSoucceId
   */
  removeDataSourceById: function removeDataSourceById(dataSoucceId) {
    this.canvasLayer.removeDataSourceById(dataSoucceId);
  },
  onRemove: function onRemove(map) {
    external_L_default.a.DomUtil.remove(this.canvasLayer.root);
  },
  addToMap: function addToMap(map) {
    map.addLayer(this);
  },

  /**
   * 根据屏幕坐标获取feature
   * Parameters :
   * x
   * y
   */
  getFeatureByXY: function getFeatureByXY(x, y) {
    return this.canvasLayer.getFeatureByXY(x, y);
  },

  /**
   * 是否支持isImportant属性，默认值为true
   * Parameters :
   * b
   */
  setHasImportant: function setHasImportant(b) {
    if (this.canvasLayer) {
      this.canvasLayer.hasImportant = b;
    }
  },

  /**
   * 获取支持isImportant属性，返回true 或者false
   */
  getHasImportant: function getHasImportant() {
    if (this.canvasLayer) {
      return this.canvasLayer.hasImportant;
    } else {
      return true;
    }
  },
  setDebug: function setDebug(debug) {
    if (this.debug != debug) {
      this.debug = debug;

      if (this.canvasLayer) {
        this.canvasLayer.setDebug(this.debug);

        this._update();
      }
    }
  },

  /**
   * 根据屏幕坐标获取feature, 可以拾取叠加的注记，效率比getFeatureByXY低
   * Parameters :
   * x
   * y
   */
  getFeaturesByXY: function getFeaturesByXY(x, y) {
    return this.canvasLayer.getFeaturesByXY(x, y);
  },

  /**
   * 高亮指定的注记
   * Parameters :
   * featrueIds 需要高亮的注记id数组
   * lightColor 注记高亮的填充色
   */
  highlightLabel: function highlightLabel(featrueIds, lightColor) {
    if (!lightColor) {
      lightColor = '#ff0000';
    }

    this.canvasLayer.highlightLabel(featrueIds, lightColor);

    this._update();
  },

  /**
   *  获取当前屏幕范围内的所有注记
   */
  getCurrentLabels: function getCurrentLabels() {
    return this.canvasLayer.features;
  },
  CLASS_NAME: "L.GWVTAnno"
});
external_L_default.a.geoway.GWVTAnno = GWVTAnno;
external_L_default.a.GWVTAnno = GWVTAnno;
/* harmony default export */ var label_GWVTAnno = (GWVTAnno);
// CONCATENATED MODULE: ./src/layer/label/feature/Feature.js
function Feature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Feature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Feature_createClass(Constructor, protoProps, staticProps) { if (protoProps) Feature_defineProperties(Constructor.prototype, protoProps); if (staticProps) Feature_defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by kongjian on 2017/6/27.
 */



var Feature = /*#__PURE__*/function () {
  function Feature() {
    Feature_classCallCheck(this, Feature);

    this.id = Math.round(Math.random() * 256 * 256 * 256); //要素类型，1代表点，2代表线

    this.type = 1; //数据一维数组，里面依次存放x,y地理坐标

    this.sourceData = []; //根据sourceAngleData转换为屏幕坐标的集合

    this.datas = []; //由原始sourceData切断过，带角度的数据

    this.sourceAngleData = [];
    this.attributes = {}; //单个注记的样式

    this.style = {};
  }
  /**
   * 添加属性字段
   * Parameters :
   * key
   * value
   */


  Feature_createClass(Feature, [{
    key: "addAttribute",
    value: function addAttribute(key, value) {
      this.attributes[key] = value;
    }
    /**
     * 根据字段名删除属性
     * Parameters :
     * key
     * value
     */

  }, {
    key: "removeAttributeByKey",
    value: function removeAttributeByKey(key) {
      delete this.attributes[key];
    }
    /**
     * 计算feature的最大外接矩形
     */

  }, {
    key: "getMaxExtent",
    value: function getMaxExtent() {
      if (this.sourceData.length == 0) {
        return null;
      }

      var minX = this.sourceData[0];
      var maxX = this.sourceData[0];
      var minY = this.sourceData[1];
      var maxY = this.sourceData[1];

      for (var i = 2; i < this.sourceData.length; i++) {
        var tempX = this.sourceData[i];
        var tempY = this.sourceData[i + 1];
        if (tempX > maxX) // 判断最大值
          maxX = tempX;
        if (tempX < minX) // 判断最小值
          minX = tempX;
        if (tempY > maxY) // 判断最大值
          maxY = tempY;
        if (tempY < minY) // 判断最小值
          minY = tempY;
        i++;
      }

      return [minX, minY, maxX, maxY];
    }
    /**
     * 判断feature是否在当前视口中
     * Parameters :
     * srceenBounds - 当前视口的外接矩形
     */

  }, {
    key: "inBounds",
    value: function inBounds(srceenBounds) {
      var featureBounds = this.getMaxExtent();

      if (!featureBounds) {
        return false;
      }

      return featureBounds[0] <= srceenBounds[2] && featureBounds[2] >= srceenBounds[0] && featureBounds[1] <= srceenBounds[3] && featureBounds[3] >= srceenBounds[1];
    }
    /**
     * 将要素的地理坐标转换为当前的屏幕坐标
     * Parameters:
     * srceenBounds - 当前视口的外接矩形
     * res - 当前地图的分辨率
     */

  }, {
    key: "transformData",
    value: function transformData(srceenBounds, res) {
      this.datas = [];

      if (this.sourceData.length == 0) {
        return;
      } //取出当前视口左上角的地理坐标


      var left = srceenBounds[0];
      var top = srceenBounds[3]; // for(let i = 0;i< this.sourceData.length;i++){
      //     let sx = this.sourceData[i];
      //     let sy = this.sourceData[i+1];
      //     this.datas.push((sx - left)/res);
      //     this.datas.push((top - sy)/res);
      //     i++;
      // }

      var rPoints = [];

      for (var i = 0; i < this.sourceAngleData.length; i++) {
        var point = this.sourceAngleData[i][0];
        var gx = (point[0] - left) / res;
        var gy = (top - point[1]) / res;
        var p = [gx, gy];
        rPoints.push([p, this.sourceAngleData[i][1]]);
      }

      this.datas = rPoints;
    }
    /**
     * 获取要素要显示的文字内容
     */

  }, {
    key: "getFeatureLabel",
    value: function getFeatureLabel() {
      var labelField = this.style['labelfield'];

      if (labelField) {
        if (this.attributes[labelField]) {
          return this.attributes[labelField] + '';
        }
      }

      return null;
    }
  }]);

  return Feature;
}();

external_L_default.a.geoway.Feature = Feature;
/* harmony default export */ var feature_Feature = (Feature);
// CONCATENATED MODULE: ./src/layer/vector/stylejs/GStyleItem.js
function GStyleItem_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GStyleItem_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function GStyleItem_createClass(Constructor, protoProps, staticProps) { if (protoProps) GStyleItem_defineProperties(Constructor.prototype, protoProps); if (staticProps) GStyleItem_defineProperties(Constructor, staticProps); return Constructor; }




var GStyleItem = /*#__PURE__*/function () {
  function GStyleItem(styleId, layerId) {
    GStyleItem_classCallCheck(this, GStyleItem);

    this.style = {};
    this.style.id = styleId;
    this.style.layer = layerId;
    this.style.type = 'style';
    this.style.children = [];
  }
  /**
   * 设置sql查询条件
   * Parameters : sqlFilter  示例： fcode  = "2602000500" or fcode  = "2507000500"
   *  fileds 示例： {"gid":{"name":"gid","type":"String"}}
   */


  GStyleItem_createClass(GStyleItem, [{
    key: "queryFilter",
    value: function queryFilter(sqlFilter, fileds) {
      if (sqlFilter) {
        this.style.query = sqlFilter;
        this.style.fields = fileds;
      } else {
        this.style.query = '';
      }
    }
    /**
     * 设置样式
     * Parameters : styleArr  示例：[{
     *			"text": "省界",
     *			"name": "省界",
     *			"filter": "fcode  = \"6302011314\"",
     *			"query": "Q_fcode_S_EQ=6302011314",
     *			"isleaf": true,
     *			"type": "style",
     *			"iconCls": "icon-line",
     *			"id": "11_境界线_省界",
     *			"style": [{
     *				"stroke": false,
     *				"strokeWidth": 0,
     *				"strokeColor": "#ED22AB",
     *				"strokeOpacity": 1,
     *				"dash": null,
     *				"lineCap": "butt",
     *				"lineJoin": "miter",
     * 				"sparsity": 1
     *			}]
     */

  }, {
    key: "setStyle",
    value: function setStyle(styleArr) {
      this.style.style = styleArr;
    }
    /**
     * 添加子样式
     * Parameters : gStyleItem  GStyleItem对象实例
     */

  }, {
    key: "addSubStyle",
    value: function addSubStyle(gStyleItem) {
      this.style.children.push(gStyleItem.style);
    }
  }]);

  return GStyleItem;
}();

external_L_default.a.geoway.GStyleItem = GStyleItem;
/* harmony default export */ var stylejs_GStyleItem = (GStyleItem);
// CONCATENATED MODULE: ./src/layer/vector/draw/GVMapGridUtil.js
function GVMapGridUtil_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { GVMapGridUtil_typeof = function _typeof(obj) { return typeof obj; }; } else { GVMapGridUtil_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return GVMapGridUtil_typeof(obj); }

function GVMapGridUtil_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GVMapGridUtil_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function GVMapGridUtil_createClass(Constructor, protoProps, staticProps) { if (protoProps) GVMapGridUtil_defineProperties(Constructor.prototype, protoProps); if (staticProps) GVMapGridUtil_defineProperties(Constructor, staticProps); return Constructor; }

function GVMapGridUtil_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) GVMapGridUtil_setPrototypeOf(subClass, superClass); }

function GVMapGridUtil_setPrototypeOf(o, p) { GVMapGridUtil_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GVMapGridUtil_setPrototypeOf(o, p); }

function GVMapGridUtil_createSuper(Derived) { var hasNativeReflectConstruct = GVMapGridUtil_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = GVMapGridUtil_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = GVMapGridUtil_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return GVMapGridUtil_possibleConstructorReturn(this, result); }; }

function GVMapGridUtil_possibleConstructorReturn(self, call) { if (call && (GVMapGridUtil_typeof(call) === "object" || typeof call === "function")) { return call; } return GVMapGridUtil_assertThisInitialized(self); }

function GVMapGridUtil_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function GVMapGridUtil_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function GVMapGridUtil_getPrototypeOf(o) { GVMapGridUtil_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GVMapGridUtil_getPrototypeOf(o); }






var GVMapGridUtil_GVMapGridUtil = /*#__PURE__*/function (_GXYZUtil) {
  GVMapGridUtil_inherits(GVMapGridUtil, _GXYZUtil);

  var _super = GVMapGridUtil_createSuper(GVMapGridUtil);

  function GVMapGridUtil(isDynamicMap) {
    var _this;

    GVMapGridUtil_classCallCheck(this, GVMapGridUtil);

    _this = _super.call(this); //纹理

    _this.textures = {};
    _this.isDynamicMap = isDynamicMap;
    _this.styleObj = {};
    return _this;
  }
  /**
   * 设置样式文件
   */


  GVMapGridUtil_createClass(GVMapGridUtil, [{
    key: "setStyle",
    value: function setStyle(styleObj) {
      this.styleObj = styleObj; // this.styleFun = new Function("drawer","level", styleStr);
      // if(this.styleDef){
      //     this.styleDef.resolve();
      // }
    }
  }, {
    key: "formatStyle",
    value: function formatStyle(styleObj, successFun) {
      this.styleObj = styleObj;
      var styleJson = JSON.stringify(this.styleObj);
      Object(es6_promise["c" /* getJSON */])({
        type: 'post',
        url: this.host + '/mapserver/styleInfo/format.do',
        data: 'styleJson= ' + styleJson,
        dataType: 'json'
      }).then(function (result) {
        this.styleFun = new Function("drawer", "level", result.styleJs);
        successFun();
      }.bind(this));
    }
    /**
     * 加载样式文件和纹理数据
     */

  }, {
    key: "loadStyle",
    value: function loadStyle(styleType) {
      var def1 = new es6_promise["a" /* Deferred */]();
      var def2 = new es6_promise["a" /* Deferred */]();

      if (!styleType) {
        styleType = 'label';
      }

      if (this.isDynamicMap) {
        var styleJson = JSON.stringify(this.styleObj);
        Object(es6_promise["c" /* getJSON */])({
          type: 'post',
          url: 'http://127.0.0.1/mapserver/styleInfo/format.do',
          data: 'styleJson= ' + styleJson,
          dataType: 'json'
        }).then(function (result) {
          this.styleFun = new Function("drawer", "level", result.styleJs);
          def1.resolve();
        }.bind(this));
      } else {
        //请求样式文件
        Object(es6_promise["c" /* getJSON */])({
          url: this.host + '/mapserver/styleInfo/' + this.servername + '/' + this.styleId + '/' + styleType + '/style.js?' + Math.random(),
          dataType: 'text'
        }).then(function (result) {
          this.styleFun = new Function("drawer", "level", result);
          def1.resolve();
        }.bind(this));
      } //请求图标纹理


      Object(es6_promise["c" /* getJSON */])({
        url: this.host + '/mapserver/styleInfo/' + this.servername + '/' + this.styleId + '/label/texture.js?' + Math.random(),
        dataType: 'text'
      }).then(function (result) {
        var textures = JSON.parse(result);
        var totalCount = 0;

        for (var i in textures) {
          if (textures[i]) {
            totalCount++;
          }
        }

        if (totalCount == 0) {
          def2.resolve();
          return;
        }

        var count = 0;

        for (var key in textures) {
          var img = new Image();
          img.name = key;

          img.onload = function (data) {
            count++;
            var name = data.target.name;
            this.textures[name] = data.target;

            if (count == totalCount) {
              def2.resolve();
            }
          }.bind(this);

          img.src = textures[key];
        }
      }.bind(this));
      return [def1, def2];
    }
  }]);

  return GVMapGridUtil;
}(draw_GXYZUtil);

external_L_default.a.geoway.GVMapGridUtil = GVMapGridUtil_GVMapGridUtil;
/* harmony default export */ var draw_GVMapGridUtil = (GVMapGridUtil_GVMapGridUtil);
// CONCATENATED MODULE: ./src/layer/vector/draw/PropertyGetter.js
function PropertyGetter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function PropertyGetter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function PropertyGetter_createClass(Constructor, protoProps, staticProps) { if (protoProps) PropertyGetter_defineProperties(Constructor.prototype, protoProps); if (staticProps) PropertyGetter_defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by kongjian on 2017/6/26.
 */
var PropertyGetter = /*#__PURE__*/function () {
  function PropertyGetter(propertyConfig) {
    PropertyGetter_classCallCheck(this, PropertyGetter);

    this.propertyConfig = {};

    for (var i = 0; i < propertyConfig.length; i++) {
      if (propertyConfig[i].id == 'true' || propertyConfig[i].id == true) {
        this.idIndex = propertyConfig[i].index;
      }

      this.propertyConfig[propertyConfig[i].name] = parseInt(propertyConfig[i].index);
    }
  }

  PropertyGetter_createClass(PropertyGetter, [{
    key: "get",
    value: function get(data, propertyName) {
      var value = data[this.propertyConfig[propertyName]];
      return value;
    }
  }, {
    key: "getId",
    value: function getId(data) {
      return data[this.idIndex];
    }
  }]);

  return PropertyGetter;
}();

/* harmony default export */ var draw_PropertyGetter = (PropertyGetter);
// CONCATENATED MODULE: ./src/layer/vector/draw/AbstractDataHolder.js
function AbstractDataHolder_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function AbstractDataHolder_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function AbstractDataHolder_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractDataHolder_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractDataHolder_defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by kongjian on 2017/6/26.
 */


var AbstractDataHolder_AbstractDataHolder = /*#__PURE__*/function () {
  function AbstractDataHolder(config, drawerCalss) {
    AbstractDataHolder_classCallCheck(this, AbstractDataHolder);

    this.layerDataMap = config.layerDataMap;
    this.extent = config.extent;
    this.ctx = config.ctx;
    this.ratio = config.ratio;
    this.control = config.control;
    this.drawerCalss = drawerCalss;
    this.config = config;
    this.textures = config.textures;
  }

  AbstractDataHolder_createClass(AbstractDataHolder, [{
    key: "_emptyDrawer",
    value: function _emptyDrawer(styleLayerID) {
      var drawer = new this.drawerCalss(null);
      return drawer;
    }
  }, {
    key: "getLayer",
    value: function getLayer(dataLayerID, styleLayerID) {
      if (styleLayerID == null) {
        styleLayerID = dataLayerID;
      }

      if (null == this.layerDataMap) {
        return this._emptyDrawer(styleLayerID);
      } //判断其他图层是否显示Control otherDisplay,如果是其他图层不显示，则需要在这里处理


      if (this.control != null) {
        //      console.log(this.control.controlObj.otherDisplay);
        if (this.control.controlObj.otherDisplay == false) {
          if (this.control.controlObj.controlLayersArr.indexOf(styleLayerID) == -1) {
            return this._emptyDrawer(styleLayerID);
          }
        }
      }

      var data = this.layerDataMap[dataLayerID];

      if (data == null) {
        return this._emptyDrawer(styleLayerID);
      } else {
        //修正一个十分傻逼的错误,好吧，我英语不好
        if (data.datas) {
          data.features = data.datas;
        } // delete data.datas;


        if (data.features == null) {
          return this._emptyDrawer(styleLayerID);
        }

        var propertyGetter = null;

        if (null !== data.fieldsConfig) {
          propertyGetter = new draw_PropertyGetter(data.fieldsConfig);
        }

        this.config['dataLayerID'] = dataLayerID;
        this.config['styleLayerID'] = styleLayerID;
        this.config['propertyGetter'] = propertyGetter;
        this.config['control'] = this.control;
        this.config['textures'] = this.textures;
        var drawer = new this.drawerCalss(this.config);

        if (!Array.isArray(data.features)) {
          for (var index in data.features) {
            var feature = data.features[index];
            feature.type = data.type;
            drawer.addFeatures(feature);
          }
        } else {
          var _feature = data.features;
          _feature.type = data.type;
          drawer.addFeatures(_feature);
        }

        return drawer;
      }
    }
  }, {
    key: "getGroupLayer",
    value: function getGroupLayer(dataLayerID, value, styleLayerID) {
      if (this.layerDataMap == null) {
        return this._emptyDrawer(styleLayerID);
      }

      if (styleLayerID == null) {
        styleLayerID = dataLayerID;
      } //判断其他图层是否显示Control otherDisplay,如果是其他图层不显示，则需要在这里处理


      if (this.control != null) {
        //      console.log(this.control.controlObj.otherDisplay);
        if (this.control.controlObj.otherDisplay == false) {
          if (this.control.controlObj.controlLayersArr.indexOf(styleLayerID) == -1) {
            return this._emptyDrawer(styleLayerID);
          }
        }
      }

      var data = this.layerDataMap[dataLayerID];

      if (this.layerDataMap == null) {
        return this._emptyDrawer(styleLayerID);
      }

      if (data == null) {
        return this._emptyDrawer(styleLayerID);
      }

      if (data.datas == null && data.data == null) {
        return this._emptyDrawer(styleLayerID);
      }

      var valueArr = value.split(',');
      var length = valueArr.length;

      if (length == 0) {
        return this._emptyDrawer(styleLayerID);
      }

      var propertyGetter = null;

      if (data.fieldsConfig != null) {
        propertyGetter = new draw_PropertyGetter(data.fieldsConfig);
      }

      this.config['dataLayerID'] = dataLayerID;
      this.config['styleLayerID'] = styleLayerID;
      this.config['propertyGetter'] = propertyGetter;
      this.config['control'] = this.control;
      this.config['textures'] = this.textures;
      var drawer = new this.drawerCalss(this.config);

      if (data.data == null) {
        data.features = data.datas;
      } else {
        data.features = data.data;
      }

      for (var i = 0; i < length; i++) {
        var dataArr = data.features[valueArr[i]];

        if (dataArr == null) {
          continue;
        }

        dataArr.type = data.type;
        drawer.addFeatures(dataArr);
      }

      return drawer;
    }
  }]);

  return AbstractDataHolder;
}();

/* harmony default export */ var draw_AbstractDataHolder = (AbstractDataHolder_AbstractDataHolder);
// CONCATENATED MODULE: ./src/layer/vector/draw/AbstractVTileProcess.js
function AbstractVTileProcess_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function AbstractVTileProcess_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function AbstractVTileProcess_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractVTileProcess_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractVTileProcess_defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by kongjian on 2017/6/26.
 */
var AbstractVTileProcess = /*#__PURE__*/function () {
  function AbstractVTileProcess(config) {
    AbstractVTileProcess_classCallCheck(this, AbstractVTileProcess);

    if (config) {
      //放数据的容器
      this.featuresArr = []; //属性构造器

      this.propertyGetter = config.propertyGetter; //网格

      this.extent = config.extent;
      /**
       * 缩放比例
       * @type {*|number}
       */

      this.ratio = config.ratio;
      this.resize = false;

      if (this.ratio != 1) {
        this.resize = true;
      }
      /**
       * 等级
       */


      this.level = this.extent.level;
      /**
       * 数据层级ID
       */

      this.dataLayerID = config.dataLayerID;
      /**
       * 样式层级ID
       */

      this.styleLayerID = config.styleLayerID;
      /**
       * 过滤器
       * @type {*|null}
       */

      this.control = config.control;
    }
  }
  /**
   * 加入处理数据
   * @param features
   */


  AbstractVTileProcess_createClass(AbstractVTileProcess, [{
    key: "addFeatures",
    value: function addFeatures(features) {
      this.featuresArr.push(features);
    }
    /**
     * 加入处理样式
     * @param fn
     */

  }, {
    key: "setStyle",
    value: function setStyle(fn) {
      this.styleOperator = fn;
    }
    /**
     *处理
     */

  }, {
    key: "process",
    value: function process() {
      var queryFilter = null;

      if (this.featuresArr == null) {
        return;
      }

      var length = this.featuresArr.length;

      if (length == 0) {
        return;
      }

      for (var i = 0; i < length; i++) {
        var features = this.featuresArr[i];

        this._processFeatures(features);
      }
    }
  }, {
    key: "_processFeature",
    value: function _processFeature(gjson) {
      throw "抽象方法";
    }
  }, {
    key: "_processFeatures",
    value: function _processFeatures(features) {
      for (var i = 0; i < features.length; i++) {
        var gjson = features[i];

        this._processFeature(gjson);
      }

      return;
    }
  }, {
    key: "_getProperty",
    value: function _getProperty(data) {
      return data[1];
    }
  }, {
    key: "_getPoints",
    value: function _getPoints(data) {
      return data[2];
    }
  }, {
    key: "_getType",
    value: function _getType(data) {
      return data[0];
    }
  }, {
    key: "_filterByStyle",
    value: function _filterByStyle(gjson) {
      var type = this._getType(gjson);

      var points = this._getPoints(gjson);

      var property = this._getProperty(gjson);

      if (points == null) {
        throw "绘制失败,数据中缺少Geometry";
      }

      if (type == null) {
        type = "POLYGON";
      }

      var controlRes = null;
      var style = null;

      if (this.styleOperator == null) {
        return null;
      } else {
        this.propertyGetter;
        var id = this.propertyGetter.getId(property);
        var _propertyGetter = this.propertyGetter;

        var get = function get(fieldName) {
          return _propertyGetter.get(property, fieldName);
        };

        if (this.control) {
          if (typeof this.control.controlFn == "function") {
            controlRes = this.control.controlFn.call({}, id, get, this.styleLayerID);

            if (controlRes == false || controlRes == null) {
              return {
                display: false
              };
            }
          }
        }

        style = this.styleOperator.call({}, this.level, get); //   } catch (e) {
        //        throw e;
        //    }
      }

      if (style == null) {
        return null;
      }

      if (style.display != null) {
        if (style.display == false) {
          return {
            display: false
          };
        }
      }

      if (controlRes != null) {
        style.customeColor = controlRes;
      }

      return style;
    }
  }]);

  return AbstractVTileProcess;
}();

/* harmony default export */ var draw_AbstractVTileProcess = (AbstractVTileProcess);
// CONCATENATED MODULE: ./src/layer/vector/draw/Drawer.js
function Drawer_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Drawer_typeof = function _typeof(obj) { return typeof obj; }; } else { Drawer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Drawer_typeof(obj); }

function Drawer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Drawer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Drawer_createClass(Constructor, protoProps, staticProps) { if (protoProps) Drawer_defineProperties(Constructor.prototype, protoProps); if (staticProps) Drawer_defineProperties(Constructor, staticProps); return Constructor; }

function Drawer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Drawer_setPrototypeOf(subClass, superClass); }

function Drawer_setPrototypeOf(o, p) { Drawer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Drawer_setPrototypeOf(o, p); }

function Drawer_createSuper(Derived) { var hasNativeReflectConstruct = Drawer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Drawer_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Drawer_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Drawer_possibleConstructorReturn(this, result); }; }

function Drawer_possibleConstructorReturn(self, call) { if (call && (Drawer_typeof(call) === "object" || typeof call === "function")) { return call; } return Drawer_assertThisInitialized(self); }

function Drawer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Drawer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function Drawer_getPrototypeOf(o) { Drawer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Drawer_getPrototypeOf(o); }

/**
 * Created by kongjian on 2017/5/1.
 */


var Drawer = /*#__PURE__*/function (_AbstractVTileProcess) {
  Drawer_inherits(Drawer, _AbstractVTileProcess);

  var _super = Drawer_createSuper(Drawer);

  function Drawer(config) {
    var _this;

    Drawer_classCallCheck(this, Drawer);

    _this = _super.call(this, config);

    if (config) {
      _this.ctx = config.ctx;
      _this.shadowDatas = [];
      _this.textures = config.textures;
    }

    return _this;
  }

  Drawer_createClass(Drawer, [{
    key: "draw",
    value: function draw() {
      if (this.featuresArr == null) {
        return;
      }

      this.process();

      for (var j = 0; j < this.shadowDatas.length; j++) {
        var shadowData = this.shadowDatas[j];

        this._drawShape(shadowData.data);

        this._processShadowEnd(shadowData.style);
      }
    }
  }, {
    key: "_processShadowEnd",
    value: function _processShadowEnd(style) {
      this.ctx.closePath();

      if (style['shadowColor']) {
        this.ctx.globalAlpha = 1;
        this.ctx.fillStyle = style['shadowColor'];
        this.ctx.fill();
      }
    }
  }, {
    key: "_drawShape",
    value: function _drawShape(points) {
      var context = this.ctx;

      if (!points.length) {
        return;
      }

      context.beginPath();

      if (this.resize) {
        context.moveTo(points[0] * this.ratio, points[1] * this.ratio);

        for (var i = 2, il = points.length; i < il; i += 2) {
          context.lineTo(points[i] * this.ratio, points[i + 1] * this.ratio);
        }
      } else {
        context.moveTo(points[0], points[1]);

        for (var i = 2, il = points.length; i < il; i += 2) {
          context.lineTo(points[i], points[i + 1]);
        }
      }

      context.closePath();
    }
  }, {
    key: "_processFeature",
    value: function _processFeature(gjson) {
      var style = this._filterByStyle(gjson);

      if (style == null) {
        return;
      }

      if (style.display == false) {
        return;
      }

      this._beginDraw();

      this._drawFeature(gjson, style);
    }
  }, {
    key: "_beginDraw",
    value: function _beginDraw() {
      this.ctx.beginPath();
    }
  }, {
    key: "_drawFeature",
    value: function _drawFeature(gjson, style) {
      var type = this._getType(gjson);

      var points = this._getPoints(gjson);

      var property = this._getProperty(gjson);

      if (points == null) {
        throw "绘制失败,数据中缺少Geometry";
      }

      if (type == null) {
        type = "POLYGON";
      }

      var sparsity = null;

      if (style.sparsity != null) {
        sparsity = parseFloat(style.sparsity);
      }

      switch (type) {
        case "PT":
          this._processPoint(points);

          break;

        case "LINESTRING":
          this._processLineString(points, sparsity);

          this._processLineStringEnd(style);

          break;

        case "MULTILINESTRING":
          this._processLineString(points, sparsity);

          this._processLineStringEnd(style);

          break;

        case "MULTIPOLYGON":
          this._processPolygon(points, sparsity);

          this._processPolygonEnd(style);

          break;

        case "POLYGON":
          this._processPolygon(points, sparsity);

          this._processPolygonEnd(style);

          break;

        default:
          break;
      }

      if (style['shadowColor']) {
        this._processShadow(points, style, type);
      }
    }
  }, {
    key: "_processShadow",
    value: function _processShadow(components, style, type) {
      var len = components.length;

      for (var i = 0; i < len; i++) {
        var component = components[i];

        if (Array.isArray(component)) {
          if (component.length == 0) {
            return;
          }

          if (Array.isArray(component[0])) {
            this._processShadow(component);
          } else {
            this._drawShadow(component, style, type);
          }
        } else {
          var PS = component.PS;

          this._drawShadow(PS, style, type);
        }
      }
    }
  }, {
    key: "_drawShadow",
    value: function _drawShadow(points, style, type) {
      var h = -3.5;

      if (type == 'MULTIPOLYGON' || type == 'POLYGON') {
        for (var i = 0; i < points.length - 3; i += 2) {
          var _a = {};
          var _b = {};
          _a.x = points[i];
          _a.y = points[i + 1];
          _b.x = points[i + 2];
          _b.y = points[i + 3];
          var ax = _a.x;
          var ay = _a.y + h;
          var bx = _b.x;
          var by = _b.y + h;

          if ((bx - ax) * (_a.y - ay) < (_a.x - ax) * (by - ay)) {
            // this._drawShape([
            //     bx , by ,
            //     ax , ay ,
            //     _a.x, _a.y,
            //     _b.x, _b.y
            // ],true);
            // this._processShadowEnd(style);
            var shadowData = {};
            shadowData.data = [bx, by, ax, ay, _a.x, _a.y, _b.x, _b.y];
            shadowData.style = style;
            this.shadowDatas.push(shadowData);
          }
        }
      }
    }
  }, {
    key: "_processPoint",
    value: function _processPoint(points) {}
  }, {
    key: "_processLineString",
    value: function _processLineString(components, sparsity) {
      if (Array.isArray(components[0])) {
        var len = components.length;

        for (var i = 0; i < len; i++) {
          var component = components[i];

          this._processLineString(component, sparsity);
        }
      } else {
        this._renderLinePath(components, false, sparsity);
      }
    }
  }, {
    key: "_processLineStringEnd",
    value: function _processLineStringEnd(style) {
      var stroke = true;

      if (style.stroke == false) {
        stroke = false;
      }

      if (stroke != false) {
        if (this.resize) {
          this.ctx.lineWidth = style.strokeWidth * this.ratio;
        } else {
          this.ctx.lineWidth = style.strokeWidth;
        }

        this.ctx.strokeStyle = style.strokeColor;
        this.ctx.globalAlpha = style.strokeOpacity;

        if (style.dash != null) {
          this.ctx.setLineDash(style.dash);
        }

        if (style.lineCap) {
          this.ctx.lineCap = style.lineCap;
        }

        this.ctx.stroke();
        var customeColor = style['customeColor'];

        if (Drawer_typeof(customeColor) == "object" && customeColor['color'] != null) {
          this.ctx.strokeStyle = customeColor['color'];
          this.ctx.globalAlpha = customeColor['opacity'];
          this.ctx.stroke();
        }

        this.ctx.setLineDash([]);
        this.ctx.lineJoin = "round";
        this.ctx.lineCap = "butt";
      }
    }
  }, {
    key: "_processPolygon",
    value: function _processPolygon(components, sparsity) {
      if (Array.isArray(components[0])) {
        var len = components.length;

        for (var i = 0; i < len; i++) {
          var component = components[i];

          this._processPolygon(component, sparsity);
        }
      } else {
        this._renderLinePath(components, true, sparsity);
      }
    }
  }, {
    key: "_processPolygonEnd",
    value: function _processPolygonEnd(style) {
      var stroke = false;
      var fill = false;

      if (style.stroke == true) {
        stroke = true;
      }

      if (style.fill == true) {
        fill = true;
      }

      if (fill) {
        if (style['fillColor']) {
          this.ctx.fillStyle = style['fillColor'];
        }

        if (style['fillOpacity']) {
          this.ctx.globalAlpha = style['fillOpacity'];
        } else {
          this.ctx.globalAlpha = 1;
        }

        this.ctx.fill();
      }

      if (stroke) {
        if (style['strokeWidth']) {
          if (this.resize) {
            this.ctx.lineWidth = style.strokeWidth * this.ratio;
          } else {
            this.ctx.lineWidth = style.strokeWidth;
          }
        }

        if (style['strokeColor']) {
          this.ctx.strokeStyle = style['strokeColor'];
        }

        if (style['strokeOpacity']) {
          this.ctx.globalAlpha = style['strokeOpacity'];
        } else {
          this.ctx.globalAlpha = 1;
        }

        this.ctx.stroke();
      }

      if (style['texture']) {
        var textureId = style['texture'];
        var texture = this.textures(textureId);

        if (texture != null) {
          var ratio = style['textureratio'];
          var pat = this.ctx.createPattern(texture.toPattern(ratio), "repeat");
          this.ctx.fillStyle = pat;
          this.ctx.fill();
        }
      }

      var customeColor = style['customeColor'];

      if (Drawer_typeof(customeColor) == "object" && customeColor['color'] != null) {
        this.ctx.fillStyle = customeColor['color'];
        this.ctx.globalAlpha = customeColor['opacity'];
        this.ctx.fill();
      }
    }
  }, {
    key: "_isSavePoint",
    value: function _isSavePoint(previous, now, next, sparsity) {
      if (previous == null || next == null) {
        return true;
      }

      var dx = now[0] - previous[0];
      var dy = now[1] - previous[1];
      var dx1 = next[0] - now[0];
      var dy1 = next[1] - now[1];

      if (Math.sqrt(dx * dx + dy * dy) < sparsity && Math.sqrt(dx1 * dx1 + dy1 * dy1) < sparsity) {
        return false;
      } else {
        return true;
      }
    }
  }, {
    key: "_renderLinePath",
    value: function _renderLinePath(points, close, sparsity) {
      //   sparsity = 2.5
      if (this.resize) {
        this.ctx.moveTo(points[0] * this.ratio, points[1] * this.ratio);
      } else {
        this.ctx.moveTo(points[0], points[1]);
      }

      var i = 2;
      var len = points.length;

      if (len % 2 != 0) {
        len = len - 1;
      }

      var previous = [points[0], points[1]];
      var now = null;
      var next = null;

      while (i < len) {
        var gap = 0;
        now = [points[i], points[i + 1]];

        if (sparsity != null) {
          if (i + 2 > len) {
            next = null;
          } else {
            next = [points[i + 2], points[i + 3]];
          }

          while (!this._isSavePoint(previous, now, next, sparsity * this.ratio)) {
            gap = gap + 2;
            now = [points[i + gap], points[i + 1 + gap]];

            if (i + 2 + gap > len) {
              next = null;
            } else {
              next = [points[i + 2 + gap], points[i + 3 + gap]];
            }
          }
        }

        if (this.resize) {
          this.ctx.lineTo(now[0] * this.ratio, now[1] * this.ratio);
        } else {
          this.ctx.lineTo(now[0], now[1]);
        }

        previous = now;
        i = i + gap + 2;
      }

      if (close) {
        if (this.resize) {
          this.ctx.lineTo(points[0] * this.ratio, points[1] * this.ratio);
        } else {
          this.ctx.lineTo(points[0], points[1]);
        }

        this.ctx.closePath();
      }
    }
  }]);

  return Drawer;
}(draw_AbstractVTileProcess);

/* harmony default export */ var draw_Drawer = (Drawer);
// CONCATENATED MODULE: ./src/layer/vector/draw/BackgroundDrawer.js
function BackgroundDrawer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function BackgroundDrawer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function BackgroundDrawer_createClass(Constructor, protoProps, staticProps) { if (protoProps) BackgroundDrawer_defineProperties(Constructor.prototype, protoProps); if (staticProps) BackgroundDrawer_defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by kongjian on 2017/6/26.
 */
var BackgroundDrawer = /*#__PURE__*/function () {
  function BackgroundDrawer(config) {
    BackgroundDrawer_classCallCheck(this, BackgroundDrawer);

    this.ratio = config.ratio;
    this.datasArr = [];
    this.ctx = config.ctx;
    this.extent = config.extent;
    this.control = config.control;
    this.styleFn = null;
    this.drawable = false;
  }

  BackgroundDrawer_createClass(BackgroundDrawer, [{
    key: "getName",
    value: function getName() {
      return this.name;
    }
    /**
     * 加入样式队列
     * @param fn
     */

  }, {
    key: "setStyle",
    value: function setStyle(fn) {
      this.styleFn = fn;
    }
  }, {
    key: "draw",
    value: function draw() {
      this.drawable = true;
      this.doDraw();
    }
    /**
     * 绘制
     */

  }, {
    key: "doDraw",
    value: function doDraw(layerFilter) {
      return; // if (this.drawable) {
      //     // console.log(this.control.controlObj)
      //     if (this.control != null) {
      //         if (this.control.controlObj != null) {
      //             if (this.control.controlObj.otherDisplay == false) {
      //                 return;
      //             }
      //         }
      //     }
      //     let style = null;
      //     style = this.styleFn.call({}, this.level);
      //     if (style.backgroundColor == "undefined") {
      //         return;
      //     }
      //     if (style.backgroundColor) {
      //         this.ctx.fillStyle = style.backgroundColor;
      //     }
      //     if (style.fillOpacity) {
      //         this.ctx.globalAlpha = style.fillOpacity / 100;
      //     } else {
      //         this.ctx.globalAlpha = 1;
      //     }
      //     this.ctx.fillRect(0, 0, 512 * this.ratio, 512 * this.ratio);
      // }
    }
  }]);

  return BackgroundDrawer;
}();

/* harmony default export */ var draw_BackgroundDrawer = (BackgroundDrawer);
// CONCATENATED MODULE: ./src/layer/vector/draw/DataHolder.js
function DataHolder_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { DataHolder_typeof = function _typeof(obj) { return typeof obj; }; } else { DataHolder_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return DataHolder_typeof(obj); }

function DataHolder_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function DataHolder_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function DataHolder_createClass(Constructor, protoProps, staticProps) { if (protoProps) DataHolder_defineProperties(Constructor.prototype, protoProps); if (staticProps) DataHolder_defineProperties(Constructor, staticProps); return Constructor; }

function DataHolder_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) DataHolder_setPrototypeOf(subClass, superClass); }

function DataHolder_setPrototypeOf(o, p) { DataHolder_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return DataHolder_setPrototypeOf(o, p); }

function DataHolder_createSuper(Derived) { var hasNativeReflectConstruct = DataHolder_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = DataHolder_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = DataHolder_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return DataHolder_possibleConstructorReturn(this, result); }; }

function DataHolder_possibleConstructorReturn(self, call) { if (call && (DataHolder_typeof(call) === "object" || typeof call === "function")) { return call; } return DataHolder_assertThisInitialized(self); }

function DataHolder_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function DataHolder_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function DataHolder_getPrototypeOf(o) { DataHolder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return DataHolder_getPrototypeOf(o); }

/**
 * Created by kongjian on 2017/6/26.
 */




var DataHolder_DataHolder = /*#__PURE__*/function (_AbstractDataHolder) {
  DataHolder_inherits(DataHolder, _AbstractDataHolder);

  var _super = DataHolder_createSuper(DataHolder);

  function DataHolder(config) {
    DataHolder_classCallCheck(this, DataHolder);

    return _super.call(this, config, draw_Drawer);
  }

  DataHolder_createClass(DataHolder, [{
    key: "getBackground",
    value: function getBackground() {
      var backgroundDrawer = new draw_BackgroundDrawer({
        extent: this.extent,
        ctx: this.ctx,
        control: this.control,
        ratio: this.ratio
      });
      return backgroundDrawer;
    }
  }, {
    key: "getWatermark",
    value: function getWatermark() {}
  }]);

  return DataHolder;
}(draw_AbstractDataHolder);

/* harmony default export */ var draw_DataHolder = (DataHolder_DataHolder);
// CONCATENATED MODULE: ./src/layer/vector/GVMapGrid.js
/**
 * Created by kongjian on 2017/9/26.
 * 前端绘制底图layer
 */






var GVMapGrid = external_L_default.a.TileLayer.extend({
  //多个服务器url的域名，用于解决一个域名只有6条请求管线的限制
  urlArray: [],
  // 不带过滤条件的url
  sourceUrl: null,
  // 纹理图标集合
  textures: {},
  //瓦片队列
  tileQueue: [],
  //缩放比例
  ratio: 1,
  //过滤json对象
  control: null,
  //过滤的id
  controlId: null,
  //瓦片大小
  tilesize: 256,
  initialize: function initialize(url, options) {
    if (window.devicePixelRatio > 1.5) {
      this.ratio = 2;
    }

    if (!this.sourceUrl) {
      this.sourceUrl = url;
    }

    if (options && options.tileSize) {
      this.tilesize = options.tileSize;
    }

    this.gVMapGridUtil = new draw_GVMapGridUtil();
    this.gVMapGridUtil.tileSize = this.tilesize;
    this.gVMapGridUtil.parseUrl(url);
    this._url = url + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version;
    external_L_default.a.setOptions(this, options);
    this.on('tileunload', this._onTileRemove);
    this.on('tileload', this._onTileLoad);
    this.on('tileerror', this._onTileError);
  },
  onAdd: function onAdd() {
    if (this.control) {
      this._url = this.sourceUrl + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&control=' + this.control;
    }

    if (this.controlId) {
      this._url = this.sourceUrl + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&controlId=' + this.controlId;
    }

    this._initContainer();

    this._levels = {};
    this._tiles = {};
    var reqArr = this.gVMapGridUtil.loadStyle('layer');
    Promise.all(reqArr).then(function () {
      this._resetView();

      this._update();
    }.bind(this));
  },

  /**
   * 重写构造瓦片的方法
   */
  createTile: function createTile(coords, done) {
    //从队列中取canvas，避免频繁创建canvas
    var tile = this.tileQueue.pop();

    if (!tile) {
      tile = this.initTile();
    } else {
      this._cleanTile(tile);
    }

    var url = this.getTileUrl(coords);
    Object(es6_promise["c" /* getJSON */])({
      url: url,
      dataType: 'json'
    }).then(function (data) {
      tile.data = data;

      this._tileOnLoad.apply(this, [done, tile]);
    }.bind(this), function (error) {
      this._tileOnError.apply(this, [done, tile, error]);
    }.bind(this));
    return tile;
  },

  /**
   * 获取url的方法
   */
  getTileUrl: function getTileUrl(coords) {
    var data = {
      r: external_L_default.a.Browser.retina ? '@2x' : '',
      s: this._getSubdomain(coords),
      x: coords.x,
      y: coords.y,
      z: this._getZoomForUrl()
    };

    if (this._map && !this._map.options.crs.infinite) {
      var invertedY = this._globalTileRange.max.y - coords.y;

      if (this.options.tms) {
        data['y'] = invertedY;
      }

      data['-y'] = invertedY;
    }

    if (this.urlArray.length == 0) {
      return external_L_default.a.Util.template(this._url, external_L_default.a.extend(data, this.options));
    } else {
      //从urlArray中随机取出一个url
      var len = this.urlArray.length - 1;
      var index = Math.round(Math.random() * len);
      var url = this.urlArray[index];

      var array = this._url.split('/mapserver');

      var partUrl = array[1];
      url = url + '/mapserver' + partUrl;
      return external_L_default.a.Util.template(url, external_L_default.a.extend(data, this.options));
    }
  },

  /**
   *  初始化canvas
   */
  initTile: function initTile() {
    // console.time('initTile');
    var tile = document.createElement("canvas");
    tile.style.width = this.tilesize + "px";
    tile.style.height = this.tilesize + "px";
    tile.width = this.tilesize;
    tile.height = this.tilesize;
    var ctx = tile.getContext("2d", {
      isQuality: true
    });
    tile.ctx = ctx; // console.timeEnd('initTile');

    return tile;
  },
  //移除瓦片
  _onTileRemove: function _onTileRemove(e) {
    //加入到瓦片队列
    this.tileQueue.push(e.tile);
  },

  /**
   *  重写，取消请求的操作
   */
  _abortLoading: function _abortLoading() {
    var i, tile;

    for (i in this._tiles) {
      if (this._tiles[i].coords.z !== this._tileZoom) {
        tile = this._tiles[i].el;

        if (!tile.complete) {
          external_L_default.a.DomUtil.remove(tile);
        }
      }
    }
  },
  _onTileLoad: function _onTileLoad(item) {
    var tile = item.tile;

    this._drawTile(tile, tile.data);

    tile.complete = true;
  },
  _onTileError: function _onTileError(item) {
    var tile = item.tile;
    tile.complete = true;
    this.tileQueue.push(tile);
  },
  _tileOnError: function _tileOnError(done, tile, e) {
    done(e, tile);
  },
  _drawTile: function _drawTile(tile, features) {
    // console.time('_drawTile');
    var ctx = tile.ctx;
    var level = Math.floor(this._map.getZoom());
    var holder = new draw_DataHolder({
      layerDataMap: features,
      ctx: ctx,
      ratio: 1,
      control: null,
      textures: this.gVMapGridUtil.textures,
      extent: {
        level: level
      }
    });
    this.gVMapGridUtil.styleFun.call({}, holder, level); // console.timeEnd('_drawTile');
  },
  _cleanTile: function _cleanTile(tile) {
    tile.ctx.clearRect(0, 0, this.tilesize, this.tilesize);
  },
  _update: function _update() {
    if (this.isSetIngFilter) {
      return;
    }

    external_L_default.a.TileLayer.prototype._update.call(this);
  },

  /**
   * 设置过滤条件
   */
  setFilter: function setFilter(filter) {
    this.isSetIngFilter = true;

    if (!this._url || !filter || filter.layers.length == 0 && filter.order.length == 0) {
      this.isSetIngFilter = false;
      this.controlId = null;
      this.control = null;
      this.setUrl(this.sourceUrl + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version);
      return;
    }

    this.gVMapGridUtil.setFilter(filter, function (result) {
      this.isSetIngFilter = false;

      if (result.isIE) {
        this.controlId = result.id;
        this.setUrl(this.sourceUrl + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&controlId=' + result.id);
      } else {
        this.control = result.id;
        this.setUrl(this.sourceUrl + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&control=' + result.id);
      }
    }.bind(this));
  },

  /**
   * 根据屏幕坐标获取拾取到的要素
   * Parameters :
   * x -
   * y -
   * callback - 拾取成功的回调函数
   */
  getFeatureByXY: function getFeatureByXY(x, y, callback) {
    var latLng = this._map.containerPointToLatLng(new external_L_default.a.point(x, y));

    this.getFeatureByLonlat(latLng, callback);
  },

  /**
   * 根据地理坐标获取拾取到的要素
   * Parameters :
   * lonlat - 地理坐标对象
   * callback - 拾取成功的回调函数
   */
  getFeatureByLonlat: function getFeatureByLonlat(latLng, callback) {
    var maxBounds = this._map.options.crs.projection.bounds; //地图当前范围

    var bounds = this._map.getBounds();

    var pBounds = this._map.getPixelBounds(); //地图当前分辨率


    var res = (bounds._northEast.lat - bounds._southWest.lat) / (pBounds.max.y - pBounds.min.y);
    var tileSize = this.options.tileSize;
    var row = (maxBounds.max.y - latLng.lat) / (res * tileSize);
    var col = (latLng.lng - maxBounds.min.x) / (res * tileSize);

    var level = this._map.getZoom();

    var tx = (col - Math.floor(col)) * tileSize;
    var ty = (row - Math.floor(row)) * tileSize;
    this.gVMapGridUtil.pickupFeatures(row, col, level, tx, ty, this.control, this.controlId, function (features) {
      callback(features);
    });
  },

  /**
   * 根据指定的样式高亮要素
   * Parameters :
   * layerFeatures - 要素数组
   * style - 高亮样式 如：{color:"red",opacity:0.8};
   */
  highlightFeatures: function highlightFeatures(layerFeatures, style) {
    //获取高亮的过滤条件
    var filter = this.gVMapGridUtil.CreateHighlightFilter(layerFeatures, style); //如果没有过滤任何要素

    if (filter.layers.length == 0) {
      return;
    } // style.color = style.color.replace('#','%23');


    if (!this.highlightLayer) {
      //构造高亮图层
      var url = this.gVMapGridUtil.host + '/mapserver/vmap/' + this.gVMapGridUtil.servername + '/getMAP?x={x}&y={y}&l={z}' + '&styleId=' + this.gVMapGridUtil.styleId;

      if (this.control) {
        url = url + '&control=' + this.control;
      }

      if (this.controlId) {
        url = url + '&controlId=' + this.controlId;
      }

      this.highlightLayer = new external_L_default.a.GXYZ(url, this.options);

      this._map.addLayer(this.highlightLayer);
    }

    this.highlightLayer.options.opacity = style.opacity;

    this.highlightLayer._updateOpacity(); //设置高亮过滤条件


    this.highlightLayer.setFilter(filter); //获取当前图层的index

    var index = this.options.zIndex; //设置高亮图层在当前底图图层之上

    this.highlightLayer.setZIndex(index + 1);
  },

  /**
   * 根据Filter高亮指定要素
   * Parameters :
   * filter - Filter对象
   */
  highlightByFilter: function highlightByFilter(filter) {
    //如果没有过滤任何要素
    if (filter.layers.length == 0) {
      return;
    } // style.color = style.color.replace('#','%23');


    if (!this.highlightLayer) {
      //构造高亮图层
      var url = this.gVMapGridUtil.host + '/mapserver/vmap/' + this.gVMapGridUtil.servername + '/getMAP?x={x}&y={y}&l={z}' + '&styleId=' + this.gVMapGridUtil.styleId;

      if (this.control) {
        url = url + '&control=' + this.control;
      }

      if (this.controlId) {
        url = url + '&controlId=' + this.controlId;
      }

      this.highlightLayer = new external_L_default.a.GXYZ(url, this.options);

      this._map.addLayer(this.highlightLayer);
    }

    this.highlightLayer.options.opacity = 1;

    this.highlightLayer._updateOpacity(); //设置高亮过滤条件


    this.highlightLayer.setFilter(filter); //获取当前图层的index

    var index = this.options.zIndex; //设置高亮图层在当前底图图层之上

    this.highlightLayer.setZIndex(index + 1);
  },

  /**
   * 取消高亮
   */
  cancelHighlight: function cancelHighlight() {
    if (this.highlightLayer) {
      this._map.removeLayer(this.highlightLayer);

      this.highlightLayer = null;
    }
  }
});
external_L_default.a.geoway.GVMapGrid = GVMapGrid;
external_L_default.a.GVMapGrid = GVMapGrid;
/* harmony default export */ var vector_GVMapGrid = (GVMapGrid);
// CONCATENATED MODULE: ./src/layer/vector/GDynamicMap.js
/**
 * Created by kongjian on 2017/9/26.
 * 前端绘制底图layer
 */





var GDynamicMap = vector_GVMapGrid.extend({
  // styleObj对象
  styleObj: {},
  //sytle的js形式，为字符串
  styleJs: null,
  initialize: function initialize(url, options) {
    options.isDynamicMap = true;

    if (window.devicePixelRatio > 1.5) {
      this.ratio = 2;
    }

    if (!this.sourceUrl) {
      this.sourceUrl = url;
    }

    if (options && options.tileSize) {
      this.tilesize = options.tileSize;
    }

    this.gVMapGridUtil = new draw_GVMapGridUtil(options.isDynamicMap);
    this.gVMapGridUtil.tileSize = this.tilesize;
    this.gVMapGridUtil.parseUrl(url);
    this._url = url + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version;
    external_L_default.a.setOptions(this, options);
    this.on('tileunload', this._onTileRemove);
    this.on('tileload', this._onTileLoad);
    this.on('tileerror', this._onTileError);
  },
  onAdd: function onAdd() {
    if (this.control) {
      this._url = this.sourceUrl + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&control=' + this.control;
    }

    if (this.controlId) {
      this._url = this.sourceUrl + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&controlId=' + this.controlId;
    }

    this._initContainer();

    this._levels = {};
    this._tiles = {};
    this.gVMapGridUtil.setStyle(this.styleObj);
    var reqArr = this.gVMapGridUtil.loadStyle('layer');
    Promise.all(reqArr).then(function () {
      this._resetView();

      this._update();
    }.bind(this));
  },
  addLevels: function addLevels(gLevels) {
    this.styleObj[gLevels.levelsKey] = gLevels.levelsData;
  },
  redraw: function redraw() {
    this.gVMapGridUtil.formatStyle(this.styleObj, function () {
      if (this._map) {
        this._removeAllTiles();

        this._update();
      }
    });
    return this;
  }
});
external_L_default.a.geoway.GDynamicMap = GDynamicMap;
external_L_default.a.GDynamicMap = GDynamicMap;
/* harmony default export */ var vector_GDynamicMap = (GDynamicMap);
// CONCATENATED MODULE: ./src/layer/vector/GXYZ.js
/**
 * Created by kongjian on 2017/7/3.
 * 后端绘制底图layer
 */




var GXYZ = external_L_default.a.TileLayer.extend({
  //多个服务器url的域名，用于解决一个域名只有6条请求管线的限制
  urlArray: [],
  // 不带过滤条件的url
  sourceUrl: null,
  //底图图层的代理类，负责封装过滤，拾取高亮等接口
  gxyzUtil: null,
  //高亮图层
  highlightLayer: null,
  //缩放比例
  ratio: 1,
  //过滤json对象
  control: null,
  //过滤的id
  controlId: null,
  //瓦片大小
  tilesize: 256,
  initialize: function initialize(url, options) {
    if (window.devicePixelRatio > 1.5) {
      this.ratio = 2;
    }

    if (!this.sourceUrl) {
      this.sourceUrl = url;
    }

    if (options && options.tileSize) {
      this.tilesize = options.tileSize;
    }

    this.gxyzUtil = new draw_GXYZUtil();
    this.gxyzUtil.tileSize = this.tilesize;
    this.gxyzUtil.parseUrl(url);
    this._url = url + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version;
    external_L_default.a.setOptions(this, options);
  },
  onAdd: function onAdd() {
    if (this.control) {
      this._url = this.sourceUrl + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&control=' + this.control;
    }

    if (this.controlId) {
      this._url = this.sourceUrl + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&controlId=' + this.controlId;
    }

    this._initContainer();

    this._levels = {};
    this._tiles = {};

    this._resetView();

    this._update();
  },
  _update: function _update() {
    if (this.isSetIngFilter) {
      return;
    }

    external_L_default.a.TileLayer.prototype._update.call(this);
  },

  /**
   * 获取url的方法
   */
  getTileUrl: function getTileUrl(coords) {
    var data = {
      r: external_L_default.a.Browser.retina ? '@2x' : '',
      s: this._getSubdomain(coords),
      x: coords.x,
      y: coords.y,
      z: this._getZoomForUrl()
    };

    if (this._map && !this._map.options.crs.infinite) {
      var invertedY = this._globalTileRange.max.y - coords.y;

      if (this.options.tms) {
        data['y'] = invertedY;
      }

      data['-y'] = invertedY;
    }

    if (this.urlArray.length == 0) {
      return external_L_default.a.Util.template(this._url, external_L_default.a.extend(data, this.options));
    } else {
      //从urlArray中随机取出一个url
      var len = this.urlArray.length - 1;
      var index = Math.round(Math.random() * len);
      var url = this.urlArray[index];

      var array = this._url.split('/mapserver');

      var partUrl = array[1];
      url = url + '/mapserver' + partUrl;
      return external_L_default.a.Util.template(url, external_L_default.a.extend(data, this.options));
    }
  },

  /**
   * 设置过滤条件
   */
  setFilter: function setFilter(filter) {
    this.isSetIngFilter = true;

    if (!this._url || !filter || filter.layers.length == 0 && filter.order.length == 0) {
      this.isSetIngFilter = false;
      this.controlId = null;
      this.control = null;
      this.setUrl(this.sourceUrl + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version);
      return;
    }

    this.gxyzUtil.setFilter(filter, function (result) {
      this.isSetIngFilter = false;

      if (result.isIE) {
        this.controlId = result.id;
        this.setUrl(this.sourceUrl + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&controlId=' + result.id);
      } else {
        this.control = result.id;
        this.setUrl(this.sourceUrl + '&ratio=' + this.ratio + '&tilesize=' + this.tilesize + '&clientVersion=' + ext_Version + '&control=' + result.id);
      }
    }.bind(this));
  },

  /**
   * 根据屏幕坐标获取拾取到的要素
   * Parameters :
   * x -
   * y -
   * callback - 拾取成功的回调函数
   */
  getFeatureByXY: function getFeatureByXY(x, y, callback) {
    var latLng = this._map.containerPointToLatLng(new external_L_default.a.point(x, y));

    var level = this._map.getZoom();

    var smta = this._map.options.crs.project(latLng);

    this.gxyzUtil.pickupFeaturesBylatlng(level, this.control, this.controlId, smta.y, smta.x, callback); //this.getFeatureByLonlat(latLng,callback);
  },

  /**
   * 根据地理坐标获取拾取到的要素
   * Parameters :
   * lonlat - 地理坐标对象
   * callback - 拾取成功的回调函数
   */
  getFeatureByLonlat: function getFeatureByLonlat(latLng, callback) {
    var pt = this._map.options.crs.projection.project(latLng);

    var maxBounds = this._map.options.crs.projection.bounds; //地图当前范围

    var bounds = this._map.getBounds();

    var pBounds = this._map.getPixelBounds();

    var east = this._map.options.crs.projection.project(bounds._northEast);

    var west = this._map.options.crs.projection.project(bounds._southWest); //地图当前分辨率


    var res = (east.y - west.y) / (pBounds.max.y - pBounds.min.y);
    var tileSize = this.options.tileSize;
    var row = (maxBounds.max.y - pt.y) / (res * tileSize);
    var col = (pt.x - maxBounds.min.x) / (res * tileSize);

    var level = this._map.getZoom();

    var tx = (col - Math.floor(col)) * tileSize;
    var ty = (row - Math.floor(row)) * tileSize;
    this.gxyzUtil.pickupFeatures(row, col, level, tx, ty, this.control, this.controlId, function (features) {
      callback(features);
    });
  },

  /**
   * 根据指定的样式高亮要素
   * Parameters :
   * layerFeatures - 要素map集合
   * style - 高亮样式 如：{color:"red",opacity:0.8};
   */
  highlightFeatures: function highlightFeatures(layerFeatures, style) {
    //获取高亮的过滤条件
    var filter = this.gxyzUtil.CreateHighlightFilter(layerFeatures, style); //如果没有过滤任何要素

    if (filter.layers.length == 0) {
      return;
    } // style.color = style.color.replace('#','%23');


    if (!this.highlightLayer) {
      //构造高亮图层
      this.highlightLayer = new external_L_default.a.GXYZ(this.sourceUrl, this.options);

      this._map.addLayer(this.highlightLayer);
    }

    this.highlightLayer.options.opacity = style.opacity;

    this.highlightLayer._updateOpacity(); //设置高亮过滤条件


    this.highlightLayer.setFilter(filter); //获取当前图层的index

    var index = this.options.zIndex; //设置高亮图层在当前底图图层之上

    this.highlightLayer.setZIndex(index + 1);
  },

  /**
   * 根据指定的样式高亮要素，每个要素都可以有不同的样式
   * Parameters :
   * layerFeatures - 要素map集合
   * opacity - 透明度，所有要高亮的要素都是必须是相同的透明度;
   */
  highlightEveryFeatures: function highlightEveryFeatures(layerFeatures, opacity) {
    //获取高亮的过滤条件
    var filter = this.gxyzUtil.CreateEveryHighlightFilter(layerFeatures); //如果没有过滤任何要素

    if (filter.layers.length == 0) {
      return;
    }

    if (!this.highlightLayer) {
      //构造高亮图层
      this.highlightLayer = new external_L_default.a.GXYZ(this.sourceUrl, this.options);

      this._map.addLayer(this.highlightLayer);
    }

    this.highlightLayer.options.opacity = opacity;

    this.highlightLayer._updateOpacity(); //设置高亮过滤条件


    this.highlightLayer.setFilter(filter); //获取当前图层的index

    var index = this.options.zIndex; //设置高亮图层在当前底图图层之上

    this.highlightLayer.setZIndex(index + 1);
  },

  /**
   * 根据Filter高亮指定要素
   * Parameters :
   * filter - Filter对象
   */
  highlightByFilter: function highlightByFilter(filter) {
    //如果没有过滤任何要素
    if (filter.layers.length == 0) {
      return;
    }

    if (!this.highlightLayer) {
      //构造高亮图层
      this.highlightLayer = new external_L_default.a.GXYZ(this.sourceUrl, this.options);

      this._map.addLayer(this.highlightLayer);
    }

    this.highlightLayer.options.opacity = 1;

    this.highlightLayer._updateOpacity(); //设置高亮过滤条件


    this.highlightLayer.setFilter(filter); //获取当前图层的index

    var index = this.options.zIndex; //设置高亮图层在当前底图图层之上

    this.highlightLayer.setZIndex(index + 1);
  },

  /**
   * 取消高亮
   */
  cancelHighlight: function cancelHighlight() {
    if (this.highlightLayer) {
      this._map.removeLayer(this.highlightLayer);

      this.highlightLayer = null;
    }
  }
});
external_L_default.a.geoway.GXYZ = GXYZ;
external_L_default.a.GXYZ = GXYZ;
/* harmony default export */ var vector_GXYZ = (GXYZ);
// CONCATENATED MODULE: ./src/layer/GServiceGroup.js
function GServiceGroup_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GServiceGroup_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function GServiceGroup_createClass(Constructor, protoProps, staticProps) { if (protoProps) GServiceGroup_defineProperties(Constructor.prototype, protoProps); if (staticProps) GServiceGroup_defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by kongjian on 2017/6/26.
 */



var GServiceGroup_GServiceGroup = /*#__PURE__*/function () {
  function GServiceGroup(layerId, url, map, options) {
    GServiceGroup_classCallCheck(this, GServiceGroup);

    this.map = null;
    this.layer = null;
    this.label = null;
    this.layerType = 0;
    this.labelType = 2;
    this.map = map;
    this.url = url;
    this.layerId = layerId;
    this.styleId = null;
    this.tileSize = 256;
    this.options = options;
  }

  GServiceGroup_createClass(GServiceGroup, [{
    key: "addServiceGroup",
    value: function addServiceGroup() {
      if (this.options && this.options.styleId) {
        this.styleId = this.options.styleId;
      }

      if (this.options && this.options.tileSize) {
        this.tileSize = this.options.tileSize;
      }

      switch (this.layerType) {
        case 0:
          this.addBaseLayer();
          break;

        case 1:
          this.addFrontBaseLayer();
          break;
      }

      switch (this.labelType) {
        case 2:
          this.addFrontLabel();
          break;

        case 3:
          this.AddImgLabel();
          break;

        case 4:
          this.addAvoidLabel();
          break;
      }
    }
    /*后端底图*/

  }, {
    key: "addBaseLayer",
    value: function addBaseLayer() {
      this.layer = new external_L_default.a.GXYZ(this.url + "&x={x}&y={y}&l={z}&tileType=" + this.layerType, {
        sphericalMercator: false,
        isBaseLayer: false,
        tileSize: this.tileSize
      });
      this.map.addLayer(this.layer);
    }
    /*前端底图*/

  }, {
    key: "addFrontBaseLayer",
    value: function addFrontBaseLayer() {
      this.layer = new external_L_default.a.GVMapGrid(this.url + "&x={x}&y={y}&l={z}&tileType=" + this.layerType, {
        maxZoom: 21,
        keepBuffer: 0,
        updateWhenZooming: false,
        tileSize: this.tileSize
      });
      this.map.addLayer(this.layer);
    } //////////////////////////////////////////////////////////////////////////

    /*后端注记绘制*/

  }, {
    key: "AddImgLabel",
    value: function AddImgLabel() {
      this.label = new external_L_default.a.GXYZ(this.url + "&x={x}&y={y}&l={z}&tileType=" + this.labelType, {
        sphericalMercator: false,
        isBaseLayer: false,
        tileSize: this.tileSize
      });
      this.map.addLayer(this.label);
    }
    /*后端注记避让*/

  }, {
    key: "addAvoidLabel",
    value: function addAvoidLabel() {
      this.label = new external_L_default.a.GLabelGrid(this.url + '&x={x}&y={y}&l={z}&tileType=' + this.labelType, {
        hitDetection: true,
        keepBuffer: 0,
        updateWhenZooming: false,
        tileSize: this.tileSize
      });
      this.map.addLayer(this.label);
    }
    /*前端*/

  }, {
    key: "addFrontLabel",
    value: function addFrontLabel() {
      this.label = new external_L_default.a.GWVTAnno("GWVTanno", {
        tileSize: this.tileSize
      });
      var dataSource = new datasource_URLDataSource();
      dataSource.url = this.url + '&x=${x}&y=${y}&l=${z}&tileType=' + this.labelType;
      this.label.addDataSource(dataSource);
      this.map.addLayer(this.label);
    }
  }, {
    key: "setLayerType",
    value: function setLayerType(layerType) {
      if (layerType == "Img") {
        this.layerType = 0;
      } else if (layerType == "Data") {
        this.layerType = 1;
      }
    }
  }, {
    key: "setLabelType",
    value: function setLabelType(labelType) {
      if (labelType == "Data") {
        this.labelType = 2;
      } else if (labelType == "Img") {
        this.labelType = 3;
      } else if (labelType == "AvoidImg") {
        this.labelType = 4;
      }
    }
  }, {
    key: "setTileSize",
    value: function setTileSize(tileSize) {
      this.tileSize = tileSize;
    }
  }, {
    key: "getLayer",
    value: function getLayer() {
      return this.layer;
    }
  }, {
    key: "getLabel",
    value: function getLabel() {
      return this.label;
    }
  }, {
    key: "removeGroupLayer",
    value: function removeGroupLayer() {
      if (this.layer) {
        this.map.removeLayer(this.layer);
      }

      if (this.label) {
        this.map.removeLayer(this.label);
      }
    }
  }]);

  return GServiceGroup;
}();

/* harmony default export */ var layer_GServiceGroup = (GServiceGroup_GServiceGroup);
// CONCATENATED MODULE: ./src/layer/vector/stylejs/GGroup.js
function GGroup_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GGroup_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function GGroup_createClass(Constructor, protoProps, staticProps) { if (protoProps) GGroup_defineProperties(Constructor.prototype, protoProps); if (staticProps) GGroup_defineProperties(Constructor, staticProps); return Constructor; }




var GGroup = /*#__PURE__*/function () {
  function GGroup(groupName) {
    GGroup_classCallCheck(this, GGroup);

    this.group = {};
    this.group.id = groupName;
    this.group.type = 'group';
    this.group.children = [];
  }
  /**
   * 添加样式
   * Parameters : gStyleItem  GStyleItem对象实例
   */


  GGroup_createClass(GGroup, [{
    key: "addStyle",
    value: function addStyle(gStyleItem) {
      this.group.children.push(gStyleItem.style);
    }
  }]);

  return GGroup;
}();

external_L_default.a.geoway.GGroup = GGroup;
/* harmony default export */ var stylejs_GGroup = (GGroup);
// CONCATENATED MODULE: ./src/layer/vector/stylejs/GLevels.js
function GLevels_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GLevels_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function GLevels_createClass(Constructor, protoProps, staticProps) { if (protoProps) GLevels_defineProperties(Constructor.prototype, protoProps); if (staticProps) GLevels_defineProperties(Constructor, staticProps); return Constructor; }




var GLevels = /*#__PURE__*/function () {
  function GLevels(startLevel, endLevel) {
    GLevels_classCallCheck(this, GLevels);

    this.levelsData = [];
    this.levelsKey = startLevel + '-' + endLevel;
  }
  /**
   * 添加组
   * Parameters : gGroup  GGroup对象实例
   */


  GLevels_createClass(GLevels, [{
    key: "addGroup",
    value: function addGroup(gGroup) {
      this.levelsData.push(gGroup.group);
    }
    /**
     * 添加组
     * Parameters : gGroup  GGroup对象实例
     */

  }, {
    key: "addStyleItem",
    value: function addStyleItem(gStyleItem) {
      this.levelsData.push(gStyleItem.style);
    }
  }]);

  return GLevels;
}();

external_L_default.a.geoway.GLevels = GLevels;
/* harmony default export */ var stylejs_GLevels = (GLevels);
// CONCATENATED MODULE: ./src/layer/index.js






















/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _util_Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);



var FormatXML = _Format__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].extend({
  namespaces: null,
  namespaceAlias: null,
  defaultPrefix: null,
  readers: {},
  writers: {},
  xmldom: null,
  initialize: function initialize(options) {
    if (window.ActiveXObject) {
      this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
    }

    _Format__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].prototype.initialize.apply(this, [options]); // clone the namespace object and set all namespace aliases

    this.namespaces = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.extend({}, this.namespaces);
    this.namespaceAlias = {};

    for (var alias in this.namespaces) {
      this.namespaceAlias[this.namespaces[alias]] = alias;
    }
  },
  destroy: function destroy() {
    this.xmldom = null;
    _Format__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].prototype.destroy.apply(this, arguments);
  },
  setNamespace: function setNamespace(alias, uri) {
    this.namespaces[alias] = uri;
    this.namespaceAlias[uri] = alias;
  },
  read: function read(text) {
    var index = text.indexOf('<');

    if (index > 0) {
      text = text.substring(index);
    }

    var node = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Util.tryFunc(leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Util.bind(function () {
      var xmldom;
      /**
       * Since we want to be able to call this method on the prototype
       * itself, this.xmldom may not exist even if in IE.
       */

      if (window.ActiveXObject && !this.xmldom) {
        xmldom = new ActiveXObject("Microsoft.XMLDOM");
      } else {
        xmldom = this.xmldom;
      }

      xmldom.loadXML(text);
      return xmldom;
    }, this), function () {
      return new DOMParser().parseFromString(text, 'text/xml');
    }, function () {
      var req = new XMLHttpRequest();
      req.open("GET", "data:" + "text/xml" + ";charset=utf-8," + encodeURIComponent(text), false);

      if (req.overrideMimeType) {
        req.overrideMimeType("text/xml");
      }

      req.send(null);
      return req.responseXML;
    });
    return node;
  },
  write: function write(node) {
    var data;

    if (this.xmldom) {
      data = node.xml;
    } else {
      var serializer = new XMLSerializer();

      if (node.nodeType == 1) {
        // Add nodes to a document before serializing. Everything else
        // is serialized as is. This may need more work. See #1218 .
        var doc = document.implementation.createDocument("", "", null);

        if (doc.importNode) {
          node = doc.importNode(node, true);
        }

        doc.appendChild(node);
        data = serializer.serializeToString(doc);
      } else {
        data = serializer.serializeToString(node);
      }
    }

    return data;
  },
  createElementNS: function createElementNS(uri, name) {
    var element;

    if (this.xmldom) {
      if (typeof uri == "string") {
        element = this.xmldom.createNode(1, name, uri);
      } else {
        element = this.xmldom.createNode(1, name, "");
      }
    } else {
      element = document.createElementNS(uri, name);
    }

    return element;
  },
  createDocumentFragment: function createDocumentFragment() {
    var element;

    if (this.xmldom) {
      element = this.xmldom.createDocumentFragment();
    } else {
      element = document.createDocumentFragment();
    }

    return element;
  },
  createTextNode: function createTextNode(text) {
    var node;

    if (typeof text !== "string") {
      text = String(text);
    }

    if (this.xmldom) {
      node = this.xmldom.createTextNode(text);
    } else {
      node = document.createTextNode(text);
    }

    return node;
  },
  getElementsByTagNameNS: function getElementsByTagNameNS(node, uri, name) {
    var elements = [];

    if (node.getElementsByTagNameNS) {
      elements = node.getElementsByTagNameNS(uri, name);
    } else {
      // brute force method
      var allNodes = node.getElementsByTagName("*");
      var potentialNode, fullName;

      for (var i = 0, len = allNodes.length; i < len; ++i) {
        potentialNode = allNodes[i];
        fullName = potentialNode.prefix ? potentialNode.prefix + ":" + name : name;

        if (name == "*" || fullName == potentialNode.nodeName) {
          if (uri == "*" || uri == potentialNode.namespaceURI) {
            elements.push(potentialNode);
          }
        }
      }
    }

    return elements;
  },
  getAttributeNodeNS: function getAttributeNodeNS(node, uri, name) {
    var attributeNode = null;

    if (node.getAttributeNodeNS) {
      attributeNode = node.getAttributeNodeNS(uri, name);
    } else {
      var attributes = node.attributes;
      var potentialNode, fullName;

      for (var i = 0, len = attributes.length; i < len; ++i) {
        potentialNode = attributes[i];

        if (potentialNode.namespaceURI == uri) {
          fullName = potentialNode.prefix ? potentialNode.prefix + ":" + name : name;

          if (fullName == potentialNode.nodeName) {
            attributeNode = potentialNode;
            break;
          }
        }
      }
    }

    return attributeNode;
  },
  getAttributeNS: function getAttributeNS(node, uri, name) {
    var attributeValue = "";

    if (node.getAttributeNS) {
      attributeValue = node.getAttributeNS(uri, name) || "";
    } else {
      var attributeNode = this.getAttributeNodeNS(node, uri, name);

      if (attributeNode) {
        attributeValue = attributeNode.nodeValue;
      }
    }

    return attributeValue;
  },
  getChildValue: function getChildValue(node, def) {
    var value = def || "";

    if (node) {
      for (var child = node.firstChild; child; child = child.nextSibling) {
        switch (child.nodeType) {
          case 3: // text node

          case 4:
            // cdata section
            value += child.nodeValue;
        }
      }
    }

    return value;
  },
  isSimpleContent: function isSimpleContent(node) {
    var simple = true;

    for (var child = node.firstChild; child; child = child.nextSibling) {
      if (child.nodeType === 1) {
        simple = false;
        break;
      }
    }

    return simple;
  },
  hasAttributeNS: function hasAttributeNS(node, uri, name) {
    var found = false;

    if (node.hasAttributeNS) {
      found = node.hasAttributeNS(uri, name);
    } else {
      found = !!this.getAttributeNodeNS(node, uri, name);
    }

    return found;
  },
  setAttributeNS: function setAttributeNS(node, uri, name, value) {
    if (node.setAttributeNS) {
      node.setAttributeNS(uri, name, value);
    } else {
      if (this.xmldom) {
        if (uri) {
          var attribute = node.ownerDocument.createNode(2, name, uri);
          attribute.nodeValue = value;
          node.setAttributeNode(attribute);
        } else {
          node.setAttribute(name, value);
        }
      } else {
        throw "setAttributeNS not implemented";
      }
    }
  },
  createElementNSPlus: function createElementNSPlus(name, options) {
    options = options || {}; // order of prefix preference
    // 1. in the uri option
    // 2. in the prefix option
    // 3. in the qualified name
    // 4. from the defaultPrefix

    var uri = options.uri || this.namespaces[options.prefix];

    if (!uri) {
      var loc = name.indexOf(":");
      uri = this.namespaces[name.substring(0, loc)];
    }

    if (!uri) {
      uri = this.namespaces[this.defaultPrefix];
    }

    var node = this.createElementNS(uri, name);

    if (options.attributes) {
      this.setAttributes(node, options.attributes);
    }

    var value = options.value;

    if (value != null) {
      node.appendChild(this.createTextNode(value));
    }

    return node;
  },
  setAttributes: function setAttributes(node, obj) {
    var value, uri;

    for (var name in obj) {
      if (obj[name] != null && obj[name].toString) {
        value = obj[name].toString(); // check for qualified attribute name ("prefix:local")

        uri = this.namespaces[name.substring(0, name.indexOf(":"))] || null;
        this.setAttributeNS(node, uri, name, value);
      }
    }
  },
  readNode: function readNode(node, obj) {
    if (!obj) {
      obj = {};
    }

    var group = this.readers[node.namespaceURI ? this.namespaceAlias[node.namespaceURI] : this.defaultPrefix];

    if (group) {
      var local = node.localName || node.nodeName.split(":").pop();
      var reader = group[local] || group["*"];

      if (reader) {
        reader.apply(this, [node, obj]);
      }
    }

    return obj;
  },
  readChildNodes: function readChildNodes(node, obj) {
    if (!obj) {
      obj = {};
    }

    var children = node.childNodes;
    var child;

    for (var i = 0, len = children.length; i < len; ++i) {
      child = children[i];

      if (child.nodeType == 1) {
        this.readNode(child, obj);
      }
    }

    return obj;
  },
  writeNode: function writeNode(name, obj, parent) {
    var prefix, local;
    var split = name.indexOf(":");

    if (split > 0) {
      prefix = name.substring(0, split);
      local = name.substring(split + 1);
    } else {
      if (parent) {
        prefix = this.namespaceAlias[parent.namespaceURI];
      } else {
        prefix = this.defaultPrefix;
      }

      local = name;
    }

    var child = this.writers[prefix][local].apply(this, [obj]);

    if (parent) {
      parent.appendChild(child);
    }

    return child;
  },
  getChildEl: function getChildEl(node, name, uri) {
    return node && this.getThisOrNextEl(node.firstChild, name, uri);
  },
  getNextEl: function getNextEl(node, name, uri) {
    return node && this.getThisOrNextEl(node.nextSibling, name, uri);
  },
  getThisOrNextEl: function getThisOrNextEl(node, name, uri) {
    outer: for (var sibling = node; sibling; sibling = sibling.nextSibling) {
      switch (sibling.nodeType) {
        case 1:
          // Element
          if ((!name || name === (sibling.localName || sibling.nodeName.split(":").pop())) && (!uri || uri === sibling.namespaceURI)) {
            // matches
            break outer;
          }

          sibling = null;
          break outer;

        case 3:
          // Text
          if (/^\s*$/.test(sibling.nodeValue)) {
            break;
          }

        case 4: // CDATA

        case 6: // ENTITY_NODE

        case 12: // NOTATION_NODE

        case 10: // DOCUMENT_TYPE_NODE

        case 11:
          // DOCUMENT_FRAGMENT_NODE
          sibling = null;
          break outer;
      } // ignore comments and processing instructions

    }

    return sibling || null;
  },
  lookupNamespaceURI: function lookupNamespaceURI(node, prefix) {
    var uri = null;

    if (node) {
      if (node.lookupNamespaceURI) {
        uri = node.lookupNamespaceURI(prefix);
      } else {
        outer: switch (node.nodeType) {
          case 1:
            // ELEMENT_NODE
            if (node.namespaceURI !== null && node.prefix === prefix) {
              uri = node.namespaceURI;
              break outer;
            }

            var len = node.attributes.length;

            if (len) {
              var attr;

              for (var i = 0; i < len; ++i) {
                attr = node.attributes[i];

                if (attr.prefix === "xmlns" && attr.name === "xmlns:" + prefix) {
                  uri = attr.value || null;
                  break outer;
                } else if (attr.name === "xmlns" && prefix === null) {
                  uri = attr.value || null;
                  break outer;
                }
              }
            }

            uri = this.lookupNamespaceURI(node.parentNode, prefix);
            break outer;

          case 2:
            // ATTRIBUTE_NODE
            uri = this.lookupNamespaceURI(node.ownerElement, prefix);
            break outer;

          case 9:
            // DOCUMENT_NODE
            uri = this.lookupNamespaceURI(node.documentElement, prefix);
            break outer;

          case 6: // ENTITY_NODE

          case 12: // NOTATION_NODE

          case 10: // DOCUMENT_TYPE_NODE

          case 11:
            // DOCUMENT_FRAGMENT_NODE
            break outer;

          default:
            // TEXT_NODE (3), CDATA_SECTION_NODE (4), ENTITY_REFERENCE_NODE (5),
            // PROCESSING_INSTRUCTION_NODE (7), COMMENT_NODE (8)
            uri = this.lookupNamespaceURI(node.parentNode, prefix);
            break outer;
        }
      }
    }

    return uri;
  },
  getXMLDoc: function getXMLDoc() {
    if (!this.xmldom && window.ActiveXObject) {
      this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
    }

    return this.xmldom;
  }
});
/* harmony default export */ __webpack_exports__["a"] = (FormatXML);

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Font = null; //import fonts from "./../../../../src/utils/font/Font";

var AvoidUtil = /*#__PURE__*/function () {
  function AvoidUtil() {
    _classCallCheck(this, AvoidUtil);
  }

  _createClass(AvoidUtil, null, [{
    key: "getRealLength",
    value: function getRealLength(str) {
      var length = str.length;
      var realLength = 0;

      for (var i = 0; i < length; i++) {
        var charCode = str.charCodeAt(i);

        if (charCode >= 0 && charCode <= 128) {
          realLength += 0.5;
        } else {
          realLength += 1;
        }
      }

      return realLength;
    }
    /**
     * 判断文本是否不为空
     *  Parameters :
     *  label - 要显示的文本
     *
     */

  }, {
    key: "isNotNull",
    value: function isNotNull(label) {
      if (!label && label != 0) {
        return false;
      } //如果是字符串


      if (typeof label == 'string') {
        label = label.toLowerCase();

        if (label == '' || label == 'undefined' || label == 'null') {
          return false;
        }
      }

      return true;
    }
    /**
     * 统一转为微软雅黑
     */

  }, {
    key: "formatFont",
    value: function formatFont(font, ratio, isChangeFont) {
      //console.log(font)
      var fontArr = font;

      if (isChangeFont) {
        if (Font == null) {
          Font = null;
        }

        var farr = font.split(' '); // farr[farr.length -1] = 'Comic Sans';

        if (farr.length - 1 != 0) {
          if ("italic" == farr[0].toLowerCase()) {
            if (farr[farr.length - 1] != "simhei") {
              farr[farr.length - 1] = Font.getDefaultFont() + "_italic";
            }
          } else {
            farr[farr.length - 1] = Font.getDefaultFont();
          }
        } else {
          farr[farr.length - 1] = Font.getDefaultFont();
        }

        fontArr = farr.join(' ');
      }

      return fontArr.replace(/(\d+\.?\d*)(px|em|rem|pt)/g, function (w, m, u) {
        // if (m < 12) {
        //     m = m * ratio;
        // } else {
        // }
        m = Math.round(m) * ratio;
        return m + u;
      });
    }
  }, {
    key: "formatLabel",

    /**
     * 对注记进行去空格等处理
     */
    value: function formatLabel(label) {
      if (label && label.length > 0) {
        //去掉不可见字符
        label = label.replace(/([\x00-\x1f\x7f])/g, '');
        label = label.replace(/(\s*$)/g, "");
        label = label.replace(/<br\/>/g, "");
      }

      return label;
    } //获取两点连线与y轴的夹角

  }, {
    key: "getAngle",
    value: function getAngle(p1, p2) {
      if (p2[0] - p1[0] == 0) {
        if (p2[1] > p1[0]) {
          return 90;
        } else {
          return -90;
        }
      }

      var k = (p2[1] - p1[1]) / (p2[0] - p1[0]);
      var angle = 360 * Math.atan(k) / (2 * Math.PI);
      return angle;
    }
  }]);

  return AvoidUtil;
}();

/* harmony default export */ __webpack_exports__["a"] = (AvoidUtil);

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Util = /*#__PURE__*/function () {
  function Util() {
    _classCallCheck(this, Util);
  }

  _createClass(Util, null, [{
    key: "measureText",
    value: function measureText(label, font, ctx) {
      return ctx.measureText(label).width;
    } //要素排序.

  }, {
    key: "sort",
    value: function sort(features, styleMap, hasImportant) {
      if (features.length > 0) {
        //从大到少排序
        return features.sort(function (a, b) {
          if (hasImportant) {
            var aStyle = styleMap[a.styleId];
            var bStyle = styleMap[b.styleId];

            if (aStyle.isImportant && !bStyle.isImportant) {
              return -1;
            }

            if (bStyle.isImportant && !aStyle.isImportant) {
              return 1;
            }
          }

          var aAttr = a.weight;
          var bAttr = b.weight; // let aId = a.attributeId;
          // let bId = b.attributeId;

          var aId = a.primaryId;
          var bId = b.primaryId;

          if (!aAttr) {
            aAttr = -1;
          }

          if (!bAttr) {
            bAttr = -1;
          }

          if (aAttr < bAttr) {
            return 1;
          } else if (aAttr == bAttr) {
            if (aId < bId) {
              return 1;
            } else {
              return -1;
            }
          } else {
            return -1;
          }
        }.bind(this));
      }
    } //要素排序.

  }, {
    key: "sortPrimaryId",
    value: function sortPrimaryId(features) {
      if (features.length > 0) {
        //从大到少排序
        return features.sort(function (a, b) {
          var aAttr = a.weight;
          var bAttr = b.weight;
          var aId = a.primaryId;
          var bId = b.primaryId;

          if (!aAttr) {
            aAttr = -1;
          }

          if (!bAttr) {
            bAttr = -1;
          }

          if (aAttr < bAttr) {
            return 1;
          } else if (aAttr == bAttr) {
            if (aId < bId) {
              return 1;
            } else {
              return -1;
            }
          } else {
            return -1;
          }
        }.bind(this));
      }
    }
    /**
     * 把注记按照显示的注记名称分组
     * @param features
     * @returns {{}}
     */

  }, {
    key: "groupByLabel",
    value: function groupByLabel(features) {
      var labelMap = {};

      for (var i = 0; i < features.length; i++) {
        var feature = features[i];

        if (feature.label == null && feature.iconImg != null) {
          if (labelMap[feature.attributeId] == null) {
            labelMap[feature.attributeId] = [];
          }

          labelMap[feature.attributeId].push(feature);
        } else {
          if (!labelMap[feature.type + '_' + feature.label]) {
            labelMap[feature.type + '_' + feature.label] = [];
          }

          labelMap[feature.type + '_' + feature.label].push(feature);
        }
      }

      return labelMap;
    }
  }]);

  return Util;
}();

/* harmony default export */ __webpack_exports__["a"] = (Util);

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by matt on 2017/7/16.
 */
//几个像素可以算是命中
var _dis = 5;

var GisTools = /*#__PURE__*/function () {
  function GisTools() {
    _classCallCheck(this, GisTools);
  }

  _createClass(GisTools, null, [{
    key: "pointDistToLine",
    value: function pointDistToLine(x, y, startx, starty, endx, endy) {
      var se = (startx - endx) * (startx - endx) + (starty - endy) * (starty - endy);
      var p = (x - startx) * (endx - startx) + (y - starty) * (endy - starty);
      var r = p / se;
      var outx = startx + r * (endx - startx);
      var outy = starty + r * (endy - starty);
      var des = Math.sqrt((x - outx) * (x - outx) + (y - outy) * (y - outy)); //console.log(des);

      return des;
    }
  }, {
    key: "isPointOnSegment",
    value: function isPointOnSegment(px, py, p1x, p1y, p2x, p2y) {
      if (px - _dis > p1x && px + _dis > p2x || px + _dis < p1x && px - _dis < p2x) {
        return 0;
      }

      if (py - _dis > p1y && py + _dis > p2y || py + _dis < p1y && py - _dis < p2y) {
        return 0;
      }

      var d = GisTools.pointDistToLine(px, py, p1x, p1y, p2x, p2y);

      if (d < _dis) {
        return 1;
      } else {
        return 0;
      }
    }
  }, {
    key: "pointInLine",
    value: function pointInLine(px, py, polyline) {
      var flag = 0;
      var line = [];

      if (Array.isArray(polyline[0])) {
        line = polyline;
      } else {
        line.push(polyline);
      }

      for (var polyIndex = 0; polyIndex < line.length; polyIndex++) {
        var subpoly = line[polyIndex];
        var length = subpoly.length / 2; // for (var i = 0, l = length, j = l - 1; i < l; j = i, i++) {

        for (var i = 0; i < length - 1; i++) {
          var j = void 0;
          j = i + 1;
          var sx = subpoly[2 * i],
              sy = subpoly[2 * i + 1],
              tx = subpoly[2 * j],
              ty = subpoly[2 * j + 1];

          if (GisTools.isPointOnSegment(px, py, sx, sy, tx, ty) == 1) {
            return 1;
          }
        }
      }

      return 0;
    }
  }, {
    key: "pointInPolygon",
    value: function pointInPolygon(px, py, polygen) {
      var flag = 0;
      var poly = [];

      if (Array.isArray(polygen[0])) {
        poly = polygen;
      } else {
        poly.push(polygen);
      }

      for (var polyIndex = 0; polyIndex < poly.length; polyIndex++) {
        var subpoly = poly[polyIndex];
        var length = subpoly.length / 2;

        for (var i = 0, l = length, j = l - 1; i < l; j = i, i++) {
          var sx = subpoly[2 * i],
              sy = subpoly[2 * i + 1],
              tx = subpoly[2 * j],
              ty = subpoly[2 * j + 1]; // 点与多边形顶点重合

          if (sx === px && sy === py || tx === px && ty === py) {
            return 1;
          } // 判断线段两端点是否在射线两侧


          if (sy < py && ty >= py || sy >= py && ty < py) {
            // 线段上与射线 Y 坐标相同的点的 X 坐标
            var x = sx + (py - sy) * (tx - sx) / (ty - sy); // 点在多边形的边上

            if (x === px) {
              return 1;
            }

            if (x > px) {
              flag = !flag;
            }
          }
        }
      }

      return flag ? 1 : 0;
    }
  }, {
    key: "lineIntersects",
    value: function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
      var denominator,
          a,
          b,
          numerator1,
          numerator2,
          onLine1 = false,
          onLine2 = false,
          res = [null, null];
      denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);

      if (denominator === 0) {
        if (res[0] !== null && res[1] !== null) {
          return res;
        } else {
          return false;
        }
      }

      a = line1StartY - line2StartY;
      b = line1StartX - line2StartX;
      numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;
      numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;
      a = numerator1 / denominator;
      b = numerator2 / denominator; // if we cast these lines infinitely in both directions, they intersect here:

      res[0] = line1StartX + a * (line1EndX - line1StartX);
      res[1] = line1StartY + a * (line1EndY - line1StartY); // if line2 is a segment and line1 is infinite, they intersect if:

      if (b > 0 && b < 1) {
        return res;
      } else {
        return false;
      }
    }
    /**
     * 判断两个poly的关系
     * @param polyOut
     * @param polyIn
     * @returns {1,相交，2包涵，3，没关系}
     */

  }, {
    key: "polyWith",
    value: function polyWith(polyOut, polyIn) {
      var lengthOut = polyOut.length / 2;
      var lengthIn = polyIn.length / 2;
      var flag = false;
      var bY;
      var aX;
      var aY;
      var bX;
      var dY;
      var cX;
      var cY;
      var dX;

      for (var i = 0; i < lengthOut; i++) {
        if (i != lengthOut - 1) {
          aX = polyOut[i * 2];
          aY = polyOut[i * 2 + 1];
          bX = polyOut[i * 2 + 2];
          bY = polyOut[i * 2 + 3];
        } else {
          aX = polyOut[i * 2];
          aY = polyOut[i * 2 + 1];
          bX = polyOut[0];
          bY = polyOut[1];
        }

        for (var j = 0; j < lengthIn; j++) {
          if (j != lengthIn - 1) {
            cX = polyIn[j * 2];
            cY = polyIn[j * 2 + 1];
            dX = polyIn[j * 2 + 2];
            dY = polyIn[j * 2 + 3];
          } else {
            cX = polyIn[j * 2];
            cY = polyIn[j * 2 + 1];
            dX = polyIn[0];
            dY = polyIn[1];
          }

          if (GisTools.lineIntersects(aX, aY, bX, bY, cX, cY, dX, dY) != false) {
            return 1;
          }
        }
      }

      var firstX = polyIn[0];
      var firstY = polyIn[1];

      if (GisTools.pointInPolygon(firstX, firstY, polyOut)) {
        return 2;
      }

      return 3;
    }
    /**
     * 把bbox转成double Array
     * @param left
     * @param bottom
     * @param right
     * @param top
     * @returns {Array}
     */

  }, {
    key: "boxToPolyArr",
    value: function boxToPolyArr(left, bottom, right, top) {
      var arr = [];
      arr.push(left);
      arr.push(bottom);
      arr.push(left);
      arr.push(top);
      arr.push(right);
      arr.push(top);
      arr.push(right);
      arr.push(bottom);
      arr.push(left);
      arr.push(bottom);
      return arr;
    }
  }, {
    key: "getExtensionPoint",
    value: function getExtensionPoint(p1, p2, d) {
      var xab = p2[0] - p1[0];
      var yab = p2[1] - p1[1];
      var xd = p2[0];
      var yd = p2[1];

      if (xab == 0) {
        if (yab > 0) {
          yd = p2[1] + d;
        } else {
          yd = p2[1] - d;
        }
      } else {
        var xbd = Math.sqrt(d * d / (yab / xab * (yab / xab) + 1));

        if (xab < 0) {
          xbd = -xbd;
        }

        xd = p2[0] + xbd;
        yd = p2[1] + yab / xab * xbd;
      }

      return [xd, yd];
    }
    /**
     * 线平行偏移
     * @param coords
     * @param distance
     * @returns {Array}
     */

  }, {
    key: "lineOffset",
    value: function lineOffset(coords, distance) {
      var segments = [];
      var finalCoords = [];
      coords.forEach(function (currentCoords, index) {
        if (index !== coords.length - 1) {
          var segment = GisTools.processSegment(currentCoords, coords[index + 1], distance);
          segments.push(segment);

          if (index > 0) {
            var seg2Coords = segments[index - 1];
            var intersects = GisTools.lineIntersects(segment[0][0], segment[0][1], segment[1][0], segment[1][1], seg2Coords[0][0], seg2Coords[0][1], seg2Coords[1][0], seg2Coords[1][1]); // Handling for line segments that aren't straight

            if (intersects !== false) {
              seg2Coords[1] = intersects;
              segment[0] = intersects;
            }

            finalCoords.push(seg2Coords[0]);

            if (index === coords.length - 2) {
              finalCoords.push(segment[0]);
              finalCoords.push(segment[1]);
            }
          } // Handling for lines that only have 1 segment


          if (coords.length === 2) {
            finalCoords.push(segment[0]);
            finalCoords.push(segment[1]);
          }
        }
      });
      return finalCoords;
    }
    /**
     * Process Segment
     * Inspiration taken from http://stackoverflow.com/questions/2825412/draw-a-parallel-line
     *
     * @private
     * @param {Array<number>} point1 Point coordinates
     * @param {Array<number>} point2 Point coordinates
     * @param {number} offset Offset
     * @returns {Array<Array<number>>} offset points
     */

  }, {
    key: "processSegment",
    value: function processSegment(pointAngle1, pointAngle2, offset) {
      var point1 = pointAngle1[0];
      var point2 = pointAngle2[0];
      var L = Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));
      var out1x = point1[0] + offset * (point2[1] - point1[1]) / L;
      var out2x = point2[0] + offset * (point2[1] - point1[1]) / L;
      var out1y = point1[1] + offset * (point1[0] - point2[0]) / L;
      var out2y = point2[1] + offset * (point1[0] - point2[0]) / L;
      return [[[out1x, out1y], pointAngle1[1]], [[out2x, out2y], pointAngle2[1]]];
    }
    /**
     *  判断box1是否在box2内部
     * @param box1
     * @param box2
     */

  }, {
    key: "isInBox",
    value: function isInBox(box1, box2) {
      if (box1[0] >= box2[0] && box1[1] >= box2[1] && box1[2] <= box2[2] && box1[3] <= box2[3]) {
        return true;
      }

      return false;
    }
  }]);

  return GisTools;
}();

/* harmony default export */ __webpack_exports__["a"] = (GisTools);

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ DrawPolyline; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ DrawPolygon; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ DrawRectangle; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ DrawCircle; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ DrawMarker; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ DrawEdit; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* reexport */ MeasurePath; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* reexport */ MeasureArea; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* reexport */ ZoomBox; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ History; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* reexport */ MousePosition; });

// UNUSED EXPORTS: TextMessage, SimpleShape, DrawFeature, DrawTip, drawPolyline, drawPolygon, drawRectangle, drawCircle, drawMarker, drawEdit, measurePath, measureArea, zoomBox, history, mousePosition, Editable, BaseEditor, MarkerEditor, PathEditor, PolylineEditor, PolygonEditor, RectangleEditor, CircleEditor, VertexMarker, PathDraggable

// CONCATENATED MODULE: ./src/control/draw/TextMessage.js
var TextMessage = {
  draw: {
    toolbar: {
      actions: {
        title: '取消绘制',
        text: '取消'
      },
      finish: {
        title: '完成绘制',
        text: '完成'
      },
      undo: {
        title: '清除最后一个绘制点',
        text: '清除最后一个点'
      },
      buttons: {
        polyline: '绘制折线',
        polygon: '绘制多边形',
        rectangle: '绘制矩形',
        circle: '绘制圆形',
        marker: '绘制标注'
      }
    },
    handlers: {
      circle: {
        tooltip: {
          start: '点击并且拖动绘制圆形'
        },
        radius: '半径'
      },
      marker: {
        tooltip: {
          start: '点击地图放置标记'
        }
      },
      polygon: {
        tooltip: {
          start: '点击开始绘制面',
          cont: '点击继续绘制面',
          end: '点击起点或双击结束绘制'
        }
      },
      polyline: {
        error: '<strong>错误:</strong> 形状边缘不能交叉!',
        tooltip: {
          start: '点击开始绘制线',
          cont: '点击继续绘制线',
          end: '点击最后一个点或双击结束绘制'
        }
      },
      rectangle: {
        tooltip: {
          start: '点击并且拖动绘制矩形'
        }
      },
      simpleshape: {
        tooltip: {
          end: '松开鼠标完成绘制'
        }
      }
    }
  },
  edit: {
    toolbar: {
      actions: {
        save: {
          title: '保存编辑',
          text: '保存'
        },
        cancel: {
          title: '取消编辑',
          text: '取消'
        }
      },
      buttons: {
        edit: '编辑图层',
        editDisabled: '没有可编辑的图层',
        remove: '删除图层',
        removeDisabled: '没有可删除的图层'
      }
    },
    handlers: {
      edit: {
        tooltip: {
          text: '拖动编辑要素',
          subtext: ''
        }
      },
      remove: {
        tooltip: {
          text: '点击一个要素删除它'
        }
      }
    }
  }
};
/* harmony default export */ var draw_TextMessage = (TextMessage);
// EXTERNAL MODULE: external "L"
var external_L_ = __webpack_require__(0);
var external_L_default = /*#__PURE__*/__webpack_require__.n(external_L_);

// CONCATENATED MODULE: ./src/control/draw/DrawTip.js

var DrawTip = external_L_default.a.Class.extend({
  initialize: function initialize(map) {
    this._map = map;
    this._popupPane = map._panes.popupPane;
    this._container = map.options.drawControlTooltips ? external_L_default.a.DomUtil.create('div', 'leaflet-draw-tooltip', this._popupPane) : null;
    this._singleLineLabel = false;

    this._map.on('mouseout', this._onMouseOut, this);
  },
  dispose: function dispose() {
    this._map.off('mouseout', this._onMouseOut, this);

    if (this._container) {
      this._popupPane.removeChild(this._container);

      this._container = null;
    }
  },
  updateContent: function updateContent(labelText) {
    if (!this._container) {
      return this;
    }

    labelText.subtext = labelText.subtext || ''; // update the vertical position (only if changed)

    if (labelText.subtext.length === 0 && !this._singleLineLabel) {
      external_L_default.a.DomUtil.addClass(this._container, 'leaflet-draw-tooltip-single');
      this._singleLineLabel = true;
    } else if (labelText.subtext.length > 0 && this._singleLineLabel) {
      external_L_default.a.DomUtil.removeClass(this._container, 'leaflet-draw-tooltip-single');
      this._singleLineLabel = false;
    }

    this._container.innerHTML = (labelText.subtext.length > 0 ? '<span class="leaflet-draw-tooltip-subtext">' + labelText.subtext + '</span>' + '<br />' : '') + '<span>' + labelText.text + '</span>';
    return this;
  },
  updatePosition: function updatePosition(latlng) {
    var pos = this._map.latLngToLayerPoint(latlng),
        tooltipContainer = this._container;

    if (this._container) {
      tooltipContainer.style.visibility = 'inherit';
      external_L_default.a.DomUtil.setPosition(tooltipContainer, pos);
    }

    return this;
  },
  showAsError: function showAsError() {
    if (this._container) {
      external_L_default.a.DomUtil.addClass(this._container, 'leaflet-error-draw-tooltip');
    }

    return this;
  },
  removeError: function removeError() {
    if (this._container) {
      external_L_default.a.DomUtil.removeClass(this._container, 'leaflet-error-draw-tooltip');
    }

    return this;
  },
  _onMouseOut: function _onMouseOut() {
    if (this._container) {
      this._container.style.visibility = 'hidden';
    }
  }
});
external_L_default.a.Map.mergeOptions({
  drawControlTooltips: true
});
/* harmony default export */ var draw_DrawTip = (DrawTip);
// EXTERNAL MODULE: ./src/core/Base.js
var Base = __webpack_require__(1);

// CONCATENATED MODULE: ./src/control/draw/DrawFeature.js



var DrawFeature = external_L_default.a.Handler.extend({
  includes: external_L_default.a.Evented.prototype,
  initialize: function initialize(map, options) {
    this._map = map;
    this._container = map._container;
    this._overlayPane = map._panes.overlayPane;
    this._popupPane = map._panes.popupPane; // Merge default shapeOptions options with custom shapeOptions

    if (options && options.shapeOptions) {
      options.shapeOptions = external_L_default.a.Util.extend({}, this.options.shapeOptions, options.shapeOptions);
    }

    external_L_default.a.setOptions(this, options);
  },

  /**
   * 控件激活
   * @method L.Draw.Feature#enable
   */
  enable: function enable() {
    if (this._enabled) {
      return;
    }

    external_L_default.a.Handler.prototype.enable.call(this);
    this.fire('enabled', {
      handler: this.type
    });

    this._map.fire('draw:drawstart', {
      layerType: this.type
    });
  },

  /**
   * 控件注销
   * @method L.Draw.Feature#disable
   */
  disable: function disable() {
    if (!this._enabled) {
      return;
    }

    external_L_default.a.Handler.prototype.disable.call(this);

    this._map.fire('draw:drawstop', {
      layerType: this.type
    });

    this.fire('disabled', {
      handler: this.type
    });
  },
  addHooks: function addHooks() {
    var map = this._map;

    if (map) {
      external_L_default.a.DomUtil.disableTextSelection();
      map.getContainer().focus();
      this._tooltip = new draw_DrawTip(this._map);
      external_L_default.a.DomEvent.on(this._container, 'keyup', this._cancelDrawing, this);
    }
  },
  removeHooks: function removeHooks() {
    if (this._map) {
      external_L_default.a.DomUtil.enableTextSelection();

      this._tooltip.dispose();

      this._tooltip = null;
      external_L_default.a.DomEvent.off(this._container, 'keyup', this._cancelDrawing, this);
    }
  },
  setOptions: function setOptions(options) {
    external_L_default.a.setOptions(this, options);
  },
  _fireCreatedEvent: function _fireCreatedEvent(layer) {
    this._map.fire('draw:created', {
      layer: layer,
      layerType: this.type
    });
  },
  // Cancel drawing when the escape key is pressed
  _cancelDrawing: function _cancelDrawing(e) {
    this._map.fire('draw:canceled', {
      layerType: this.type
    });

    if (e.keyCode === 27) {
      this.disable();
    }
  }
});
/* harmony default export */ var draw_DrawFeature = (DrawFeature);
// EXTERNAL MODULE: ./src/util/Util.js
var Util = __webpack_require__(10);

// CONCATENATED MODULE: ./src/control/draw/DrawPolyline.js





var DrawPolyline = draw_DrawFeature.extend({
  statics: {
    TYPE: 'polyline'
  },
  Poly: external_L_default.a.Polyline,
  options: {
    allowIntersection: true,
    repeatMode: false,
    drawError: {
      color: '#b00b00',
      timeout: 2500
    },
    icon: new external_L_default.a.DivIcon({
      iconSize: new external_L_default.a.Point(8, 8),
      className: 'leaflet-div-icon leaflet-editing-icon'
    }),
    touchIcon: new external_L_default.a.DivIcon({
      iconSize: new external_L_default.a.Point(8, 8),
      className: 'leaflet-div-icon leaflet-editing-icon leaflet-touch-icon'
    }),
    guidelineDistance: 20,
    maxGuideLineLength: 4000,
    shapeOptions: {
      stroke: true,
      color: '#f06eaa',
      weight: 4,
      opacity: 0.5,
      fill: false,
      clickable: true
    },
    metric: true,
    // Whether to use the metric measurement system or imperial
    feet: true,
    // When not metric, to use feet instead of yards for display.
    showLength: true,
    // Whether to display distance in the tooltip
    zIndexOffset: 2000 // This should be > than the highest z-index any map layers

  },
  initialize: function initialize(map, options) {
    // if touch, switch to touch icon
    if (external_L_default.a.Browser.touch) {
      this.options.icon = this.options.touchIcon;
    } // Need to set this here to ensure the correct message is used.


    this.options.drawError.message = draw_TextMessage.draw.handlers.polyline.error; // Merge default drawError options with custom options

    if (options && options.drawError) {
      options.drawError = external_L_default.a.Util.extend({}, this.options.drawError, options.drawError);
    } // Save the type so super can fire, need to do this as cannot do this.TYPE :(


    this.type = DrawPolyline.TYPE;
    draw_DrawFeature.prototype.initialize.call(this, map, options);
  },
  addHooks: function addHooks() {
    draw_DrawFeature.prototype.addHooks.call(this);

    if (this._map) {
      this._markers = [];
      this._markerGroup = new external_L_default.a.LayerGroup();

      this._map.addLayer(this._markerGroup);

      this._poly = new external_L_default.a.Polyline([], this.options.shapeOptions);

      this._tooltip.updateContent(this._getTooltipText()); // Make a transparent marker that will used to catch click events. These click
      // events will create the vertices. We need to do this so we can ensure that
      // we can create vertices over other map layers (markers, vector layers). We
      // also do not want to trigger any click handlers of objects we are clicking on
      // while drawing.


      if (!this._mouseMarker) {
        this._mouseMarker = external_L_default.a.marker(this._map.getCenter(), {
          icon: external_L_default.a.divIcon({
            className: 'leaflet-mouse-marker',
            iconAnchor: [20, 20],
            iconSize: [40, 40]
          }),
          opacity: 0,
          zIndexOffset: this.options.zIndexOffset
        });
      }

      if (!external_L_default.a.Browser.touch) {
        this._map.on('mouseup', this._onMouseUp, this); // Necessary for 0.7 compatibility

      }

      this._mouseMarker.on('mousedown', this._onMouseDown, this).on('mouseout', this._onMouseOut, this).on('mouseup', this._onMouseUp, this) // Necessary for 0.8 compatibility
      .on('mousemove', this._onMouseMove, this) // Necessary to prevent 0.8 stutter
      .addTo(this._map);

      this._map.on('mouseup', this._onMouseUp, this) // Necessary for 0.7 compatibility
      .on('mousemove', this._onMouseMove, this).on('zoomlevelschange', this._onZoomEnd, this).on('click', this._onTouch, this).on('zoomend', this._onZoomEnd, this);
    }
  },
  removeHooks: function removeHooks() {
    draw_DrawFeature.prototype.removeHooks.call(this);

    this._clearHideErrorTimeout();

    this._cleanUpShape(); // remove markers from map


    this._map.removeLayer(this._markerGroup);

    delete this._markerGroup;
    delete this._markers;

    this._map.removeLayer(this._poly);

    delete this._poly;

    this._mouseMarker.off('mousedown', this._onMouseDown, this).off('mouseout', this._onMouseOut, this).off('mouseup', this._onMouseUp, this).off('mousemove', this._onMouseMove, this);

    this._map.removeLayer(this._mouseMarker);

    delete this._mouseMarker; // clean up DOM

    this._clearGuides();

    this._map.off('mouseup', this._onMouseUp, this).off('mousemove', this._onMouseMove, this).off('zoomlevelschange', this._onZoomEnd, this).off('zoomend', this._onZoomEnd, this).off('click', this._onTouch, this);
  },
  deleteLastVertex: function deleteLastVertex() {
    if (this._markers.length <= 1) {
      return;
    }

    var lastMarker = this._markers.pop(),
        poly = this._poly,
        latlng = this._poly.spliceLatLngs(poly.getLatLngs().length - 1, 1)[0];

    this._markerGroup.removeLayer(lastMarker);

    if (poly.getLatLngs().length < 2) {
      this._map.removeLayer(poly);
    }

    this._vertexChanged(latlng, false);
  },
  addVertex: function addVertex(latlng) {
    var markersLength = this._markers.length;

    if (markersLength > 0 && !this.options.allowIntersection && this._poly.newLatLngIntersects(latlng)) {
      this._showErrorTooltip();

      return false;
    } else if (this._errorShown) {
      this._hideErrorTooltip();
    }

    this._markers.push(this._createMarker(latlng));

    this._poly.addLatLng(latlng);

    if (this._poly.getLatLngs().length === 2) {
      this._map.addLayer(this._poly);
    }

    this._vertexChanged(latlng, true);
  },
  completeShape: function completeShape() {
    if (this._markers.length <= 1) {
      return;
    }

    this._fireCreatedEvent();

    this.disable();

    if (this.options.repeatMode) {
      this.enable();
    }
  },
  _finishShape: function _finishShape() {
    var intersects = this._poly.newLatLngIntersects(this._poly.getLatLngs()[this._poly.getLatLngs().length - 1]);

    if (!this.options.allowIntersection && intersects || !this._shapeIsValid()) {
      this._showErrorTooltip();

      return;
    }

    this._fireCreatedEvent();

    this.disable();

    if (this.options.repeatMode) {
      this.enable();
    }
  },
  //Called to verify the shape is valid when the user tries to finish it
  //Return false if the shape is not valid
  _shapeIsValid: function _shapeIsValid() {
    return true;
  },
  _onZoomEnd: function _onZoomEnd() {
    if (this._markers !== null) {
      this._updateGuide();
    }
  },
  _onMouseMove: function _onMouseMove(e) {
    var newPos = this._map.mouseEventToLayerPoint(e.originalEvent);

    var latlng = this._map.layerPointToLatLng(newPos); // Save latlng
    // should this be moved to _updateGuide() ?


    this._currentLatLng = latlng;

    this._updateTooltip(latlng); // Update the guide line


    this._updateGuide(newPos); // Update the mouse marker position


    this._mouseMarker.setLatLng(latlng);

    external_L_default.a.DomEvent.preventDefault(e.originalEvent);
  },
  _vertexChanged: function _vertexChanged(latlng, added) {
    this._map.fire('draw:drawvertex', {
      layers: this._markerGroup
    });

    this._updateFinishHandler();

    this._updateRunningMeasure(latlng, added);

    this._clearGuides();

    this._updateTooltip();
  },
  _onMouseDown: function _onMouseDown(e) {
    var originalEvent = e.originalEvent;
    this._mouseDownOrigin = external_L_default.a.point(originalEvent.clientX, originalEvent.clientY);
  },
  _onMouseUp: function _onMouseUp(e) {
    if (this._mouseDownOrigin) {
      // We detect clicks within a certain tolerance, otherwise let it
      // be interpreted as a drag by the map
      var distance = external_L_default.a.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(this._mouseDownOrigin);

      if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) {
        this.addVertex(e.latlng);
      }
    }

    this._mouseDownOrigin = null;
  },
  _onTouch: function _onTouch(e) {// if (L.Browser.touch) {
    //     this._onMouseDown(e);
    //     this._onMouseUp(e);
    // }
  },
  _onMouseOut: function _onMouseOut() {
    if (this._tooltip) {
      this._tooltip._onMouseOut.call(this._tooltip);
    }
  },
  _updateFinishHandler: function _updateFinishHandler() {
    var markerCount = this._markers.length; // The last marker should have a click handler to close the polyline

    if (markerCount > 1) {
      this._markers[markerCount - 1].on('click', this._finishShape, this);
    } // Remove the old marker click handler (as only the last point should close the polyline)


    if (markerCount > 2) {
      this._markers[markerCount - 2].off('click', this._finishShape, this);
    }
  },
  _createMarker: function _createMarker(latlng) {
    var marker = new external_L_default.a.Marker(latlng, {
      icon: this.options.icon,
      zIndexOffset: this.options.zIndexOffset * 2
    });

    this._markerGroup.addLayer(marker);

    return marker;
  },
  _updateGuide: function _updateGuide(newPos) {
    var markerCount = this._markers ? this._markers.length : 0;

    if (markerCount > 0) {
      newPos = newPos || this._map.latLngToLayerPoint(this._currentLatLng); // draw the guide line

      this._clearGuides();

      this._drawGuide(this._map.latLngToLayerPoint(this._markers[markerCount - 1].getLatLng()), newPos);
    }
  },
  _updateTooltip: function _updateTooltip(latLng) {
    var text = this._getTooltipText();

    if (latLng) {
      this._tooltip.updatePosition(latLng);
    }

    if (!this._errorShown) {
      this._tooltip.updateContent(text);
    }
  },
  _drawGuide: function _drawGuide(pointA, pointB) {
    var length = Math.floor(Math.sqrt(Math.pow(pointB.x - pointA.x, 2) + Math.pow(pointB.y - pointA.y, 2))),
        guidelineDistance = this.options.guidelineDistance,
        maxGuideLineLength = this.options.maxGuideLineLength,
        // Only draw a guideline with a max length
    i = length > maxGuideLineLength ? length - maxGuideLineLength : guidelineDistance,
        fraction,
        dashPoint,
        dash; //create the guides container if we haven't yet

    if (!this._guidesContainer) {
      this._guidesContainer = external_L_default.a.DomUtil.create('div', 'leaflet-draw-guides', this._overlayPane);
    } //draw a dash every GuildeLineDistance


    for (; i < length; i += this.options.guidelineDistance) {
      //work out fraction along line we are
      fraction = i / length; //calculate new x,y point

      dashPoint = {
        x: Math.floor(pointA.x * (1 - fraction) + fraction * pointB.x),
        y: Math.floor(pointA.y * (1 - fraction) + fraction * pointB.y)
      }; //add guide dash to guide container

      dash = external_L_default.a.DomUtil.create('div', 'leaflet-draw-guide-dash', this._guidesContainer);
      dash.style.backgroundColor = !this._errorShown ? this.options.shapeOptions.color : this.options.drawError.color;
      external_L_default.a.DomUtil.setPosition(dash, dashPoint);
    }
  },
  _updateGuideColor: function _updateGuideColor(color) {
    if (this._guidesContainer) {
      for (var i = 0, l = this._guidesContainer.childNodes.length; i < l; i++) {
        this._guidesContainer.childNodes[i].style.backgroundColor = color;
      }
    }
  },
  // removes all child elements (guide dashes) from the guides container
  _clearGuides: function _clearGuides() {
    if (this._guidesContainer) {
      while (this._guidesContainer.firstChild) {
        this._guidesContainer.removeChild(this._guidesContainer.firstChild);
      }
    }
  },
  _getTooltipText: function _getTooltipText() {
    var showLength = this.options.showLength,
        labelText,
        distanceStr;

    if (this._markers.length === 0) {
      labelText = {
        text: draw_TextMessage.draw.handlers.polyline.tooltip.start
      };
    } else {
      distanceStr = showLength ? this._getMeasurementString() : '';

      if (this._markers.length === 1) {
        labelText = {
          text: draw_TextMessage.draw.handlers.polyline.tooltip.cont,
          subtext: distanceStr
        };
      } else {
        labelText = {
          text: draw_TextMessage.draw.handlers.polyline.tooltip.end,
          subtext: distanceStr
        };
      }
    }

    return labelText;
  },
  _updateRunningMeasure: function _updateRunningMeasure(latlng, added) {
    var markersLength = this._markers.length,
        previousMarkerIndex,
        distance;

    if (this._markers.length === 1) {
      this._measurementRunningTotal = 0;
    } else {
      previousMarkerIndex = markersLength - (added ? 2 : 1);
      distance = latlng.distanceTo(this._markers[previousMarkerIndex].getLatLng());
      this._measurementRunningTotal += distance * (added ? 1 : -1);
    }
  },
  _getMeasurementString: function _getMeasurementString() {
    var currentLatLng = this._currentLatLng,
        previousLatLng = this._markers[this._markers.length - 1].getLatLng(),
        distance; // calculate the distance from the last fixed point to the mouse position


    distance = this._measurementRunningTotal + currentLatLng.distanceTo(previousLatLng);
    return external_L_default.a.Util.readableDistance(distance, this.options.metric, this.options.feet);
  },
  _showErrorTooltip: function _showErrorTooltip() {
    this._errorShown = true; // Update tooltip

    this._tooltip.showAsError().updateContent({
      text: this.options.drawError.message
    }); // Update shape


    this._updateGuideColor(this.options.drawError.color);

    this._poly.setStyle({
      color: this.options.drawError.color
    }); // Hide the error after 2 seconds


    this._clearHideErrorTimeout();

    this._hideErrorTimeout = setTimeout(external_L_default.a.Util.bind(this._hideErrorTooltip, this), this.options.drawError.timeout);
  },
  _hideErrorTooltip: function _hideErrorTooltip() {
    this._errorShown = false;

    this._clearHideErrorTimeout(); // Revert tooltip


    this._tooltip.removeError().updateContent(this._getTooltipText()); // Revert shape


    this._updateGuideColor(this.options.shapeOptions.color);

    this._poly.setStyle({
      color: this.options.shapeOptions.color
    });
  },
  _clearHideErrorTimeout: function _clearHideErrorTimeout() {
    if (this._hideErrorTimeout) {
      clearTimeout(this._hideErrorTimeout);
      this._hideErrorTimeout = null;
    }
  },
  _cleanUpShape: function _cleanUpShape() {
    if (this._markers.length > 1) {
      this._markers[this._markers.length - 1].off('click', this._finishShape, this);
    }
  },
  _fireCreatedEvent: function _fireCreatedEvent() {
    var poly = new this.Poly(this._poly.getLatLngs(), this.options.shapeOptions);

    draw_DrawFeature.prototype._fireCreatedEvent.call(this, poly);
  }
});
var drawPolyline = function drawPolyline(map, options) {
  return new DrawPolyline(map, options);
};
external_L_default.a.geoway.control.drawPolyline = drawPolyline;
external_L_default.a.geoway.control.DrawPolyline = DrawPolyline;
external_L_default.a.Draw = external_L_default.a.Draw ? external_L_default.a.Draw : {};
external_L_default.a.Draw.Polyline = DrawPolyline;
// CONCATENATED MODULE: ./src/control/draw/DrawPolygon.js





var DrawPolygon = DrawPolyline.extend({
  statics: {
    TYPE: 'polygon'
  },
  Poly: external_L_default.a.Polygon,
  options: {
    showArea: false,
    shapeOptions: {
      stroke: true,
      color: '#f06eaa',
      weight: 4,
      opacity: 0.5,
      fill: true,
      fillColor: null,
      //same as color by default
      fillOpacity: 0.2,
      clickable: true
    },
    metric: true // Whether to use the metric measurement system or imperial

  },
  initialize: function initialize(map, options) {
    this.type = DrawPolygon.TYPE;
    DrawPolyline.prototype.initialize.call(this, map, options);
  },
  _updateFinishHandler: function _updateFinishHandler() {
    var markerCount = this._markers.length; // The first marker should have a click handler to close the polygon

    if (markerCount === 1) {
      this._markers[0].on('click', this._finishShape, this);
    } // Add and update the double click handler


    if (markerCount > 2) {
      this._markers[markerCount - 1].on('dblclick', this._finishShape, this); // Only need to remove handler if has been added before


      if (markerCount > 3) {
        this._markers[markerCount - 2].off('dblclick', this._finishShape, this);
      }
    }
  },
  _getTooltipText: function _getTooltipText() {
    var text, subtext;

    if (this._markers.length === 0) {
      text = draw_TextMessage.draw.handlers.polygon.tooltip.start;
    } else if (this._markers.length < 3) {
      text = draw_TextMessage.draw.handlers.polygon.tooltip.cont;
    } else {
      text = draw_TextMessage.draw.handlers.polygon.tooltip.end;
      subtext = this._getMeasurementString();
    }

    return {
      text: text,
      subtext: subtext
    };
  },
  _getMeasurementString: function _getMeasurementString() {
    var area = this._area;

    if (!area) {
      return null;
    }

    return external_L_default.a.Util.readableArea(area, this.options.metric);
  },
  _shapeIsValid: function _shapeIsValid() {
    return this._markers.length >= 3;
  },
  _vertexChanged: function _vertexChanged(latlng, added) {
    var latLngs; // Check to see if we should show the area

    if (!this.options.allowIntersection && this.options.showArea) {
      latLngs = this._poly.getLatLngs();
      this._area = external_L_default.a.Util.geodesicArea(latLngs);
    }

    DrawPolyline.prototype._vertexChanged.call(this, latlng, added);
  },
  _cleanUpShape: function _cleanUpShape() {
    var markerCount = this._markers.length;

    if (markerCount > 0) {
      this._markers[0].off('click', this._finishShape, this);

      if (markerCount > 2) {
        this._markers[markerCount - 1].off('dblclick', this._finishShape, this);
      }
    }
  }
});
var drawPolygon = function drawPolygon(map, options) {
  return new DrawPolygon(map, options);
};
external_L_default.a.geoway.control.drawPolygon = drawPolygon;
external_L_default.a.geoway.control.DrawPolygon = DrawPolygon;
external_L_default.a.Draw = external_L_default.a.Draw ? external_L_default.a.Draw : {};
external_L_default.a.Draw.Polygon = DrawPolygon;
// CONCATENATED MODULE: ./src/control/draw/SimpleShape.js



var SimpleShape = draw_DrawFeature.extend({
  options: {
    repeatMode: false
  },
  initialize: function initialize(map, options) {
    this._endLabelText = draw_TextMessage.draw.handlers.simpleshape.tooltip.end;
    draw_DrawFeature.prototype.initialize.call(this, map, options);
  },
  addHooks: function addHooks() {
    draw_DrawFeature.prototype.addHooks.call(this);

    if (this._map) {
      this._mapDraggable = this._map.dragging.enabled();

      if (this._mapDraggable) {
        this._map.dragging.disable();
      }

      this._container.style.cursor = 'crosshair';

      this._tooltip.updateContent({
        text: this._initialLabelText
      });

      this._map.on('mousedown', this._onMouseDown, this).on('mousemove', this._onMouseMove, this).on('touchstart', this._onMouseDown, this).on('touchmove', this._onMouseMove, this);
    }
  },
  removeHooks: function removeHooks() {
    draw_DrawFeature.prototype.removeHooks.call(this);

    if (this._map) {
      if (this._mapDraggable) {
        this._map.dragging.enable();
      }

      this._container.style.cursor = '';

      this._map.off('mousedown', this._onMouseDown, this).off('mousemove', this._onMouseMove, this).off('touchstart', this._onMouseDown, this).off('touchmove', this._onMouseMove, this);

      external_L_default.a.DomEvent.off(document, 'mouseup', this._onMouseUp, this);
      external_L_default.a.DomEvent.off(document, 'touchend', this._onMouseUp, this); // If the box element doesn't exist they must not have moved the mouse, so don't need to destroy/return

      if (this._shape) {
        this._map.removeLayer(this._shape);

        delete this._shape;
      }
    }

    this._isDrawing = false;
  },
  _getTooltipText: function _getTooltipText() {
    return {
      text: this._endLabelText
    };
  },
  _onMouseDown: function _onMouseDown(e) {
    this._isDrawing = true;
    this._startLatLng = e.latlng;
    external_L_default.a.DomEvent.on(document, 'mouseup', this._onMouseUp, this).on(document, 'touchend', this._onMouseUp, this).preventDefault(e.originalEvent);
  },
  _onMouseMove: function _onMouseMove(e) {
    var latlng = e.latlng;

    this._tooltip.updatePosition(latlng);

    if (this._isDrawing) {
      this._tooltip.updateContent(this._getTooltipText());

      this._drawShape(latlng);
    }
  },
  _onMouseUp: function _onMouseUp() {
    if (this._shape) {
      this._fireCreatedEvent();
    }

    this.disable();

    if (this.options.repeatMode) {
      this.enable();
    }
  }
});
/* harmony default export */ var draw_SimpleShape = (SimpleShape);
// CONCATENATED MODULE: ./src/control/draw/DrawRectangle.js





var DrawRectangle = draw_SimpleShape.extend({
  statics: {
    TYPE: 'rectangle'
  },
  options: {
    shapeOptions: {
      stroke: true,
      color: '#f06eaa',
      weight: 4,
      opacity: 0.5,
      fill: true,
      fillColor: null,
      //same as color by default
      fillOpacity: 0.2,
      clickable: true
    },
    metric: true // Whether to use the metric measurement system or imperial

  },
  initialize: function initialize(map, options) {
    // Save the type so super can fire, need to do this as cannot do this.TYPE :(
    this.type = DrawRectangle.TYPE;
    this._initialLabelText = draw_TextMessage.draw.handlers.rectangle.tooltip.start;
    draw_SimpleShape.prototype.initialize.call(this, map, options);
  },
  _drawShape: function _drawShape(latlng) {
    if (!this._shape) {
      this._shape = new external_L_default.a.Rectangle(new external_L_default.a.LatLngBounds(this._startLatLng, latlng), this.options.shapeOptions);

      this._map.addLayer(this._shape);
    } else {
      this._shape.setBounds(new external_L_default.a.LatLngBounds(this._startLatLng, latlng));
    }
  },
  _fireCreatedEvent: function _fireCreatedEvent() {
    var rectangle = new external_L_default.a.Rectangle(this._shape.getBounds(), this.options.shapeOptions);

    draw_SimpleShape.prototype._fireCreatedEvent.call(this, rectangle);
  },
  _getTooltipText: function _getTooltipText() {
    var tooltipText = draw_SimpleShape.prototype._getTooltipText.call(this),
        shape = this._shape,
        latLngs,
        area,
        subtext;

    if (shape) {
      latLngs = this._shape.getLatLngs();
      area = external_L_default.a.Util.geodesicArea(latLngs);
      subtext = external_L_default.a.Util.readableArea(area, this.options.metric);
    }

    return {
      text: tooltipText.text,
      subtext: subtext
    };
  }
});
var drawRectangle = function drawRectangle(map, options) {
  return new DrawRectangle(map, options);
};
external_L_default.a.geoway.control.drawRectangle = drawRectangle;
external_L_default.a.geoway.control.DrawRectangle = DrawRectangle;
external_L_default.a.Draw = external_L_default.a.Draw ? external_L_default.a.Draw : {};
external_L_default.a.Draw.Rectangle = DrawRectangle;
// CONCATENATED MODULE: ./src/control/draw/DrawCircle.js





var DrawCircle = draw_SimpleShape.extend({
  statics: {
    TYPE: 'circle'
  },
  options: {
    shapeOptions: {
      stroke: true,
      color: '#f06eaa',
      weight: 4,
      opacity: 0.5,
      fill: true,
      fillColor: null,
      //same as color by default
      fillOpacity: 0.2,
      clickable: true
    },
    showRadius: true,
    metric: true,
    // Whether to use the metric measurement system or imperial
    feet: true // When not metric, use feet instead of yards for display

  },
  initialize: function initialize(map, options) {
    // Save the type so super can fire, need to do this as cannot do this.TYPE :(
    this.type = DrawCircle.TYPE;
    this._initialLabelText = draw_TextMessage.draw.handlers.circle.tooltip.start;
    draw_SimpleShape.prototype.initialize.call(this, map, options);
  },
  _drawShape: function _drawShape(latlng) {
    if (!this._shape) {
      this._shape = new external_L_default.a.Circle(this._startLatLng, this._startLatLng.distanceTo(latlng), this.options.shapeOptions);

      this._map.addLayer(this._shape);
    } else {
      this._shape.setRadius(this._startLatLng.distanceTo(latlng));
    }
  },
  _fireCreatedEvent: function _fireCreatedEvent() {
    var circle = new external_L_default.a.Circle(this._startLatLng, this._shape.getRadius(), this.options.shapeOptions);

    draw_SimpleShape.prototype._fireCreatedEvent.call(this, circle);
  },
  _onMouseMove: function _onMouseMove(e) {
    var latlng = e.latlng,
        showRadius = this.options.showRadius,
        useMetric = this.options.metric,
        radius;

    this._tooltip.updatePosition(latlng);

    if (this._isDrawing) {
      this._drawShape(latlng); // Get the new radius (rounded to 1 dp)


      radius = this._shape.getRadius().toFixed(1);

      this._tooltip.updateContent({
        text: this._endLabelText,
        subtext: showRadius ? draw_TextMessage.draw.handlers.circle.radius + ': ' + external_L_default.a.Util.readableDistance(radius, useMetric, this.options.feet) : ''
      });
    }
  }
});
var drawCircle = function drawCircle(map, options) {
  return new DrawCircle(map, options);
};
external_L_default.a.geoway.control.drawCircle = drawCircle;
external_L_default.a.geoway.control.DrawCircle = DrawCircle;
external_L_default.a.Draw = external_L_default.a.Draw ? external_L_default.a.Draw : {};
external_L_default.a.Draw.Circle = DrawCircle;
// CONCATENATED MODULE: ./src/control/draw/DrawMarker.js




var DrawMarker = draw_DrawFeature.extend({
  statics: {
    TYPE: 'marker'
  },
  options: {
    icon: new external_L_default.a.Icon.Default(),
    repeatMode: false,
    zIndexOffset: 2000 // This should be > than the highest z-index any markers

  },
  initialize: function initialize(map, options) {
    // Save the type so super can fire, need to do this as cannot do this.TYPE :(
    this.type = DrawMarker.TYPE;
    draw_DrawFeature.prototype.initialize.call(this, map, options);
  },
  addHooks: function addHooks() {
    draw_DrawFeature.prototype.addHooks.call(this);

    if (this._map) {
      this._tooltip.updateContent({
        text: draw_TextMessage.draw.handlers.marker.tooltip.start
      }); // Same mouseMarker as in Draw.Polyline


      if (!this._mouseMarker) {
        this._mouseMarker = external_L_default.a.marker(this._map.getCenter(), {
          icon: external_L_default.a.divIcon({
            className: 'leaflet-mouse-marker',
            iconAnchor: [20, 20],
            iconSize: [40, 40]
          }),
          opacity: 0,
          zIndexOffset: this.options.zIndexOffset
        });
      }

      this._mouseMarker.on('click', this._onClick, this).addTo(this._map);

      this._map.on('mousemove', this._onMouseMove, this);

      this._map.on('click', this._onTouch, this);
    }
  },
  removeHooks: function removeHooks() {
    draw_DrawFeature.prototype.removeHooks.call(this);

    if (this._map) {
      if (this._marker) {
        this._marker.off('click', this._onClick, this);

        this._map.off('click', this._onClick, this).off('click', this._onTouch, this).removeLayer(this._marker);

        delete this._marker;
      }

      this._mouseMarker.off('click', this._onClick, this);

      this._map.removeLayer(this._mouseMarker);

      delete this._mouseMarker;

      this._map.off('mousemove', this._onMouseMove, this);
    }
  },
  _onMouseMove: function _onMouseMove(e) {
    var latlng = e.latlng;

    this._tooltip.updatePosition(latlng);

    this._mouseMarker.setLatLng(latlng);

    if (!this._marker) {
      this._marker = new external_L_default.a.Marker(latlng, {
        icon: this.options.icon,
        zIndexOffset: this.options.zIndexOffset
      }); // Bind to both marker and map to make sure we get the click event.

      this._marker.on('click', this._onClick, this);

      this._map.on('click', this._onClick, this).addLayer(this._marker);
    } else {
      latlng = this._mouseMarker.getLatLng();

      this._marker.setLatLng(latlng);
    }
  },
  _onClick: function _onClick() {
    this._fireCreatedEvent();

    this.disable();

    if (this.options.repeatMode) {
      this.enable();
    }
  },
  _onTouch: function _onTouch(e) {
    // called on click & tap, only really does any thing on tap
    this._onMouseMove(e); // creates & places marker


    this._onClick(); // permanently places marker & ends interaction

  },
  _fireCreatedEvent: function _fireCreatedEvent() {
    var marker = new external_L_default.a.Marker(this._marker.getLatLng(), {
      icon: this.options.icon
    });

    draw_DrawFeature.prototype._fireCreatedEvent.call(this, marker);
  }
});
var drawMarker = function drawMarker(map, options) {
  return new DrawMarker(map, options);
};
external_L_default.a.geoway.control.drawMarker = drawMarker;
external_L_default.a.geoway.control.DrawMarker = DrawMarker;
external_L_default.a.Draw = external_L_default.a.Draw ? external_L_default.a.Draw : {};
external_L_default.a.Draw.Marker = DrawMarker;
// CONCATENATED MODULE: ./src/control/draw/edit/DrawEdit.js
/**
 * @class
 * @classdesc 要素编辑器控件
 * @alias EditTool
 * @param {L.Map} map - 地图对象
 * @param {object} options
 * @property {object}  options
 * @property {object}  options.featureGroup	- 指定可编辑的图层
 * @example
 * var edit = new EditTool(map);
 * edit.enable();   //激活控件
 * edit.disable();  //注销控件
 * @extends L.Handler
 */




var DrawEdit = external_L_default.a.Handler.extend({
  statics: {
    TYPE: 'edit'
  },
  includes: external_L_default.a.Evented.prototype,
  initialize: function initialize(map, options) {
    external_L_default.a.Handler.prototype.initialize.call(this, map);
    external_L_default.a.setOptions(this, options); // Store the selectable layer group for ease of access

    this._featureGroup = options.featureGroup;

    if (!(this._featureGroup instanceof external_L_default.a.FeatureGroup)) {
      throw new Error('options.featureGroup must be a L.FeatureGroup');
    }

    this._uneditedLayerProps = {}; // Save the type so super can fire, need to do this as cannot do this.TYPE :(

    this.type = DrawEdit.TYPE;
  },

  /**
   * 控件激活
   * @method EditTool#enable
   */
  enable: function enable() {
    if (this._enabled || !this._hasAvailableLayers()) {
      return;
    }

    this.fire('enabled', {
      handler: this.type
    }); //this disable other handlers

    this._map.fire('draw:editstart', {
      handler: this.type
    }); //allow drawLayer to be updated before beginning edition.


    external_L_default.a.Handler.prototype.enable.call(this);

    this._featureGroup.on('layeradd', this._enableLayerEdit, this).on('layerremove', this._disableLayerEdit, this);
  },

  /**
   * 控件注销
   * @method EditTool#disable
   */
  disable: function disable() {
    if (!this._enabled) {
      return;
    }

    this._featureGroup.off('layeradd', this._enableLayerEdit, this).off('layerremove', this._disableLayerEdit, this);

    external_L_default.a.Handler.prototype.disable.call(this);

    this._map.fire('draw:editstop', {
      handler: this.type
    });

    this.fire('disabled', {
      handler: this.type
    });
  },
  addHooks: function addHooks() {
    var map = this._map;

    if (map) {
      map.getContainer().focus();

      this._featureGroup.eachLayer(this._enableLayerEdit, this);

      this._tooltip = new draw_DrawTip(this._map);

      this._tooltip.updateContent({
        text: draw_TextMessage.edit.handlers.edit.tooltip.text,
        subtext: draw_TextMessage.edit.handlers.edit.tooltip.subtext
      }); // Quickly access the tooltip to update for intersection checking


      map._editTooltip = this._tooltip;

      this._updateTooltip();

      this._map.on('mousemove', this._onMouseMove, this).on('touchmove', this._onMouseMove, this).on('MSPointerMove', this._onMouseMove, this).on('draw:editvertex', this._updateTooltip, this);
    }
  },
  removeHooks: function removeHooks() {
    if (this._map) {
      // Clean up selected layers.
      this._featureGroup.eachLayer(this._disableLayerEdit, this); // Clear the backups of the original layers


      this._uneditedLayerProps = {};

      this._tooltip.dispose();

      this._tooltip = null;

      this._map.off('mousemove', this._onMouseMove, this).off('touchmove', this._onMouseMove, this).off('MSPointerMove', this._onMouseMove, this).off('click', this._editStyle, this).off('draw:editvertex', this._updateTooltip, this);
    }
  },
  revertLayers: function revertLayers() {
    this._featureGroup.eachLayer(function (layer) {
      this._revertLayer(layer);
    }, this);
  },
  save: function save() {
    var editedLayers = new external_L_default.a.LayerGroup();

    this._featureGroup.eachLayer(function (layer) {
      if (layer.edited) {
        editedLayers.addLayer(layer);
        layer.edited = false;
      }
    });

    this._map.fire('draw:edited', {
      layers: editedLayers
    });
  },
  _updateTooltip: function _updateTooltip() {
    this._tooltip.updateContent(this._getTooltipText());
  },
  _revertLayer: function _revertLayer(layer) {
    var id = external_L_default.a.Util.stamp(layer);
    layer.edited = false;

    if (this._uneditedLayerProps.hasOwnProperty(id)) {
      // Polyline, Polygon or Rectangle
      if (layer instanceof external_L_default.a.Polyline || layer instanceof external_L_default.a.Polygon || layer instanceof external_L_default.a.Rectangle) {
        layer.setLatLngs(this._uneditedLayerProps[id].latlngs);
      } else if (layer instanceof external_L_default.a.Circle) {
        layer.setLatLng(this._uneditedLayerProps[id].latlng);
        layer.setRadius(this._uneditedLayerProps[id].radius);
      } else if (layer instanceof external_L_default.a.Marker) {
        // Marker
        layer.setLatLng(this._uneditedLayerProps[id].latlng);
      }

      layer.fire('revert-edited', {
        layer: layer
      });
    }
  },
  _backupLayer: function _backupLayer(layer) {
    var id = external_L_default.a.Util.stamp(layer);

    if (!this._uneditedLayerProps[id]) {
      // Polyline, Polygon or Rectangle
      if (layer instanceof external_L_default.a.Polyline || layer instanceof external_L_default.a.Polygon || layer instanceof external_L_default.a.Rectangle) {
        this._uneditedLayerProps[id] = {
          latlngs: external_L_default.a.Util.cloneLatLngs(layer.getLatLngs())
        };
      } else if (layer instanceof external_L_default.a.Circle) {
        this._uneditedLayerProps[id] = {
          latlng: external_L_default.a.Util.cloneLatLng(layer.getLatLng()),
          radius: layer.getRadius()
        };
      } else if (layer instanceof external_L_default.a.Marker) {
        // Marker
        this._uneditedLayerProps[id] = {
          latlng: external_L_default.a.Util.cloneLatLng(layer.getLatLng())
        };
      }
    }
  },
  _getTooltipText: function _getTooltipText() {
    return {
      text: draw_TextMessage.edit.handlers.edit.tooltip.text,
      subtext: draw_TextMessage.edit.handlers.edit.tooltip.subtext
    };
  },
  _enableLayerEdit: function _enableLayerEdit(e) {
    var layer = e.layer || e.target || e,
        pathOptions,
        poly; // Back up this layer (if haven't before)

    this._backupLayer(layer);

    if (this.options.poly) {
      poly = external_L_default.a.Util.extend({}, this.options.poly);
      layer.options.poly = poly;
    } // Set different style for editing mode


    if (this.options.selectedPathOptions) {
      pathOptions = external_L_default.a.Util.extend({}, this.options.selectedPathOptions); // Use the existing color of the layer

      if (pathOptions.maintainColor) {
        pathOptions.color = layer.options.color;
        pathOptions.fillColor = layer.options.fillColor;
      }

      layer.options.original = external_L_default.a.extend({}, layer.options);
      layer.options.editing = pathOptions;
    }

    if (this.isMarker) {
      layer.dragging.enable();
      layer.on('dragend', this._onMarkerDragEnd) // #TODO: remove when leaflet finally fixes their draggable so it's touch friendly again.
      .on('touchmove', this._onTouchMove, this).on('MSPointerMove', this._onTouchMove, this).on('touchend', this._onMarkerDragEnd, this).on('MSPointerUp', this._onMarkerDragEnd, this);
    } else {
      layer.editing.enable();
    }
  },
  _disableLayerEdit: function _disableLayerEdit(e) {
    var layer = e.layer || e.target || e;
    layer.edited = false;
    layer.editing.disable();
    delete layer.options.editing;
    delete layer.options.original; // Reset layer styles to that of before select

    if (this._selectedPathOptions) {
      if (layer instanceof external_L_default.a.Marker) {
        this._toggleMarkerHighlight(layer);
      } else {
        // reset the layer style to what is was before being selected
        layer.setStyle(layer.options.previousOptions); // remove the cached options for the layer object

        delete layer.options.previousOptions;
      }
    }

    if (layer instanceof external_L_default.a.Marker) {
      layer.dragging.disable();
      layer.off('dragend', this._onMarkerDragEnd, this).off('touchmove', this._onTouchMove, this).off('MSPointerMove', this._onTouchMove, this).off('touchend', this._onMarkerDragEnd, this).off('MSPointerUp', this._onMarkerDragEnd, this);
    } else {
      layer.editing.disable();
    }
  },
  _onMouseMove: function _onMouseMove(e) {
    this._tooltip.updatePosition(e.latlng);
  },
  _onTouchMove: function _onTouchMove(e) {
    var touchEvent = e.originalEvent.changedTouches[0],
        layerPoint = this._map.mouseEventToLayerPoint(touchEvent),
        latlng = this._map.layerPointToLatLng(layerPoint);

    e.target.setLatLng(latlng);
  },
  _hasAvailableLayers: function _hasAvailableLayers() {
    return this._featureGroup.getLayers().length !== 0;
  }
});
var drawEdit = function drawEdit(map, options) {
  return new DrawEdit(map, options);
};
external_L_default.a.geoway.control.drawEdit = drawEdit;
external_L_default.a.geoway.control.DrawEdit = DrawEdit;
// EXTERNAL MODULE: ./src/util/TipPopup.js
var TipPopup = __webpack_require__(15);

// CONCATENATED MODULE: ./src/control/MeasurePath.js




var MeasurePath = DrawPolyline.extend({
  initialize: function initialize(map, options) {
    DrawPolyline.prototype.initialize.call(this, map, options);
    this._cache = [];
  },
  addHooks: function addHooks() {
    DrawPolyline.prototype.addHooks.call(this);

    if (this._map) {
      this._markerGroup = new external_L_default.a.LayerGroup();

      this._map.addLayer(this._markerGroup);

      this._markers = [];
      this._popups = [];

      this._map.on('click', this._onClick, this);

      this._startShape();
    }
  },
  removeHooks: function removeHooks() {
    this._clearHideErrorTimeout();

    this._mouseMarker.off('mousedown', this._onMouseDown, this).off('mouseout', this._onMouseOut, this).off('mouseup', this._onMouseUp, this).off('mousemove', this._onMouseMove, this);

    this._map.removeLayer(this._mouseMarker);

    delete this._mouseMarker;

    this._map.off('pointermove', this._onMouseMove, this).off('mousemove', this._onMouseMove, this).off('click', this._onClick, this);

    this._clearGuides();

    this._container.style.cursor = '';

    this._tooltip.dispose();
  },
  _startShape: function _startShape() {
    this._drawing = true;
    this._poly = new external_L_default.a.Polyline([], this.options.shapeOptions); // this is added as a placeholder, if leaflet doesn't recieve
    // this when the tool is turned off all onclick events are removed

    this._poly._onClick = function () {};

    this._container.style.cursor = 'crosshair';

    this._updateTooltip();

    this._map.on('pointermove', this._onMouseMove, this).on('mousemove', this._onMouseMove, this);
  },
  _finishShape: function _finishShape() {
    this._drawing = false;

    this._cleanUpShape();

    this._clearGuides();

    this._updateTooltip();

    this._map.off('pointermove', this._onMouseMove, this).off('mousemove', this._onMouseMove, this);

    this._container.style.cursor = '';
    this.disable();
    var polyId = external_L_default.a.stamp(this._poly);
    var measureId = "measure-" + polyId;
    var cache = {
      id: measureId,
      popups: this._popups,
      markers: this._markers,
      poly: this._poly
    };

    this._cache.push(cache);

    if (this._tippopup) {
      //var content = this._tippopup.getContent();
      var closeBtn = external_L_default.a.DomUtil.create('div', "leaflet-measure-tipclose");
      closeBtn.id = measureId;
      closeBtn.title = '清除本次测距';

      this._tippopup._contentNode.appendChild(closeBtn);

      var w = this._tippopup._contentNode.offsetWidth;
      this._tippopup._contentNode.style.width = w + 30 + "px";
      external_L_default.a.DomEvent.on(closeBtn, 'click', this._onTipClose, this);
    }
  },
  _removeShape: function _removeShape() {
    if (!this._poly) {
      return false;
    }

    this._map.removeLayer(this._poly);

    delete this._poly;

    this._markers.splice(0);

    this._markerGroup.clearLayers();
  },
  _onClick: function _onClick() {
    if (!this._drawing) {
      this._removeShape();

      this._startShape();

      return;
    }
  },
  _getTooltipText: function _getTooltipText() {
    var labelText = DrawPolyline.prototype._getTooltipText.call(this);

    if (!this._drawing) {
      labelText.text = '';
    }

    return labelText;
  },
  addVertex: function addVertex(latlng) {
    var markersLength = this._markers.length;

    if (markersLength > 0 && !this.options.allowIntersection && this._poly.newLatLngIntersects(latlng)) {
      this._showErrorTooltip();

      return;
    } else if (this._errorShown) {
      this._hideErrorTooltip();
    }

    var marker = this._createMarker(latlng);

    external_L_default.a.DomEvent.on(marker, "dblclick", this._preventMouseEvent, this);

    var text = this._getTooltipText();

    var content = "";
    var w;

    if (text.subtext) {
      content = text.subtext;
      w = 46;
    } else {
      content = "起点";
      w = 40;
    }

    var popup = new TipPopup["a" /* default */]({
      offset: new external_L_default.a.Point(w, 24)
    });
    popup.setLatLng(latlng).setContent(content).openOn(this._map);
    popup._sort = "tip-popup";
    this._tippopup = popup;

    this._popups.push(popup);

    this._markers.push(marker);

    this._poly.addLatLng(latlng);

    if (this._poly.getLatLngs().length === 2) {
      this._map.addLayer(this._poly);
    }

    this._vertexChanged(latlng, true);
  },
  _onTipClose: function _onTipClose(e) {
    var el = e.target || e.srcElement;
    var measureId = el.id;

    var cache = this._getCacheById(measureId);

    if (cache) {
      var popups = cache.popups;
      var markers = cache.markers;
      var poly = cache.poly;

      this._map.removeLayer(poly);

      for (var i = 0; i < markers.length; i++) {
        if (markers[i] && popups[i]) {
          this._map.removeLayer(markers[i]);

          this._map.removeLayer(popups[i]);
        }
      }

      this._deleteCacheById(measureId);
    }
  },
  _getCacheById: function _getCacheById(id) {
    var cache;

    for (var i = 0; i < this._cache.length; i++) {
      if (this._cache[i].id == id) {
        cache = this._cache[i];
        break;
      }
    }

    return cache;
  },
  _deleteCacheById: function _deleteCacheById(id) {
    for (var i = this._cache.length - 1; i >= 0; i--) {
      if (this._cache[i].id == id) {
        this._cache.splice(i, 1);

        break;
      }
    }
  },
  _preventMouseEvent: function _preventMouseEvent(e) {
    if (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {
      external_L_default.a.DomEvent.preventDefault(e);
    }

    if (e.type !== 'mousedown') {
      external_L_default.a.DomEvent.stopPropagation(e);
    } else {
      external_L_default.a.DomEvent.preventDefault(e);
    }
  },
  clear: function clear() {
    var caches = this._cache;

    for (var k = 0; k < caches.length; k++) {
      var cache = caches[k];
      var popups = cache.popups;
      var markers = cache.markers;
      var poly = cache.poly;

      this._map.removeLayer(poly);

      for (var i = 0; i < markers.length; i++) {
        if (markers[i] && popups[i]) {
          this._map.removeLayer(markers[i]);

          this._map.removeLayer(popups[i]);
        }
      }
    }

    this._popups = [];
    this._markers = [];
    this._poly = null;
    this._cache = [];
  }
});
var measurePath = function measurePath(map, options) {
  return new MeasurePath(map, options);
};
external_L_default.a.geoway.control.measurePath = measurePath;
external_L_default.a.geoway.control.MeasurePath = MeasurePath;
external_L_default.a.Measure = external_L_default.a.Measure ? external_L_default.a.Measure : {};
external_L_default.a.Measure.Path = MeasurePath;
// CONCATENATED MODULE: ./src/control/MeasureArea.js





var MeasureArea = DrawPolygon.extend({
  options: {
    showArea: true,
    shapeOptions: {
      stroke: true,
      color: '#f06eaa',
      weight: 4,
      opacity: 0.5,
      fill: true,
      fillColor: null,
      //same as color by default
      fillOpacity: 0.2,
      clickable: true
    },
    metric: true // Whether to use the metric measurement system or imperial

  },
  initialize: function initialize(map, options) {
    DrawPolygon.prototype.initialize.call(this, map, options);
    this._cache = [];
  },
  addHooks: function addHooks() {
    DrawPolygon.prototype.addHooks.call(this);

    if (this._map && !this._areaGroup) {
      this._areaGroup = new external_L_default.a.LayerGroup();

      this._map.addLayer(this._areaGroup);
    }
  },
  removeHooks: function removeHooks() {
    this._clearHideErrorTimeout();

    this._cleanUpShape(); // remove markers from map


    this._map.removeLayer(this._markerGroup);

    delete this._markerGroup;
    delete this._markers;

    this._map.removeLayer(this._poly);

    delete this._poly;

    this._mouseMarker.off('mousedown', this._onMouseDown, this).off('mouseout', this._onMouseOut, this).off('mouseup', this._onMouseUp, this).off('mousemove', this._onMouseMove, this);

    this._map.removeLayer(this._mouseMarker);

    delete this._mouseMarker; // clean up DOM

    this._clearGuides();

    this._map.off('mouseup', this._onMouseUp, this).off('mousemove', this._onMouseMove, this).off('zoomlevelschange', this._onZoomEnd, this).off('zoomend', this._onZoomEnd, this).off('click', this._onTouch, this);

    this._container.style.cursor = '';

    this._tooltip.dispose();
  },
  _finishShape: function _finishShape() {
    this._cleanUpShape();

    this._clearGuides();

    var latlngs = this._poly.getLatLngs();

    var lastLatlng = latlngs[latlngs.length - 1];

    var intersects = this._poly.newLatLngIntersects(lastLatlng);

    if (!this.options.allowIntersection && intersects || !this._shapeIsValid()) {
      this._showErrorTooltip();

      return;
    }

    var area = external_L_default.a.Util.geodesicArea(latlngs);
    area = external_L_default.a.Util.readableArea(area, this.options.metric);
    var poly = new this.Poly(this._poly.getLatLngs(), this.options.shapeOptions);

    this._areaGroup.addLayer(poly);

    var polyId = external_L_default.a.stamp(poly);
    var measureId = "measure-" + polyId;
    var popup = new TipPopup["a" /* default */]({
      offset: new external_L_default.a.Point(36, -4)
    });
    popup.setLatLng(lastLatlng).setContent(area).openOn(this._map);
    popup._sort = "tip-popup"; //var content = popup.getContent();

    var closeBtn = external_L_default.a.DomUtil.create('div', "leaflet-measure-tipclose");
    closeBtn.id = measureId;
    closeBtn.title = '清除本次测面';

    popup._contentNode.appendChild(closeBtn);

    var w = popup._contentNode.offsetWidth;
    popup._contentNode.style.width = w + 30 + "px";
    external_L_default.a.DomEvent.on(closeBtn, 'click', this._onTipClose, this);
    var cache = {
      id: measureId,
      popup: popup,
      poly: poly
    };

    this._cache.push(cache);

    this.disable();
  },
  _onTipClose: function _onTipClose(e) {
    var el = e.target || e.srcElement;
    var measureId = el.id;

    var cache = this._getCacheById(measureId);

    if (cache) {
      var popup = cache.popup;
      var poly = cache.poly;

      this._map.removeLayer(poly);

      this._map.removeLayer(popup);

      this._deleteCacheById(measureId);
    }
  },
  _getCacheById: function _getCacheById(id) {
    var cache;

    for (var i = 0; i < this._cache.length; i++) {
      if (this._cache[i].id == id) {
        cache = this._cache[i];
        break;
      }
    }

    return cache;
  },
  _deleteCacheById: function _deleteCacheById(id) {
    for (var i = this._cache.length - 1; i >= 0; i--) {
      if (this._cache[i].id == id) {
        this._cache.splice(i, 1);

        break;
      }
    }
  },
  clear: function clear() {
    var caches = this._cache;

    for (var k = 0; k < caches.length; k++) {
      var cache = caches[k];
      var popup = cache.popup;
      var poly = cache.poly;

      this._map.removeLayer(poly);

      this._map.removeLayer(popup);
    }

    this._cache = [];
  }
});
var measureArea = function measureArea(map, options) {
  return new MeasureArea(map, options);
};
external_L_default.a.geoway.control.measureArea = measureArea;
external_L_default.a.geoway.control.MeasureArea = MeasureArea;
external_L_default.a.Measure = external_L_default.a.Measure ? external_L_default.a.Measure : {};
external_L_default.a.Measure.Area = MeasureArea;
// CONCATENATED MODULE: ./src/control/ZoomBox.js


var ZoomBox = external_L_default.a.Control.extend({
  _map: null,
  includes: external_L_default.a.Evented ? external_L_default.a.Evented.prototype : external_L_default.a.Mixin.Events,
  onAdd: function onAdd(map) {
    this._map = map;
    this._container = external_L_default.a.DomUtil.create('div', 'leaflet-zoom-box-control leaflet-bar'); // Bind to the map's boxZoom handler

    var _origMouseDown = map.boxZoom._onMouseDown;

    map.boxZoom._onMouseDown = function (e) {
      if (e.button === 2) {
        return;
      } // prevent right-click from triggering zoom box


      _origMouseDown.call(map.boxZoom, {
        clientX: e.clientX,
        clientY: e.clientY,
        which: 1,
        shiftKey: true
      });
    }; //var _origMouseUp = map.boxZoom._onMouseUp;


    map.boxZoom._onMouseUp = function (e) {
      if (e.which !== 1 && e.button !== 1) {
        return;
      }

      this._finish();

      if (!this._moved) {
        return;
      }

      setTimeout(external_L_default.a.bind(this._resetState, this), 0);

      var startLatLng = this._map.containerPointToLatLng(this._startPoint);

      var endLatLng = this._map.containerPointToLatLng(this._point);

      var bounds = new external_L_default.a.LatLngBounds(startLatLng, endLatLng);
      var out = this.out;

      if (!out) {
        this._map.fitBounds(bounds).fire('boxzoomend', {
          boxZoomBounds: bounds
        });
      } else {
        var center = bounds.getCenter();
        var zoom = this._map.getZoom() - 1 >= 0 ? this._map.getZoom() - 1 : 0;

        this._map.setView(center, zoom).fire('boxzoomend', {
          boxZoomBounds: bounds
        });
      }
    };

    map.on('boxzoomend', this.deactivate, this);
    return this._container;
  },
  activate: function activate(options) {
    this._map.boxZoom.out = options.out;

    this._map.dragging.disable();

    this._map.boxZoom.addHooks();

    external_L_default.a.DomUtil.addClass(this._map.getContainer(), 'leaflet-zoom-box-crosshair');
  },
  deactivate: function deactivate() {
    this._map.dragging.enable();

    this._map.boxZoom.removeHooks();

    external_L_default.a.DomUtil.removeClass(this._map.getContainer(), 'leaflet-zoom-box-crosshair');
  }
});
var zoomBox = function zoomBox() {
  return new ZoomBox();
};
external_L_default.a.geoway.control.zoomBox = zoomBox;
external_L_default.a.geoway.control.ZoomBox = ZoomBox;
external_L_default.a.Control.ZoomBox = ZoomBox;
external_L_default.a.control.zoomBox = zoomBox;
// CONCATENATED MODULE: ./src/util/ZoomCenter.js

var ZoomCenter = external_L_default.a.Class.extend({
  initialize: function initialize(zoom, centerPoint) {
    this.zoom = zoom;
    this.centerPoint = centerPoint;
  }
});
/* harmony default export */ var util_ZoomCenter = (ZoomCenter);
// CONCATENATED MODULE: ./src/control/History.js



var History = external_L_default.a.Control.extend({
  options: {
    position: 'topright',
    maxMovesToSave: 100,
    useExternalControls: true,
    backImage: 'fa fa-caret-left',
    backText: '',
    backTooltip: 'Go to Previous Extent',
    backImageBeforeText: true,
    forwardImage: 'fa fa-caret-right',
    forwardText: '',
    forwardTooltip: 'Go to Next Extent',
    forwardImageBeforeText: false,
    orientation: 'horizontal',
    shouldSaveMoveInHistory: function shouldSaveMoveInHistory() {
      return true;
    }
  },
  initialize: function initialize(options) {
    external_L_default.a.Util.setOptions(this, options);
    this._state.maxMovesToSave = this.options.maxMovesToSave;
  },
  onAdd: function onAdd(map) {
    this._map = map;
    var container = external_L_default.a.DomUtil.create('div', 'history-control leaflet-bar leaflet-control ' + this.options.orientation);

    if (!this.options.useExternalControls) {
      this._backButton = this._createButton('back', container, this.goBack, this);
      this._forwardButton = this._createButton('forward', container, this.goForward, this);
    }

    this._updateDisabled();

    this._addMapListeners();

    return container;
  },
  onRemove: function onRemove(map) {
    map.off('movestart');
  },
  performActionWithoutTriggeringEvent: function performActionWithoutTriggeringEvent(action) {
    this._state.ignoringEvents = true;

    if (typeof action === 'function') {
      action();
    }
  },
  moveWithoutTriggeringEvent: function moveWithoutTriggeringEvent(zoomCenter) {
    var _this = this;

    this.performActionWithoutTriggeringEvent(function () {
      _this._map.setView(zoomCenter.centerPoint, zoomCenter.zoom);
    });
  },
  goBack: function goBack() {
    return this._invokeBackOrForward('historyback', this._state.history, this._state.future);
  },
  goForward: function goForward() {
    return this._invokeBackOrForward('historyforward', this._state.future, this._state.history);
  },
  clearHistory: function clearHistory() {
    this._state.history.items = [];

    this._updateDisabled();
  },
  clearFuture: function clearFuture() {
    this._state.future.items = [];

    this._updateDisabled();
  },
  _map: null,
  _backButton: null,
  _forwardButton: null,
  _state: {
    backDisabled: null,
    forwardDisabled: null,
    ignoringEvents: false,
    maxMovesToSave: 0,
    history: {
      items: []
    },
    future: {
      items: []
    }
  },
  _createButton: function _createButton(name, container, action, _this) {
    var text = this.options[name + 'Text'] || '';
    var imageClass = this.options[name + 'Image'] || '';
    var tooltip = this.options[name + 'Tooltip'] || '';
    var button = external_L_default.a.DomUtil.create('a', 'history-' + name + '-button', container);

    if (imageClass) {
      var imageElement = '<i class="' + imageClass + '"></i>';

      if (this.options[name + 'ImageBeforeText']) {
        text = imageElement + ' ' + text;
      } else {
        text += ' ' + imageElement;
      }
    }

    button.innerHTML = text;
    button.href = '#';
    button.title = tooltip;
    var stop = external_L_default.a.DomEvent.stopPropagation;
    external_L_default.a.DomEvent.on(button, 'click', stop).on(button, 'mousedown', stop).on(button, 'dblclick', stop).on(button, 'click', external_L_default.a.DomEvent.preventDefault).on(button, 'click', action, _this).on(button, 'click', this._refocusOnMap, _this);
    return button;
  },
  _updateDisabled: function _updateDisabled() {
    var backDisabled = this._state.history.items.length === 0;
    var forwardDisabled = this._state.future.items.length === 0;

    if (backDisabled !== this._state.backDisabled) {
      this._state.backDisabled = backDisabled;

      this._map.fire('historyback' + (backDisabled ? 'disabled' : 'enabled'));
    }

    if (forwardDisabled !== this._state.forwardDisabled) {
      this._state.forwardDisabled = forwardDisabled;

      this._map.fire('historyforward' + (forwardDisabled ? 'disabled' : 'enabled'));
    }

    if (!this.options.useExternalControls) {
      this._setButtonDisabled(this._backButton, backDisabled);

      this._setButtonDisabled(this._forwardButton, forwardDisabled);
    }
  },
  _setButtonDisabled: function _setButtonDisabled(button, condition) {
    var className = 'leaflet-disabled';

    if (condition) {
      external_L_default.a.DomUtil.addClass(button, className);
    } else {
      external_L_default.a.DomUtil.removeClass(button, className);
    }
  },
  _pop: function _pop(stack) {
    stack = stack.items;

    if (external_L_default.a.Util.isArray(stack) && stack.length > 0) {
      return stack.splice(stack.length - 1, 1)[0];
    }

    return undefined;
  },
  _push: function _push(stack, value) {
    var maxLength = this._state.maxMovesToSave;
    stack = stack.items;

    if (external_L_default.a.Util.isArray(stack)) {
      stack.push(value);

      if (maxLength > 0 && stack.length > maxLength) {
        stack.splice(0, 1);
      }
    }
  },
  _invokeBackOrForward: function _invokeBackOrForward(eventName, stackToPop, stackToPushCurrent) {
    var response = this._popStackAndUseLocation(stackToPop, stackToPushCurrent);

    if (response) {
      this._map.fire(eventName, response);

      return true;
    }

    return false;
  },
  _popStackAndUseLocation: function _popStackAndUseLocation(stackToPop, stackToPushCurrent) {
    //check if we can pop
    if (external_L_default.a.Util.isArray(stackToPop.items) && stackToPop.items.length > 0) {
      var current = this._buildZoomCenterObjectFromCurrent(this._map); //get most recent


      var previous = this._pop(stackToPop); //save where we currently are in the 'other' stack


      this._push(stackToPushCurrent, current);

      this.moveWithoutTriggeringEvent(previous);
      return {
        previousLocation: previous,
        currentLocation: current
      };
    }
  },
  _buildZoomCenterObjectFromCurrent: function _buildZoomCenterObjectFromCurrent(map) {
    return new util_ZoomCenter(map.getZoom(), map.getCenter());
  },
  _addMapListeners: function _addMapListeners() {
    var _this = this;

    this._map.on('movestart', function (e) {
      if (!_this._state.ignoringEvents) {
        var current = _this._buildZoomCenterObjectFromCurrent(e.target);

        if (_this.options.shouldSaveMoveInHistory(current)) {
          _this._state.future.items = [];

          _this._push(_this._state.history, current);
        }
      } else {
        _this._state.ignoringEvents = false;
      }

      _this._updateDisabled();
    });
  }
});
var History_history = function history() {
  return new History();
};
external_L_default.a.geoway.control.history = History_history;
external_L_default.a.geoway.control.History = History;
external_L_default.a.Control.History = History;
external_L_default.a.control.history = History_history;
// CONCATENATED MODULE: ./src/control/MousePosition.js


var MousePosition = external_L_default.a.Control.extend({
  options: {
    position: 'bottomleft',
    separator: ' : ',
    emptyString: '',
    lngFirst: true,
    numDigits: 5,
    lngFormatter: undefined,
    latFormatter: undefined,
    prefix: ""
  },
  onAdd: function onAdd(map) {
    this._container = external_L_default.a.DomUtil.create('div', 'leaflet-control-mouseposition');
    external_L_default.a.DomEvent.disableClickPropagation(this._container);
    map.on('mousemove', this._onMouseMove, this);
    this._container.innerHTML = this.options.emptyString;
    return this._container;
  },
  onRemove: function onRemove(map) {
    map.off('mousemove', this._onMouseMove);
  },
  _onMouseMove: function _onMouseMove(e) {
    var lng = this.options.lngFormatter ? this.options.lngFormatter(e.latlng.lng) : external_L_default.a.Util.formatNum(e.latlng.lng, this.options.numDigits);
    var lat = this.options.latFormatter ? this.options.latFormatter(e.latlng.lat) : external_L_default.a.Util.formatNum(e.latlng.lat, this.options.numDigits);
    var value = this.options.lngFirst ? lng + this.options.separator + lat : lat + this.options.separator + lng;
    var prefixAndValue = this.options.prefix + ' ' + value;
    this._container.innerHTML = prefixAndValue;
  }
});
var mousePosition = function mousePosition() {
  return new MousePosition();
};
external_L_default.a.geoway.control.mousePosition = mousePosition;
external_L_default.a.geoway.control.MousePosition = MousePosition;
external_L_default.a.Control.MousePosition = MousePosition;
external_L_default.a.control.mousePosition = mousePosition;
external_L_default.a.Map.mergeOptions({
  positionControl: false
});
external_L_default.a.Map.addInitHook(function () {
  if (this.options.positionControl) {
    this.positionControl = new external_L_default.a.geoway.control.MousePosition();
    this.addControl(this.positionControl);
  }
});
// CONCATENATED MODULE: ./src/control/editable/VertexMarker.js
 // 🍂namespace Editable; 🍂class VertexMarker; Handler for dragging path vertices.

var VertexMarker = external_L_default.a.Marker.extend({
  options: {
    draggable: true,
    className: 'leaflet-div-icon leaflet-vertex-icon'
  },
  // 🍂section Public methods
  // The marker used to handle path vertex. You will usually interact with a `VertexMarker`
  // instance when listening for events like `editable:vertex:ctrlclick`.
  initialize: function initialize(latlng, latlngs, editor, options) {
    // We don't use this._latlng, because on drag Leaflet replace it while
    // we want to keep reference.
    this.latlng = latlng;
    this.latlngs = latlngs;
    this.editor = editor;
    external_L_default.a.Marker.prototype.initialize.call(this, latlng, options);
    this.options.icon = this.editor.tools.createVertexIcon({
      className: this.options.className
    });
    this.latlng.__vertex = this;
    this.editor.editLayer.addLayer(this);
    this.setZIndexOffset(editor.tools._lastZIndex + 1);
  },
  onAdd: function onAdd(map) {
    external_L_default.a.Marker.prototype.onAdd.call(this, map);
    this.on('drag', this.onDrag);
    this.on('dragstart', this.onDragStart);
    this.on('dragend', this.onDragEnd);
    this.on('mouseup', this.onMouseup);
    this.on('click', this.onClick);
    this.on('contextmenu', this.onContextMenu);
    this.on('mousedown touchstart', this.onMouseDown);
    this.on('mouseover', this.onMouseOver);
    this.on('mouseout', this.onMouseOut);
    this.addMiddleMarkers();
  },
  onRemove: function onRemove(map) {
    if (this.middleMarker) this.middleMarker["delete"]();
    delete this.latlng.__vertex;
    this.off('drag', this.onDrag);
    this.off('dragstart', this.onDragStart);
    this.off('dragend', this.onDragEnd);
    this.off('mouseup', this.onMouseup);
    this.off('click', this.onClick);
    this.off('contextmenu', this.onContextMenu);
    this.off('mousedown touchstart', this.onMouseDown);
    this.off('mouseover', this.onMouseOver);
    this.off('mouseout', this.onMouseOut);
    external_L_default.a.Marker.prototype.onRemove.call(this, map);
  },
  onDrag: function onDrag(e) {
    e.vertex = this;
    this.editor.onVertexMarkerDrag(e);

    var iconPos = external_L_default.a.DomUtil.getPosition(this._icon),
        latlng = this._map.layerPointToLatLng(iconPos);

    this.latlng.update(latlng);
    this._latlng = this.latlng; // Push back to Leaflet our reference.

    this.editor.refresh();
    if (this.middleMarker) this.middleMarker.updateLatLng();
    var next = this.getNext();
    if (next && next.middleMarker) next.middleMarker.updateLatLng();
  },
  onDragStart: function onDragStart(e) {
    e.vertex = this;
    this.editor.onVertexMarkerDragStart(e);
  },
  onDragEnd: function onDragEnd(e) {
    e.vertex = this;
    this.editor.onVertexMarkerDragEnd(e);
  },
  onClick: function onClick(e) {
    e.vertex = this;
    this.editor.onVertexMarkerClick(e);
  },
  onMouseup: function onMouseup(e) {
    external_L_default.a.DomEvent.stop(e);
    e.vertex = this;
    this.editor.map.fire('mouseup', e);
  },
  onContextMenu: function onContextMenu(e) {
    e.vertex = this;
    this.editor.onVertexMarkerContextMenu(e);
  },
  onMouseDown: function onMouseDown(e) {
    e.vertex = this;
    this.editor.onVertexMarkerMouseDown(e);
  },
  onMouseOver: function onMouseOver(e) {
    e.vertex = this;
    this.editor.onVertexMarkerMouseOver(e);
  },
  onMouseOut: function onMouseOut(e) {
    e.vertex = this;
    this.editor.onVertexMarkerMouseOut(e);
  },
  // 🍂method delete()
  // Delete a vertex and the related LatLng.
  "delete": function _delete() {
    var next = this.getNext(); // Compute before changing latlng

    this.latlngs.splice(this.getIndex(), 1);
    this.editor.editLayer.removeLayer(this);
    this.editor.onVertexDeleted({
      latlng: this.latlng,
      vertex: this
    });
    if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);
    if (next) next.resetMiddleMarker();
    this.editor.refresh();
  },
  // 🍂method getIndex(): int
  // Get the index of the current vertex among others of the same LatLngs group.
  getIndex: function getIndex() {
    return this.latlngs.indexOf(this.latlng);
  },
  // 🍂method getLastIndex(): int
  // Get last vertex index of the LatLngs group of the current vertex.
  getLastIndex: function getLastIndex() {
    return this.latlngs.length - 1;
  },
  // 🍂method getPrevious(): VertexMarker
  // Get the previous VertexMarker in the same LatLngs group.
  getPrevious: function getPrevious() {
    if (this.latlngs.length < 2) return;
    var index = this.getIndex(),
        previousIndex = index - 1;
    if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();
    var previous = this.latlngs[previousIndex];
    if (previous) return previous.__vertex;
  },
  // 🍂method getNext(): VertexMarker
  // Get the next VertexMarker in the same LatLngs group.
  getNext: function getNext() {
    if (this.latlngs.length < 2) return;
    var index = this.getIndex(),
        nextIndex = index + 1;
    if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;
    var next = this.latlngs[nextIndex];
    if (next) return next.__vertex;
  },
  addMiddleMarker: function addMiddleMarker(previous) {
    if (!this.editor.hasMiddleMarkers()) return;
    previous = previous || this.getPrevious();
    if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);
  },
  addMiddleMarkers: function addMiddleMarkers() {
    if (!this.editor.hasMiddleMarkers()) return;
    var previous = this.getPrevious();
    if (previous) this.addMiddleMarker(previous);
    var next = this.getNext();
    if (next) next.resetMiddleMarker();
  },
  resetMiddleMarker: function resetMiddleMarker() {
    if (this.middleMarker) this.middleMarker["delete"]();
    this.addMiddleMarker();
  },
  // 🍂method split()
  // Split the vertex LatLngs group at its index, if possible.
  split: function split() {
    if (!this.editor.splitShape) return; // Only for PolylineEditor

    this.editor.splitShape(this.latlngs, this.getIndex());
  },
  // 🍂method continue()
  // Continue the vertex LatLngs from this vertex. Only active for first and last vertices of a Polyline.
  "continue": function _continue() {
    if (!this.editor.continueBackward) return; // Only for PolylineEditor

    var index = this.getIndex();
    if (index === 0) this.editor.continueBackward(this.latlngs);else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);
  }
});
/* harmony default export */ var editable_VertexMarker = (VertexMarker);
// CONCATENATED MODULE: ./src/control/editable/MiddleMarker.js


var MiddleMarker = external_L_default.a.Marker.extend({
  options: {
    opacity: 0.5,
    className: 'leaflet-div-icon leaflet-middle-icon',
    draggable: true
  },
  initialize: function initialize(left, right, latlngs, editor, options) {
    this.left = left;
    this.right = right;
    this.editor = editor;
    this.latlngs = latlngs;
    external_L_default.a.Marker.prototype.initialize.call(this, this.computeLatLng(), options);
    this._opacity = this.options.opacity;
    this.options.icon = this.editor.tools.createVertexIcon({
      className: this.options.className
    });
    this.editor.editLayer.addLayer(this);
    this.setVisibility();
  },
  setVisibility: function setVisibility() {
    var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),
        rightPoint = this._map.latLngToContainerPoint(this.right.latlng),
        size = external_L_default.a.point(this.options.icon.options.iconSize);

    if (leftPoint.distanceTo(rightPoint) < size.x * 3) {
      this.hide();
    } else {
      this.show();
    }
  },
  show: function show() {
    this.setOpacity(this._opacity);
  },
  hide: function hide() {
    this.setOpacity(0);
  },
  updateLatLng: function updateLatLng() {
    this.setLatLng(this.computeLatLng());
    this.setVisibility();
  },
  computeLatLng: function computeLatLng() {
    var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),
        rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),
        y = (leftPoint.y + rightPoint.y) / 2,
        x = (leftPoint.x + rightPoint.x) / 2;
    return this.editor.map.containerPointToLatLng([x, y]);
  },
  onAdd: function onAdd(map) {
    external_L_default.a.Marker.prototype.onAdd.call(this, map);
    external_L_default.a.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);
    map.on('zoomend', this.setVisibility, this);
  },
  onRemove: function onRemove(map) {
    delete this.right.middleMarker;
    external_L_default.a.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);
    map.off('zoomend', this.setVisibility, this);
    external_L_default.a.Marker.prototype.onRemove.call(this, map);
  },
  onMouseDown: function onMouseDown(e) {
    var iconPos = external_L_default.a.DomUtil.getPosition(this._icon),
        latlng = this.editor.map.layerPointToLatLng(iconPos);
    e = {
      originalEvent: e,
      latlng: latlng
    };

    if (this.options.opacity === 0) {
      return;
    }

    editable_Editable.makeCancellable(e);
    this.editor.onMiddleMarkerMouseDown(e);

    if (e._cancelled) {
      return;
    }

    this.latlngs.splice(this.index(), 0, e.latlng);
    this.editor.refresh();
    var icon = this._icon;
    var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);
    this.editor.onNewVertex(marker);
    /* Hack to workaround browser not firing touchend when element is no more on DOM */

    var parent = marker._icon.parentNode;
    parent.removeChild(marker._icon);
    marker._icon = icon;
    parent.appendChild(marker._icon);

    marker._initIcon();

    marker._initInteraction();

    marker.setOpacity(1);
    /* End hack */
    // Transfer ongoing dragging to real marker

    external_L_default.a.Draggable._dragging = false;

    marker.dragging._draggable._onDown(e.originalEvent);

    this["delete"]();
  },
  "delete": function _delete() {
    this.editor.editLayer.removeLayer(this);
  },
  index: function index() {
    return this.latlngs.indexOf(this.right.latlng);
  }
});
/* harmony default export */ var editable_MiddleMarker = (MiddleMarker);
// CONCATENATED MODULE: ./src/control/editable/VertexIcon.js

var VertexIcon = external_L_default.a.DivIcon.extend({
  options: {
    iconSize: new external_L_default.a.Point(8, 8)
  }
});
/* harmony default export */ var editable_VertexIcon = (VertexIcon);
// CONCATENATED MODULE: ./src/control/editable/TouchVertexIcon.js


var TouchVertexIcon = editable_VertexIcon.extend({
  options: {
    iconSize: new external_L_default.a.Point(20, 20)
  }
});
/* harmony default export */ var editable_TouchVertexIcon = (TouchVertexIcon);
// CONCATENATED MODULE: ./src/control/editable/Editable.js





var Editable = external_L_default.a.Evented.extend({
  statics: {
    FORWARD: 1,
    BACKWARD: -1
  },
  options: {
    // You can pass them when creating a map using the `editOptions` key.
    // 🍂option zIndex: int = 1000
    // The default zIndex of the editing tools.
    zIndex: 1000,
    // 🍂option polygonClass: class = L.Polygon
    // Class to be used when creating a new Polygon.
    polygonClass: external_L_default.a.Polygon,
    // 🍂option polylineClass: class = L.Polyline
    // Class to be used when creating a new Polyline.
    polylineClass: external_L_default.a.Polyline,
    // 🍂option markerClass: class = L.Marker
    // Class to be used when creating a new Marker.
    markerClass: external_L_default.a.Marker,
    // 🍂option rectangleClass: class = L.Rectangle
    // Class to be used when creating a new Rectangle.
    rectangleClass: external_L_default.a.Rectangle,
    // 🍂option circleClass: class = L.Circle
    // Class to be used when creating a new Circle.
    circleClass: external_L_default.a.Circle,
    // 🍂option drawingCSSClass: string = 'leaflet-editable-drawing'
    // CSS class to be added to the map container while drawing.
    drawingCSSClass: 'leaflet-editable-drawing',
    // 🍂option drawingCursor: const = 'crosshair'
    // Cursor mode set to the map while drawing.
    drawingCursor: 'crosshair',
    // 🍂option editLayer: Layer = new L.LayerGroup()
    // Layer used to store edit tools (vertex, line guide…).
    editLayer: undefined,
    // 🍂option featuresLayer: Layer = new L.LayerGroup()
    // Default layer used to store drawn features (Marker, Polyline…).
    featuresLayer: undefined,
    // 🍂option polylineEditorClass: class = PolylineEditor
    // Class to be used as Polyline editor.
    polylineEditorClass: undefined,
    // 🍂option polygonEditorClass: class = PolygonEditor
    // Class to be used as Polygon editor.
    polygonEditorClass: undefined,
    // 🍂option markerEditorClass: class = MarkerEditor
    // Class to be used as Marker editor.
    markerEditorClass: undefined,
    // 🍂option rectangleEditorClass: class = RectangleEditor
    // Class to be used as Rectangle editor.
    rectangleEditorClass: undefined,
    // 🍂option circleEditorClass: class = CircleEditor
    // Class to be used as Circle editor.
    circleEditorClass: undefined,
    // 🍂option lineGuideOptions: hash = {}
    // Options to be passed to the line guides.
    lineGuideOptions: {},
    // 🍂option skipMiddleMarkers: boolean = false
    // Set this to true if you don't want middle markers.
    skipMiddleMarkers: false
  },
  initialize: function initialize(map, options) {
    external_L_default.a.setOptions(this, options);
    this._lastZIndex = this.options.zIndex;
    this.map = map;
    this.editLayer = this.createEditLayer();
    this.featuresLayer = this.createFeaturesLayer();
    this.forwardLineGuide = this.createLineGuide();
    this.backwardLineGuide = this.createLineGuide();
  },
  fireAndForward: function fireAndForward(type, e) {
    e = e || {};
    e.editTools = this;
    this.fire(type, e);
    this.map.fire(type, e);
  },
  createLineGuide: function createLineGuide() {
    var options = external_L_default.a.extend({
      dashArray: '5,10',
      weight: 1,
      interactive: false
    }, this.options.lineGuideOptions);
    return external_L_default.a.polyline([], options);
  },
  createVertexIcon: function createVertexIcon(options) {
    return external_L_default.a.Browser.mobile && external_L_default.a.Browser.touch ? new editable_TouchVertexIcon(options) : new editable_VertexIcon(options);
  },
  createEditLayer: function createEditLayer() {
    return this.options.editLayer || new external_L_default.a.LayerGroup().addTo(this.map);
  },
  createFeaturesLayer: function createFeaturesLayer() {
    return this.options.featuresLayer || new external_L_default.a.LayerGroup().addTo(this.map);
  },
  moveForwardLineGuide: function moveForwardLineGuide(latlng) {
    if (this.forwardLineGuide._latlngs.length) {
      this.forwardLineGuide._latlngs[1] = latlng;

      this.forwardLineGuide._bounds.extend(latlng);

      this.forwardLineGuide.redraw();
    }
  },
  moveBackwardLineGuide: function moveBackwardLineGuide(latlng) {
    if (this.backwardLineGuide._latlngs.length) {
      this.backwardLineGuide._latlngs[1] = latlng;

      this.backwardLineGuide._bounds.extend(latlng);

      this.backwardLineGuide.redraw();
    }
  },
  anchorForwardLineGuide: function anchorForwardLineGuide(latlng) {
    this.forwardLineGuide._latlngs[0] = latlng;

    this.forwardLineGuide._bounds.extend(latlng);

    this.forwardLineGuide.redraw();
  },
  anchorBackwardLineGuide: function anchorBackwardLineGuide(latlng) {
    this.backwardLineGuide._latlngs[0] = latlng;

    this.backwardLineGuide._bounds.extend(latlng);

    this.backwardLineGuide.redraw();
  },
  attachForwardLineGuide: function attachForwardLineGuide() {
    this.editLayer.addLayer(this.forwardLineGuide);
  },
  attachBackwardLineGuide: function attachBackwardLineGuide() {
    this.editLayer.addLayer(this.backwardLineGuide);
  },
  detachForwardLineGuide: function detachForwardLineGuide() {
    this.forwardLineGuide.setLatLngs([]);
    this.editLayer.removeLayer(this.forwardLineGuide);
  },
  detachBackwardLineGuide: function detachBackwardLineGuide() {
    this.backwardLineGuide.setLatLngs([]);
    this.editLayer.removeLayer(this.backwardLineGuide);
  },
  blockEvents: function blockEvents() {
    // Hack: force map not to listen to other layers events while drawing.
    if (!this._oldTargets) {
      this._oldTargets = this.map._targets;
      this.map._targets = {};
    }
  },
  unblockEvents: function unblockEvents() {
    if (this._oldTargets) {
      // Reset, but keep targets created while drawing.
      this.map._targets = external_L_default.a.extend(this.map._targets, this._oldTargets);
      delete this._oldTargets;
    }
  },
  registerForDrawing: function registerForDrawing(editor) {
    if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);
    this.blockEvents();
    editor.reset(); // Make sure editor tools still receive events.

    this._drawingEditor = editor;
    this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);
    this.map.on('mousedown', this.onMousedown, this);
    this.map.on('mouseup', this.onMouseup, this);
    external_L_default.a.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);
    this.defaultMapCursor = this.map._container.style.cursor;
    this.map._container.style.cursor = this.options.drawingCursor;
  },
  unregisterForDrawing: function unregisterForDrawing(editor) {
    this.unblockEvents();
    external_L_default.a.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);
    this.map._container.style.cursor = this.defaultMapCursor;
    editor = editor || this._drawingEditor;
    if (!editor) return;
    this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);
    this.map.off('mousedown', this.onMousedown, this);
    this.map.off('mouseup', this.onMouseup, this);
    if (editor !== this._drawingEditor) return;
    delete this._drawingEditor;
    if (editor._drawing) editor.cancelDrawing();
  },
  onMousedown: function onMousedown(e) {
    if (e.originalEvent.which != 1) return;
    this._mouseDown = e;

    this._drawingEditor.onDrawingMouseDown(e);
  },
  onMouseup: function onMouseup(e) {
    if (this._mouseDown) {
      var editor = this._drawingEditor,
          mouseDown = this._mouseDown;
      this._mouseDown = null;
      editor.onDrawingMouseUp(e);
      if (this._drawingEditor !== editor) return; // onDrawingMouseUp may call unregisterFromDrawing.

      var origin = external_L_default.a.point(mouseDown.originalEvent.clientX, mouseDown.originalEvent.clientY);
      var distance = external_L_default.a.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);
      if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);
    }
  },
  // 🍂section Public methods
  // You will generally access them by the `map.editTools`
  // instance:
  //
  // `map.editTools.startPolyline();`
  // 🍂method drawing(): boolean
  // Return true if any drawing action is ongoing.
  drawing: function drawing() {
    return this._drawingEditor && this._drawingEditor.drawing();
  },
  // 🍂method stopDrawing()
  // When you need to stop any ongoing drawing, without needing to know which editor is active.
  stopDrawing: function stopDrawing() {
    this.unregisterForDrawing();
  },
  // 🍂method commitDrawing()
  // When you need to commit any ongoing drawing, without needing to know which editor is active.
  commitDrawing: function commitDrawing(e) {
    if (!this._drawingEditor) return;

    this._drawingEditor.commitDrawing(e);
  },
  connectCreatedToMap: function connectCreatedToMap(layer) {
    return this.featuresLayer.addLayer(layer);
  },
  // 🍂method startPolyline(latlng: L.LatLng, options: hash): L.Polyline
  // Start drawing a Polyline. If `latlng` is given, a first point will be added. In any case, continuing on user click.
  // If `options` is given, it will be passed to the Polyline class constructor.
  startPolyline: function startPolyline(latlng, options) {
    var line = this.createPolyline([], options);
    line.enableEdit(this.map).newShape(latlng);
    return line;
  },
  // 🍂method startPolygon(latlng: L.LatLng, options: hash): L.Polygon
  // Start drawing a Polygon. If `latlng` is given, a first point will be added. In any case, continuing on user click.
  // If `options` is given, it will be passed to the Polygon class constructor.
  startPolygon: function startPolygon(latlng, options) {
    var polygon = this.createPolygon([], options);
    polygon.enableEdit(this.map).newShape(latlng);
    return polygon;
  },
  // 🍂method startMarker(latlng: L.LatLng, options: hash): L.Marker
  // Start adding a Marker. If `latlng` is given, the Marker will be shown first at this point.
  // In any case, it will follow the user mouse, and will have a final `latlng` on next click (or touch).
  // If `options` is given, it will be passed to the Marker class constructor.
  startMarker: function startMarker(latlng, options) {
    latlng = latlng || this.map.getCenter().clone();
    var marker = this.createMarker(latlng, options);
    marker.enableEdit(this.map).startDrawing();
    return marker;
  },
  // 🍂method startRectangle(latlng: L.LatLng, options: hash): L.Rectangle
  // Start drawing a Rectangle. If `latlng` is given, the Rectangle anchor will be added. In any case, continuing on user drag.
  // If `options` is given, it will be passed to the Rectangle class constructor.
  startRectangle: function startRectangle(latlng, options) {
    var corner = latlng || external_L_default.a.latLng([0, 0]);
    var bounds = new external_L_default.a.LatLngBounds(corner, corner);
    var rectangle = this.createRectangle(bounds, options);
    rectangle.enableEdit(this.map).startDrawing();
    return rectangle;
  },
  // 🍂method startCircle(latlng: L.LatLng, options: hash): L.Circle
  // Start drawing a Circle. If `latlng` is given, the Circle anchor will be added. In any case, continuing on user drag.
  // If `options` is given, it will be passed to the Circle class constructor.
  startCircle: function startCircle(latlng, options) {
    latlng = latlng || this.map.getCenter().clone();
    var circle = this.createCircle(latlng, options);
    circle.enableEdit(this.map).startDrawing();
    return circle;
  },
  startHole: function startHole(editor, latlng) {
    editor.newHole(latlng);
  },
  createLayer: function createLayer(klass, latlngs, options) {
    options = external_L_default.a.Util.extend({
      editOptions: {
        editTools: this
      }
    }, options);
    var layer = new klass(latlngs, options); // 🍂namespace Editable
    // 🍂event editable:created: LayerEvent
    // Fired when a new feature (Marker, Polyline…) is created.

    this.fireAndForward('editable:created', {
      layer: layer
    });
    return layer;
  },
  createPolyline: function createPolyline(latlngs, options) {
    return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);
  },
  createPolygon: function createPolygon(latlngs, options) {
    return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);
  },
  createMarker: function createMarker(latlng, options) {
    return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);
  },
  createRectangle: function createRectangle(bounds, options) {
    return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);
  },
  createCircle: function createCircle(latlng, options) {
    return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);
  }
});
external_L_default.a.extend(Editable, {
  makeCancellable: function makeCancellable(e) {
    e.cancel = function () {
      e._cancelled = true;
    };
  }
});
external_L_default.a.Map.mergeOptions({
  // 🍂namespace Map
  // 🍂section Map Options
  // 🍂option editToolsClass: class = L.Editable
  // Class to be used as vertex, for path editing.
  editToolsClass: Editable,
  // 🍂option editable: boolean = false
  // Whether to create a L.Editable instance at map init.
  editable: false,
  // 🍂option editOptions: hash = {}
  // Options to pass to L.Editable when instantiating.
  editOptions: {}
});
external_L_default.a.Map.addInitHook(function () {
  this.whenReady(function () {
    if (this.options.editable) {
      this.editTools = new this.options.editToolsClass(this, this.options.editOptions);
    }
  });
});
Editable.mergeOptions({
  // Class to be used as vertex, for path editing.
  vertexMarkerClass: editable_VertexMarker,
  // Class to be used as middle vertex, pulled by the user to create a new point in the middle of a path.
  middleMarkerClass: editable_MiddleMarker
});

external_L_default.a.LatLng.prototype.update = function (latlng) {
  latlng = external_L_default.a.latLng(latlng);
  this.lat = latlng.lat;
  this.lng = latlng.lng;
};

var isFlat = external_L_default.a.LineUtil.isFlat || external_L_default.a.LineUtil._flat || external_L_default.a.Polyline._flat; // <=> 1.1 compat.

var EditableMixin = {
  createEditor: function createEditor(map) {
    map = map || this._map;
    var tools = (this.options.editOptions || {}).editTools || map.editTools;
    if (!tools) throw Error('Unable to detect Editable instance.');
    var Klass = this.options.editorClass || this.getEditorClass(tools);
    return new Klass(map, this, this.options.editOptions);
  },
  // 🍂method enableEdit(map?: L.Map): this.editor
  // Enable editing, by creating an editor if not existing, and then calling `enable` on it.
  enableEdit: function enableEdit(map) {
    if (!this.editor) this.createEditor(map);
    this.editor.enable();
    return this.editor;
  },
  // 🍂method editEnabled(): boolean
  // Return true if current instance has an editor attached, and this editor is enabled.
  editEnabled: function editEnabled() {
    return this.editor && this.editor.enabled();
  },
  // 🍂method disableEdit()
  // Disable editing, also remove the editor property reference.
  disableEdit: function disableEdit() {
    if (this.editor) {
      this.editor.disable();
      delete this.editor;
    }
  },
  // 🍂method toggleEdit()
  // Enable or disable editing, according to current status.
  toggleEdit: function toggleEdit() {
    if (this.editEnabled()) this.disableEdit();else this.enableEdit();
  },
  _onEditableAdd: function _onEditableAdd() {
    if (this.editor) this.enableEdit();
  }
};

var keepEditable = function keepEditable() {
  // Make sure you can remove/readd an editable layer.
  this.on('add', this._onEditableAdd);
};

/* harmony default export */ var editable_Editable = (Editable);

// CONCATENATED MODULE: ./src/control/editable/BaseEditor.js

 // 🍂namespace Editable; 🍂class BaseEditor
// When editing a feature (Marker, Polyline…), an editor is attached to it. This
// editor basically knows how to handle the edition.

var BaseEditor = external_L_default.a.Handler.extend({
  initialize: function initialize(map, feature, options) {
    external_L_default.a.setOptions(this, options);
    this.map = map;
    this.feature = feature;
    this.feature.editor = this;
    this.editLayer = new external_L_default.a.LayerGroup();
    this.tools = this.options.editTools || map.editTools;
  },
  // 🍂method enable(): this
  // Set up the drawing tools for the feature to be editable.
  addHooks: function addHooks() {
    if (this.isConnected()) this.onFeatureAdd();else this.feature.once('add', this.onFeatureAdd, this);
    this.onEnable();
    this.feature.on(this._getEvents(), this);
  },
  // 🍂method disable(): this
  // Remove the drawing tools for the feature.
  removeHooks: function removeHooks() {
    this.feature.off(this._getEvents(), this);
    if (this.feature.dragging) this.feature.dragging.disable();
    this.editLayer.clearLayers();
    this.tools.editLayer.removeLayer(this.editLayer);
    this.onDisable();
    if (this._drawing) this.cancelDrawing();
  },
  // 🍂method drawing(): boolean
  // Return true if any drawing action is ongoing with this editor.
  drawing: function drawing() {
    return !!this._drawing;
  },
  reset: function reset() {},
  onFeatureAdd: function onFeatureAdd() {
    this.tools.editLayer.addLayer(this.editLayer);
    if (this.feature.dragging) this.feature.dragging.enable();
  },
  hasMiddleMarkers: function hasMiddleMarkers() {
    return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;
  },
  fireAndForward: function fireAndForward(type, e) {
    e = e || {};
    e.layer = this.feature;
    this.feature.fire(type, e);
    this.tools.fireAndForward(type, e);
  },
  onEnable: function onEnable() {
    // 🍂namespace Editable
    // 🍂event editable:enable: Event
    // Fired when an existing feature is ready to be edited.
    this.fireAndForward('editable:enable');
  },
  onDisable: function onDisable() {
    // 🍂namespace Editable
    // 🍂event editable:disable: Event
    // Fired when an existing feature is not ready anymore to be edited.
    this.fireAndForward('editable:disable');
  },
  onEditing: function onEditing() {
    // 🍂namespace Editable
    // 🍂event editable:editing: Event
    // Fired as soon as any change is made to the feature geometry.
    this.fireAndForward('editable:editing');
  },
  onStartDrawing: function onStartDrawing() {
    // 🍂namespace Editable
    // 🍂section Drawing events
    // 🍂event editable:drawing:start: Event
    // Fired when a feature is to be drawn.
    this.fireAndForward('editable:drawing:start');
  },
  onEndDrawing: function onEndDrawing() {
    // 🍂namespace Editable
    // 🍂section Drawing events
    // 🍂event editable:drawing:end: Event
    // Fired when a feature is not drawn anymore.
    this.fireAndForward('editable:drawing:end');
  },
  onCancelDrawing: function onCancelDrawing() {
    // 🍂namespace Editable
    // 🍂section Drawing events
    // 🍂event editable:drawing:cancel: Event
    // Fired when user cancel drawing while a feature is being drawn.
    this.fireAndForward('editable:drawing:cancel');
  },
  onCommitDrawing: function onCommitDrawing(e) {
    // 🍂namespace Editable
    // 🍂section Drawing events
    // 🍂event editable:drawing:commit: Event
    // Fired when user finish drawing a feature.
    this.fireAndForward('editable:drawing:commit', e);
  },
  onDrawingMouseDown: function onDrawingMouseDown(e) {
    // 🍂namespace Editable
    // 🍂section Drawing events
    // 🍂event editable:drawing:mousedown: Event
    // Fired when user `mousedown` while drawing.
    this.fireAndForward('editable:drawing:mousedown', e);
  },
  onDrawingMouseUp: function onDrawingMouseUp(e) {
    // 🍂namespace Editable
    // 🍂section Drawing events
    // 🍂event editable:drawing:mouseup: Event
    // Fired when user `mouseup` while drawing.
    this.fireAndForward('editable:drawing:mouseup', e);
  },
  startDrawing: function startDrawing() {
    if (!this._drawing) this._drawing = editable_Editable.FORWARD;
    this.tools.registerForDrawing(this);
    this.onStartDrawing();
  },
  commitDrawing: function commitDrawing(e) {
    this.onCommitDrawing(e);
    this.endDrawing();
  },
  cancelDrawing: function cancelDrawing() {
    // If called during a vertex drag, the vertex will be removed before
    // the mouseup fires on it. This is a workaround. Maybe better fix is
    // To have L.Draggable reset it's status on disable (Leaflet side).
    external_L_default.a.Draggable._dragging = false;
    this.onCancelDrawing();
    this.endDrawing();
  },
  endDrawing: function endDrawing() {
    this._drawing = false;
    this.tools.unregisterForDrawing(this);
    this.onEndDrawing();
  },
  onDrawingClick: function onDrawingClick(e) {
    if (!this.drawing()) return;
    editable_Editable.makeCancellable(e); // 🍂namespace Editable
    // 🍂section Drawing events
    // 🍂event editable:drawing:click: CancelableEvent
    // Fired when user `click` while drawing, before any internal action is being processed.

    this.fireAndForward('editable:drawing:click', e);
    if (e._cancelled) return;
    if (!this.isConnected()) this.connect(e);
    this.processDrawingClick(e);
  },
  isConnected: function isConnected() {
    return this.map.hasLayer(this.feature);
  },
  connect: function connect() {
    this.tools.connectCreatedToMap(this.feature);
    this.tools.editLayer.addLayer(this.editLayer);
  },
  onMove: function onMove(e) {
    // 🍂namespace Editable
    // 🍂section Drawing events
    // 🍂event editable:drawing:move: Event
    // Fired when `move` mouse while drawing, while dragging a marker, and while dragging a vertex.
    this.fireAndForward('editable:drawing:move', e);
  },
  onDrawingMouseMove: function onDrawingMouseMove(e) {
    this.onMove(e);
  },
  _getEvents: function _getEvents() {
    return {
      dragstart: this.onDragStart,
      drag: this.onDrag,
      dragend: this.onDragEnd,
      remove: this.disable
    };
  },
  onDragStart: function onDragStart(e) {
    this.onEditing(); // 🍂namespace Editable
    // 🍂event editable:dragstart: Event
    // Fired before a path feature is dragged.

    this.fireAndForward('editable:dragstart', e);
  },
  onDrag: function onDrag(e) {
    this.onMove(e); // 🍂namespace Editable
    // 🍂event editable:drag: Event
    // Fired when a path feature is being dragged.

    this.fireAndForward('editable:drag', e);
  },
  onDragEnd: function onDragEnd(e) {
    // 🍂namespace Editable
    // 🍂event editable:dragend: Event
    // Fired after a path feature has been dragged.
    this.fireAndForward('editable:dragend', e);
  }
});
/* harmony default export */ var editable_BaseEditor = (BaseEditor);
// CONCATENATED MODULE: ./src/control/editable/MarkerEditor.js


 // 🍂namespace Editable; 🍂class MarkerEditor
// 🍂inherits BaseEditor
// Editor for Marker.

var MarkerEditor = editable_BaseEditor.extend({
  addHooks: function addHooks() {
    editable_BaseEditor.prototype.addHooks.call(this);

    this._toggleMarkerHighlight();
  },
  removeHooks: function removeHooks() {
    editable_BaseEditor.prototype.removeHooks.call(this);

    this._toggleMarkerHighlight();
  },
  onDrawingMouseMove: function onDrawingMouseMove(e) {
    editable_BaseEditor.prototype.onDrawingMouseMove.call(this, e);
    if (this._drawing) this.feature.setLatLng(e.latlng);
  },
  processDrawingClick: function processDrawingClick(e) {
    // 🍂namespace Editable
    // 🍂section Drawing events
    // 🍂event editable:drawing:clicked: Event
    // Fired when user `click` while drawing, after all internal actions.
    this.fireAndForward('editable:drawing:clicked', e);
    this.commitDrawing(e);
  },
  connect: function connect(e) {
    // On touch, the latlng has not been updated because there is
    // no mousemove.
    if (e) this.feature._latlng = e.latlng;
    editable_BaseEditor.prototype.connect.call(this, e);
  },
  _toggleMarkerHighlight: function _toggleMarkerHighlight() {
    var icon = this.feature._icon; // Don't do anything if this layer is a marker but doesn't have an icon. Markers
    // should usually have icons. If using Leaflet.draw with Leaflet.markercluster there
    // is a chance that a marker doesn't.

    if (!icon) {
      return;
    } // This is quite naughty, but I don't see another way of doing it. (short of setting a new icon)


    icon.style.display = 'none';

    if (external_L_default.a.DomUtil.hasClass(icon, 'leaflet-edit-marker-selected')) {
      external_L_default.a.DomUtil.removeClass(icon, 'leaflet-edit-marker-selected'); // Offset as the border will make the icon move.

      this._offsetMarker(icon, -3);
    } else {
      external_L_default.a.DomUtil.addClass(icon, 'leaflet-edit-marker-selected'); // Offset as the border will make the icon move.

      this._offsetMarker(icon, 3);
    }

    icon.style.display = '';
  },
  _offsetMarker: function _offsetMarker(icon, offset) {
    var iconMarginTop = parseInt(icon.style.marginTop, 10) - offset,
        iconMarginLeft = parseInt(icon.style.marginLeft, 10) - offset;
    icon.style.marginTop = iconMarginTop + 'px';
    icon.style.marginLeft = iconMarginLeft + 'px';
  }
});
var MarkerMixin = {
  getEditorClass: function getEditorClass(tools) {
    return tools && tools.options.markerEditorClass ? tools.options.markerEditorClass : MarkerEditor;
  }
};

if (external_L_default.a.Marker) {
  external_L_default.a.Marker.include(EditableMixin);
  external_L_default.a.Marker.include(MarkerMixin);
  external_L_default.a.Marker.addInitHook(keepEditable);
}

/* harmony default export */ var editable_MarkerEditor = (MarkerEditor);
// CONCATENATED MODULE: ./src/control/editable/PathEditor.js

 // 🍂namespace Editable; 🍂class PathEditor
// 🍂inherits BaseEditor
// Base class for all path editors.

var PathEditor = editable_BaseEditor.extend({
  CLOSED: false,
  MIN_VERTEX: 2,
  addHooks: function addHooks() {
    editable_BaseEditor.prototype.addHooks.call(this);
    if (this.feature) this.initVertexMarkers();
    return this;
  },
  initVertexMarkers: function initVertexMarkers(latlngs) {
    if (!this.enabled()) return;
    latlngs = latlngs || this.getLatLngs();
    if (isFlat(latlngs)) this.addVertexMarkers(latlngs);else for (var i = 0; i < latlngs.length; i++) {
      this.initVertexMarkers(latlngs[i]);
    }
  },
  getLatLngs: function getLatLngs() {
    return this.feature.getLatLngs();
  },
  // 🍂method reset()
  // Rebuild edit elements (Vertex, MiddleMarker, etc.).
  reset: function reset() {
    this.editLayer.clearLayers();
    this.initVertexMarkers();
  },
  addVertexMarker: function addVertexMarker(latlng, latlngs) {
    return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);
  },
  onNewVertex: function onNewVertex(vertex) {
    // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:new: VertexEvent
    // Fired when a new vertex is created.
    this.fireAndForward('editable:vertex:new', {
      latlng: vertex.latlng,
      vertex: vertex
    });
  },
  addVertexMarkers: function addVertexMarkers(latlngs) {
    for (var i = 0; i < latlngs.length; i++) {
      this.addVertexMarker(latlngs[i], latlngs);
    }
  },
  refreshVertexMarkers: function refreshVertexMarkers(latlngs) {
    latlngs = latlngs || this.getDefaultLatLngs();

    for (var i = 0; i < latlngs.length; i++) {
      latlngs[i].__vertex.update();
    }
  },
  addMiddleMarker: function addMiddleMarker(left, right, latlngs) {
    return new this.tools.options.middleMarkerClass(left, right, latlngs, this);
  },
  onVertexMarkerClick: function onVertexMarkerClick(e) {
    editable_Editable.makeCancellable(e); // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:click: CancelableVertexEvent
    // Fired when a `click` is issued on a vertex, before any internal action is being processed.

    this.fireAndForward('editable:vertex:click', e);
    if (e._cancelled) return;
    if (this.tools.drawing() && this.tools._drawingEditor !== this) return;
    var index = e.vertex.getIndex(),
        commit;

    if (e.originalEvent.ctrlKey) {
      this.onVertexMarkerCtrlClick(e);
    } else if (e.originalEvent.altKey) {
      this.onVertexMarkerAltClick(e);
    } else if (e.originalEvent.shiftKey) {
      this.onVertexMarkerShiftClick(e);
    } else if (e.originalEvent.metaKey) {
      this.onVertexMarkerMetaKeyClick(e);
    } else if (index === e.vertex.getLastIndex() && this._drawing === editable_Editable.FORWARD) {
      if (index >= this.MIN_VERTEX - 1) commit = true;
    } else if (index === 0 && this._drawing === editable_Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {
      commit = true;
    } else if (index === 0 && this._drawing === editable_Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {
      commit = true; // Allow to close on first point also for polygons
    } else {
      this.onVertexRawMarkerClick(e);
    } // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:clicked: VertexEvent
    // Fired when a `click` is issued on a vertex, after all internal actions.


    this.fireAndForward('editable:vertex:clicked', e);
    if (commit) this.commitDrawing(e);
  },
  onVertexRawMarkerClick: function onVertexRawMarkerClick(e) {
    // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:rawclick: CancelableVertexEvent
    // Fired when a `click` is issued on a vertex without any special key and without being in drawing mode.
    this.fireAndForward('editable:vertex:rawclick', e);
    if (e._cancelled) return;
    if (!this.vertexCanBeDeleted(e.vertex)) return;
    e.vertex["delete"]();
  },
  vertexCanBeDeleted: function vertexCanBeDeleted(vertex) {
    return vertex.latlngs.length > this.MIN_VERTEX;
  },
  onVertexDeleted: function onVertexDeleted(e) {
    // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:deleted: VertexEvent
    // Fired after a vertex has been deleted by user.
    this.fireAndForward('editable:vertex:deleted', e);
  },
  onVertexMarkerCtrlClick: function onVertexMarkerCtrlClick(e) {
    // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:ctrlclick: VertexEvent
    // Fired when a `click` with `ctrlKey` is issued on a vertex.
    this.fireAndForward('editable:vertex:ctrlclick', e);
  },
  onVertexMarkerShiftClick: function onVertexMarkerShiftClick(e) {
    // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:shiftclick: VertexEvent
    // Fired when a `click` with `shiftKey` is issued on a vertex.
    this.fireAndForward('editable:vertex:shiftclick', e);
  },
  onVertexMarkerMetaKeyClick: function onVertexMarkerMetaKeyClick(e) {
    // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:metakeyclick: VertexEvent
    // Fired when a `click` with `metaKey` is issued on a vertex.
    this.fireAndForward('editable:vertex:metakeyclick', e);
  },
  onVertexMarkerAltClick: function onVertexMarkerAltClick(e) {
    // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:altclick: VertexEvent
    // Fired when a `click` with `altKey` is issued on a vertex.
    this.fireAndForward('editable:vertex:altclick', e);
  },
  onVertexMarkerContextMenu: function onVertexMarkerContextMenu(e) {
    // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:contextmenu: VertexEvent
    // Fired when a `contextmenu` is issued on a vertex.
    this.fireAndForward('editable:vertex:contextmenu', e);
  },
  onVertexMarkerMouseDown: function onVertexMarkerMouseDown(e) {
    // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:mousedown: VertexEvent
    // Fired when user `mousedown` a vertex.
    this.fireAndForward('editable:vertex:mousedown', e);
  },
  onVertexMarkerMouseOver: function onVertexMarkerMouseOver(e) {
    // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:mouseover: VertexEvent
    // Fired when a user's mouse enters the vertex
    this.fireAndForward('editable:vertex:mouseover', e);
  },
  onVertexMarkerMouseOut: function onVertexMarkerMouseOut(e) {
    // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:mouseout: VertexEvent
    // Fired when a user's mouse leaves the vertex
    this.fireAndForward('editable:vertex:mouseout', e);
  },
  onMiddleMarkerMouseDown: function onMiddleMarkerMouseDown(e) {
    // 🍂namespace Editable
    // 🍂section MiddleMarker events
    // 🍂event editable:middlemarker:mousedown: VertexEvent
    // Fired when user `mousedown` a middle marker.
    this.fireAndForward('editable:middlemarker:mousedown', e);
  },
  onVertexMarkerDrag: function onVertexMarkerDrag(e) {
    this.onMove(e);
    if (this.feature._bounds) this.extendBounds(e); // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:drag: VertexEvent
    // Fired when a vertex is dragged by user.

    this.fireAndForward('editable:vertex:drag', e);
  },
  onVertexMarkerDragStart: function onVertexMarkerDragStart(e) {
    // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:dragstart: VertexEvent
    // Fired before a vertex is dragged by user.
    this.fireAndForward('editable:vertex:dragstart', e);
  },
  onVertexMarkerDragEnd: function onVertexMarkerDragEnd(e) {
    // 🍂namespace Editable
    // 🍂section Vertex events
    // 🍂event editable:vertex:dragend: VertexEvent
    // Fired after a vertex is dragged by user.
    this.fireAndForward('editable:vertex:dragend', e);
  },
  setDrawnLatLngs: function setDrawnLatLngs(latlngs) {
    this._drawnLatLngs = latlngs || this.getDefaultLatLngs();
  },
  startDrawing: function startDrawing() {
    if (!this._drawnLatLngs) this.setDrawnLatLngs();
    editable_BaseEditor.prototype.startDrawing.call(this);
  },
  startDrawingForward: function startDrawingForward() {
    this.startDrawing();
  },
  endDrawing: function endDrawing() {
    this.tools.detachForwardLineGuide();
    this.tools.detachBackwardLineGuide();
    if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);
    editable_BaseEditor.prototype.endDrawing.call(this);
    delete this._drawnLatLngs;
  },
  addLatLng: function addLatLng(latlng) {
    if (this._drawing === editable_Editable.FORWARD) this._drawnLatLngs.push(latlng);else this._drawnLatLngs.unshift(latlng);

    this.feature._bounds.extend(latlng);

    var vertex = this.addVertexMarker(latlng, this._drawnLatLngs);
    this.onNewVertex(vertex);
    this.refresh();
  },
  newPointForward: function newPointForward(latlng) {
    this.addLatLng(latlng);
    this.tools.attachForwardLineGuide();
    this.tools.anchorForwardLineGuide(latlng);
  },
  newPointBackward: function newPointBackward(latlng) {
    this.addLatLng(latlng);
    this.tools.anchorBackwardLineGuide(latlng);
  },
  // 🍂namespace PathEditor
  // 🍂method push()
  // Programmatically add a point while drawing.
  push: function push(latlng) {
    if (!latlng) return console.error('L.Editable.PathEditor.push expect a valid latlng as parameter');
    if (this._drawing === editable_Editable.FORWARD) this.newPointForward(latlng);else this.newPointBackward(latlng);
  },
  removeLatLng: function removeLatLng(latlng) {
    latlng.__vertex["delete"]();

    this.refresh();
  },
  // 🍂method pop(): L.LatLng or null
  // Programmatically remove last point (if any) while drawing.
  pop: function pop() {
    if (this._drawnLatLngs.length <= 1) return;
    var latlng;
    if (this._drawing === editable_Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];else latlng = this._drawnLatLngs[0];
    this.removeLatLng(latlng);
    if (this._drawing === editable_Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);
    return latlng;
  },
  processDrawingClick: function processDrawingClick(e) {
    if (e.vertex && e.vertex.editor === this) return;
    if (this._drawing === editable_Editable.FORWARD) this.newPointForward(e.latlng);else this.newPointBackward(e.latlng);
    this.fireAndForward('editable:drawing:clicked', e);
  },
  onDrawingMouseMove: function onDrawingMouseMove(e) {
    editable_BaseEditor.prototype.onDrawingMouseMove.call(this, e);

    if (this._drawing) {
      this.tools.moveForwardLineGuide(e.latlng);
      this.tools.moveBackwardLineGuide(e.latlng);
    }
  },
  refresh: function refresh() {
    this.feature.redraw();
    this.onEditing();
  },
  // 🍂namespace PathEditor
  // 🍂method newShape(latlng?: L.LatLng)
  // Add a new shape (Polyline, Polygon) in a multi, and setup up drawing tools to draw it;
  // if optional `latlng` is given, start a path at this point.
  newShape: function newShape(latlng) {
    var shape = this.addNewEmptyShape();
    if (!shape) return;
    this.setDrawnLatLngs(shape[0] || shape); // Polygon or polyline

    this.startDrawingForward(); // 🍂namespace Editable
    // 🍂section Shape events
    // 🍂event editable:shape:new: ShapeEvent
    // Fired when a new shape is created in a multi (Polygon or Polyline).

    this.fireAndForward('editable:shape:new', {
      shape: shape
    });
    if (latlng) this.newPointForward(latlng);
  },
  deleteShape: function deleteShape(shape, latlngs) {
    var e = {
      shape: shape
    };
    editable_Editable.makeCancellable(e); // 🍂namespace Editable
    // 🍂section Shape events
    // 🍂event editable:shape:delete: CancelableShapeEvent
    // Fired before a new shape is deleted in a multi (Polygon or Polyline).

    this.fireAndForward('editable:shape:delete', e);
    if (e._cancelled) return;
    shape = this._deleteShape(shape, latlngs);
    if (this.ensureNotFlat) this.ensureNotFlat(); // Polygon.

    this.feature.setLatLngs(this.getLatLngs()); // Force bounds reset.

    this.refresh();
    this.reset(); // 🍂namespace Editable
    // 🍂section Shape events
    // 🍂event editable:shape:deleted: ShapeEvent
    // Fired after a new shape is deleted in a multi (Polygon or Polyline).

    this.fireAndForward('editable:shape:deleted', {
      shape: shape
    });
    return shape;
  },
  _deleteShape: function _deleteShape(shape, latlngs) {
    latlngs = latlngs || this.getLatLngs();
    if (!latlngs.length) return;

    var self = this,
        inplaceDelete = function inplaceDelete(latlngs, shape) {
      // Called when deleting a flat latlngs
      shape = latlngs.splice(0, Number.MAX_VALUE);
      return shape;
    },
        spliceDelete = function spliceDelete(latlngs, shape) {
      // Called when removing a latlngs inside an array
      latlngs.splice(latlngs.indexOf(shape), 1);
      if (!latlngs.length) self._deleteShape(latlngs);
      return shape;
    };

    if (latlngs === shape) return inplaceDelete(latlngs, shape);

    for (var i = 0; i < latlngs.length; i++) {
      if (latlngs[i] === shape) return spliceDelete(latlngs, shape);else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);
    }
  },
  // 🍂namespace PathEditor
  // 🍂method deleteShapeAt(latlng: L.LatLng): Array
  // Remove a path shape at the given `latlng`.
  deleteShapeAt: function deleteShapeAt(latlng) {
    var shape = this.feature.shapeAt(latlng);
    if (shape) return this.deleteShape(shape);
  },
  // 🍂method appendShape(shape: Array)
  // Append a new shape to the Polygon or Polyline.
  appendShape: function appendShape(shape) {
    this.insertShape(shape);
  },
  // 🍂method prependShape(shape: Array)
  // Prepend a new shape to the Polygon or Polyline.
  prependShape: function prependShape(shape) {
    this.insertShape(shape, 0);
  },
  // 🍂method insertShape(shape: Array, index: int)
  // Insert a new shape to the Polygon or Polyline at given index (default is to append).
  insertShape: function insertShape(shape, index) {
    this.ensureMulti();
    shape = this.formatShape(shape);
    if (typeof index === 'undefined') index = this.feature._latlngs.length;

    this.feature._latlngs.splice(index, 0, shape);

    this.feature.redraw();
    if (this._enabled) this.reset();
  },
  extendBounds: function extendBounds(e) {
    this.feature._bounds.extend(e.vertex.latlng);
  },
  onDragStart: function onDragStart(e) {
    this.editLayer.clearLayers();
    editable_BaseEditor.prototype.onDragStart.call(this, e);
  },
  onDragEnd: function onDragEnd(e) {
    this.initVertexMarkers();
    editable_BaseEditor.prototype.onDragEnd.call(this, e);
  }
});
/* harmony default export */ var editable_PathEditor = (PathEditor);
// CONCATENATED MODULE: ./src/control/editable/PolylineEditor.js


 // 🍂namespace Editable; 🍂class PolylineEditor
// 🍂inherits PathEditor

var PolylineEditor = editable_PathEditor.extend({
  startDrawingBackward: function startDrawingBackward() {
    this._drawing = editable_Editable.BACKWARD;
    this.startDrawing();
  },
  // 🍂method continueBackward(latlngs?: Array)
  // Set up drawing tools to continue the line backward.
  continueBackward: function continueBackward(latlngs) {
    if (this.drawing()) return;
    latlngs = latlngs || this.getDefaultLatLngs();
    this.setDrawnLatLngs(latlngs);

    if (latlngs.length > 0) {
      this.tools.attachBackwardLineGuide();
      this.tools.anchorBackwardLineGuide(latlngs[0]);
    }

    this.startDrawingBackward();
  },
  // 🍂method continueForward(latlngs?: Array)
  // Set up drawing tools to continue the line forward.
  continueForward: function continueForward(latlngs) {
    if (this.drawing()) return;
    latlngs = latlngs || this.getDefaultLatLngs();
    this.setDrawnLatLngs(latlngs);

    if (latlngs.length > 0) {
      this.tools.attachForwardLineGuide();
      this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);
    }

    this.startDrawingForward();
  },
  getDefaultLatLngs: function getDefaultLatLngs(latlngs) {
    latlngs = latlngs || this.feature._latlngs;
    if (!latlngs.length || latlngs[0] instanceof external_L_default.a.LatLng) return latlngs;else return this.getDefaultLatLngs(latlngs[0]);
  },
  ensureMulti: function ensureMulti() {
    if (this.feature._latlngs.length && isFlat(this.feature._latlngs)) {
      this.feature._latlngs = [this.feature._latlngs];
    }
  },
  addNewEmptyShape: function addNewEmptyShape() {
    if (this.feature._latlngs.length) {
      var shape = [];
      this.appendShape(shape);
      return shape;
    } else {
      return this.feature._latlngs;
    }
  },
  formatShape: function formatShape(shape) {
    if (isFlat(shape)) return shape;else if (shape[0]) return this.formatShape(shape[0]);
  },
  // 🍂method splitShape(latlngs?: Array, index: int)
  // Split the given `latlngs` shape at index `index` and integrate new shape in instance `latlngs`.
  splitShape: function splitShape(shape, index) {
    if (!index || index >= shape.length - 1) return;
    this.ensureMulti();

    var shapeIndex = this.feature._latlngs.indexOf(shape);

    if (shapeIndex === -1) return;
    var first = shape.slice(0, index + 1),
        second = shape.slice(index); // We deal with reference, we don't want twice the same latlng around.

    second[0] = external_L_default.a.latLng(second[0].lat, second[0].lng, second[0].alt);

    this.feature._latlngs.splice(shapeIndex, 1, first, second);

    this.refresh();
    this.reset();
  }
});
var PolylineMixin = {
  getEditorClass: function getEditorClass(tools) {
    return tools && tools.options.polylineEditorClass ? tools.options.polylineEditorClass : PolylineEditor;
  },
  shapeAt: function shapeAt(latlng, latlngs) {
    // We can have those cases:
    // - latlngs are just a flat array of latlngs, use this
    // - latlngs is an array of arrays of latlngs, loop over
    var shape = null;
    latlngs = latlngs || this._latlngs;
    if (!latlngs.length) return shape;else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;else for (var i = 0; i < latlngs.length; i++) {
      if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];
    }
    return shape;
  },
  isInLatLngs: function isInLatLngs(l, latlngs) {
    if (!latlngs) return false;

    var i,
        k,
        len,
        part = [],
        p,
        w = this._clickTolerance();

    this._projectLatlngs(latlngs, part, this._pxBounds);

    part = part[0];
    p = this._map.latLngToLayerPoint(l);

    if (!this._pxBounds.contains(p)) {
      return false;
    }

    for (i = 1, len = part.length, k = 0; i < len; k = i++) {
      if (external_L_default.a.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {
        return true;
      }
    }

    return false;
  }
};

if (external_L_default.a.Polyline) {
  external_L_default.a.Polyline.include(EditableMixin);
  external_L_default.a.Polyline.include(PolylineMixin);
  external_L_default.a.Polyline.addInitHook(keepEditable);
}

/* harmony default export */ var editable_PolylineEditor = (PolylineEditor);
// CONCATENATED MODULE: ./src/control/editable/PolygonEditor.js


 // 🍂namespace Editable; 🍂class PolygonEditor
// 🍂inherits PathEditor

var PolygonEditor = editable_PathEditor.extend({
  CLOSED: true,
  MIN_VERTEX: 3,
  newPointForward: function newPointForward(latlng) {
    editable_PathEditor.prototype.newPointForward.call(this, latlng);
    if (!this.tools.backwardLineGuide._latlngs.length) this.tools.anchorBackwardLineGuide(latlng);
    if (this._drawnLatLngs.length === 2) this.tools.attachBackwardLineGuide();
  },
  addNewEmptyHole: function addNewEmptyHole(latlng) {
    this.ensureNotFlat();
    var latlngs = this.feature.shapeAt(latlng);
    if (!latlngs) return;
    var holes = [];
    latlngs.push(holes);
    return holes;
  },
  // 🍂method newHole(latlng?: L.LatLng, index: int)
  // Set up drawing tools for creating a new hole on the Polygon. If the `latlng` param is given, a first point is created.
  newHole: function newHole(latlng) {
    var holes = this.addNewEmptyHole(latlng);
    if (!holes) return;
    this.setDrawnLatLngs(holes);
    this.startDrawingForward();
    if (latlng) this.newPointForward(latlng);
  },
  addNewEmptyShape: function addNewEmptyShape() {
    if (this.feature._latlngs.length && this.feature._latlngs[0].length) {
      var shape = [];
      this.appendShape(shape);
      return shape;
    } else {
      return this.feature._latlngs;
    }
  },
  ensureMulti: function ensureMulti() {
    if (this.feature._latlngs.length && isFlat(this.feature._latlngs[0])) {
      this.feature._latlngs = [this.feature._latlngs];
    }
  },
  ensureNotFlat: function ensureNotFlat() {
    if (!this.feature._latlngs.length || isFlat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];
  },
  vertexCanBeDeleted: function vertexCanBeDeleted(vertex) {
    var parent = this.feature.parentShape(vertex.latlngs),
        idx = external_L_default.a.Util.indexOf(parent, vertex.latlngs);
    if (idx > 0) return true; // Holes can be totally deleted without removing the layer itself.

    return editable_PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);
  },
  getDefaultLatLngs: function getDefaultLatLngs() {
    if (!this.feature._latlngs.length) this.feature._latlngs.push([]);
    return this.feature._latlngs[0];
  },
  formatShape: function formatShape(shape) {
    // [[1, 2], [3, 4]] => must be nested
    // [] => must be nested
    // [[]] => is already nested
    if (isFlat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];else return shape;
  }
});
var PolygonMixin = {
  getEditorClass: function getEditorClass(tools) {
    return tools && tools.options.polygonEditorClass ? tools.options.polygonEditorClass : PolygonEditor;
  },
  shapeAt: function shapeAt(latlng, latlngs) {
    // We can have those cases:
    // - latlngs are just a flat array of latlngs, use this
    // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first
    // - latlngs is an array of arrays of arrays, this is a multi, loop over
    var shape = null;
    latlngs = latlngs || this._latlngs;
    if (!latlngs.length) return shape;else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;else if (isFlat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;else for (var i = 0; i < latlngs.length; i++) {
      if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];
    }
    return shape;
  },
  isInLatLngs: function isInLatLngs(l, latlngs) {
    var inside = false,
        l1,
        l2,
        j,
        k,
        len2;

    for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {
      l1 = latlngs[j];
      l2 = latlngs[k];

      if (l1.lat > l.lat !== l2.lat > l.lat && l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng) {
        inside = !inside;
      }
    }

    return inside;
  },
  parentShape: function parentShape(shape, latlngs) {
    latlngs = latlngs || this._latlngs;
    if (!latlngs) return;
    var idx = external_L_default.a.Util.indexOf(latlngs, shape);
    if (idx !== -1) return latlngs;

    for (var i = 0; i < latlngs.length; i++) {
      idx = external_L_default.a.Util.indexOf(latlngs[i], shape);
      if (idx !== -1) return latlngs[i];
    }
  }
};

if (external_L_default.a.Polygon) {
  external_L_default.a.Polygon.include(EditableMixin);
  external_L_default.a.Polygon.include(PolygonMixin);
}

/* harmony default export */ var editable_PolygonEditor = (PolygonEditor);
// CONCATENATED MODULE: ./src/control/editable/RectangleEditor.js


 // 🍂namespace Editable; 🍂class RectangleEditor
// 🍂inherits PathEditor

var RectangleEditor = editable_PathEditor.extend({
  CLOSED: true,
  MIN_VERTEX: 4,
  options: {
    skipMiddleMarkers: true
  },
  extendBounds: function extendBounds(e) {
    var index = e.vertex.getIndex(),
        next = e.vertex.getNext(),
        previous = e.vertex.getPrevious(),
        oppositeIndex = (index + 2) % 4,
        opposite = e.vertex.latlngs[oppositeIndex],
        bounds = new external_L_default.a.LatLngBounds(e.latlng, opposite); // Update latlngs by hand to preserve order.

    previous.latlng.update([e.latlng.lat, opposite.lng]);
    next.latlng.update([opposite.lat, e.latlng.lng]);
    this.updateBounds(bounds);
    this.refreshVertexMarkers();
  },
  onDrawingMouseDown: function onDrawingMouseDown(e) {
    editable_PathEditor.prototype.onDrawingMouseDown.call(this, e);
    this.connect();
    var latlngs = this.getDefaultLatLngs(); // L.Polygon._convertLatLngs removes last latlng if it equals first point,
    // which is the case here as all latlngs are [0, 0]

    if (latlngs.length === 3) latlngs.push(e.latlng);
    var bounds = new external_L_default.a.LatLngBounds(e.latlng, e.latlng);
    this.updateBounds(bounds);
    this.updateLatLngs(bounds);
    this.refresh();
    this.reset(); // Stop dragging map.
    // L.Draggable has two workflows:
    // - mousedown => mousemove => mouseup
    // - touchstart => touchmove => touchend
    // Problem: L.Map.Tap does not allow us to listen to touchstart, so we only
    // can deal with mousedown, but then when in a touch device, we are dealing with
    // simulated events (actually simulated by L.Map.Tap), which are no more taken
    // into account by L.Draggable.
    // Ref.: https://github.com/Leaflet/Leaflet.Editable/issues/103

    e.originalEvent._simulated = false;

    this.map.dragging._draggable._onUp(e.originalEvent); // Now transfer ongoing drag action to the bottom right corner.
    // Should we refine which corner will handle the drag according to
    // drag direction?


    latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);
  },
  onDrawingMouseUp: function onDrawingMouseUp(e) {
    this.commitDrawing(e);
    e.originalEvent._simulated = false;
    editable_PathEditor.prototype.onDrawingMouseUp.call(this, e);
  },
  onDrawingMouseMove: function onDrawingMouseMove(e) {
    e.originalEvent._simulated = false;
    editable_PathEditor.prototype.onDrawingMouseMove.call(this, e);
  },
  getDefaultLatLngs: function getDefaultLatLngs(latlngs) {
    return latlngs || this.feature._latlngs[0];
  },
  updateBounds: function updateBounds(bounds) {
    this.feature._bounds = bounds;
  },
  updateLatLngs: function updateLatLngs(bounds) {
    var latlngs = this.getDefaultLatLngs(),
        newLatlngs = this.feature._boundsToLatLngs(bounds); // Keep references.


    for (var i = 0; i < latlngs.length; i++) {
      latlngs[i].update(newLatlngs[i]);
    }
  }
});
var RectangleMixin = {
  getEditorClass: function getEditorClass(tools) {
    return tools && tools.options.rectangleEditorClass ? tools.options.rectangleEditorClass : RectangleEditor;
  }
};

if (external_L_default.a.Rectangle) {
  external_L_default.a.Rectangle.include(EditableMixin);
  external_L_default.a.Rectangle.include(RectangleMixin);
}

/* harmony default export */ var editable_RectangleEditor = (RectangleEditor);
// CONCATENATED MODULE: ./src/control/editable/CircleEditor.js


 // 🍂namespace Editable; 🍂class CircleEditor
// 🍂inherits PathEditor

var CircleEditor = editable_PathEditor.extend({
  MIN_VERTEX: 2,
  options: {
    skipMiddleMarkers: true
  },
  initialize: function initialize(map, feature, options) {
    editable_PathEditor.prototype.initialize.call(this, map, feature, options);
    this._resizeLatLng = this.computeResizeLatLng();
  },
  computeResizeLatLng: function computeResizeLatLng() {
    // While circle is not added to the map, _radius is not set.
    var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),
        point = this.map.project(this.feature._latlng);
    return this.map.unproject([point.x + delta, point.y - delta]);
  },
  updateResizeLatLng: function updateResizeLatLng() {
    this._resizeLatLng.update(this.computeResizeLatLng());

    this._resizeLatLng.__vertex.update();
  },
  getLatLngs: function getLatLngs() {
    return [this.feature._latlng, this._resizeLatLng];
  },
  getDefaultLatLngs: function getDefaultLatLngs() {
    return this.getLatLngs();
  },
  onVertexMarkerDrag: function onVertexMarkerDrag(e) {
    if (e.vertex.getIndex() === 1) this.resize(e);else this.updateResizeLatLng(e);
    editable_PathEditor.prototype.onVertexMarkerDrag.call(this, e);
  },
  resize: function resize(e) {
    var radius = this.feature._latlng.distanceTo(e.latlng);

    this.feature.setRadius(radius);
  },
  onDrawingMouseDown: function onDrawingMouseDown(e) {
    editable_PathEditor.prototype.onDrawingMouseDown.call(this, e);

    this._resizeLatLng.update(e.latlng);

    this.feature._latlng.update(e.latlng);

    this.connect(); // Stop dragging map.

    e.originalEvent._simulated = false;

    this.map.dragging._draggable._onUp(e.originalEvent); // Now transfer ongoing drag action to the radius handler.


    this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);
  },
  onDrawingMouseUp: function onDrawingMouseUp(e) {
    this.commitDrawing(e);
    e.originalEvent._simulated = false;
    editable_PathEditor.prototype.onDrawingMouseUp.call(this, e);
  },
  onDrawingMouseMove: function onDrawingMouseMove(e) {
    e.originalEvent._simulated = false;
    editable_PathEditor.prototype.onDrawingMouseMove.call(this, e);
  },
  onDrag: function onDrag(e) {
    editable_PathEditor.prototype.onDrag.call(this, e);
    this.feature.dragging.updateLatLng(this._resizeLatLng);
  }
});
var CircleMixin = {
  getEditorClass: function getEditorClass(tools) {
    return tools && tools.options.circleEditorClass ? tools.options.circleEditorClass : CircleEditor;
  }
};

if (external_L_default.a.Circle) {
  external_L_default.a.Circle.include(EditableMixin);
  external_L_default.a.Circle.include(CircleMixin);
}

/* harmony default export */ var editable_CircleEditor = (CircleEditor);
// CONCATENATED MODULE: ./src/control/editable/PathDraggable.js

/* A Draggable that does not update the element position
and takes care of only bubbling to targetted path in Canvas mode. */

var PathDraggable = external_L_default.a.Draggable.extend({
  initialize: function initialize(path) {
    this._path = path;
    this._canvas = path._map.getRenderer(path) instanceof external_L_default.a.Canvas;
    var element = this._canvas ? this._path._map.getRenderer(this._path)._container : this._path._path;
    external_L_default.a.Draggable.prototype.initialize.call(this, element, element, true);
  },
  _updatePosition: function _updatePosition() {
    var e = {
      originalEvent: this._lastEvent
    };
    this.fire('drag', e);
  },
  _onDown: function _onDown(e) {
    var first = e.touches ? e.touches[0] : e;
    this._startPoint = new external_L_default.a.Point(first.clientX, first.clientY);

    if (this._canvas && !this._path._containsPoint(this._path._map.mouseEventToLayerPoint(first))) {
      return;
    }

    external_L_default.a.Draggable.prototype._onDown.call(this, e);
  }
});
var PathDrag = external_L_default.a.Handler.extend({
  initialize: function initialize(path) {
    this._path = path;
  },
  getEvents: function getEvents() {
    return {
      dragstart: this._onDragStart,
      drag: this._onDrag,
      dragend: this._onDragEnd
    };
  },
  addHooks: function addHooks() {
    if (!this._draggable) {
      this._draggable = new PathDraggable(this._path);
    }

    this._draggable.on(this.getEvents(), this).enable();

    external_L_default.a.DomUtil.addClass(this._draggable._element, 'leaflet-path-draggable');
  },
  removeHooks: function removeHooks() {
    this._draggable.off(this.getEvents(), this).disable();

    external_L_default.a.DomUtil.removeClass(this._draggable._element, 'leaflet-path-draggable');
  },
  moved: function moved() {
    return this._draggable && this._draggable._moved;
  },
  _onDragStart: function _onDragStart() {
    this._startPoint = this._draggable._startPoint;

    this._path.closePopup().fire('movestart').fire('dragstart');
  },
  _onDrag: function _onDrag(e) {
    var path = this._path,
        event = e.originalEvent.touches && e.originalEvent.touches.length === 1 ? e.originalEvent.touches[0] : e.originalEvent,
        newPoint = external_L_default.a.point(event.clientX, event.clientY),
        latlng = path._map.layerPointToLatLng(newPoint);

    this._offset = newPoint.subtract(this._startPoint);
    this._startPoint = newPoint;

    this._path.eachLatLng(this.updateLatLng, this);

    path.redraw();
    e.latlng = latlng;
    e.offset = this._offset;
    path.fire('drag', e);
    e.latlng = this._path.getCenter ? this._path.getCenter() : this._path.getLatLng();
    path.fire('move', e);
  },
  _onDragEnd: function _onDragEnd(e) {
    if (this._path._bounds) this.resetBounds();

    this._path.fire('moveend').fire('dragend', e);
  },
  latLngToLayerPoint: function latLngToLayerPoint(latlng) {
    // Same as map.latLngToLayerPoint, but without the round().
    var projectedPoint = this._path._map.project(external_L_default.a.latLng(latlng));

    return projectedPoint._subtract(this._path._map.getPixelOrigin());
  },
  updateLatLng: function updateLatLng(latlng) {
    var oldPoint = this.latLngToLayerPoint(latlng);

    oldPoint._add(this._offset);

    var newLatLng = this._path._map.layerPointToLatLng(oldPoint);

    latlng.lat = newLatLng.lat;
    latlng.lng = newLatLng.lng;
  },
  resetBounds: function resetBounds() {
    this._path._bounds = new external_L_default.a.LatLngBounds();

    this._path.eachLatLng(function (latlng) {
      this._bounds.extend(latlng);
    });
  }
});
external_L_default.a.Path.include({
  eachLatLng: function eachLatLng(callback, context) {
    context = context || this;

    var loop = function loop(latlngs) {
      for (var i = 0; i < latlngs.length; i++) {
        if (external_L_default.a.Util.isArray(latlngs[i])) loop(latlngs[i]);else callback.call(context, latlngs[i]);
      }
    };

    loop(this.getLatLngs ? this.getLatLngs() : [this.getLatLng()]);
  }
});
external_L_default.a.Path.addInitHook(function () {
  this.dragging = new PathDrag(this);

  if (this.options.draggable) {
    this.once('add', function () {
      this.dragging.enable();
    });
  }
});
/* harmony default export */ var editable_PathDraggable = (PathDraggable);
// CONCATENATED MODULE: ./src/control/index.js








 // import EditMarker from "./draw/edit/EditMarker";
// import EditPolyVertices from './draw/edit/EditPolyVertices';
// import EditPoly from "./draw/edit/EditPoly";
// import EditRectangle from "./draw/edit/EditRectangle";
// import EditCircle from "./draw/edit/EditCircle"






















 // export {EditMarker};
// export {EditPolyVertices};
// export {EditPoly};
// export {EditRectangle};
// export {EditCircle};









/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);

leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.extend(leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.LatLng, {
  DEG_TO_RAD: Math.PI / 180,
  RAD_TO_DEG: 180 / Math.PI,
  MAX_MARGIN: 1.0E-9
});
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.extend(leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Util, {
  proxyUtil: function proxyUtil(fn, context) {
    var args, proxy, tmp;

    if (typeof context === "string") {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    }

    if (!(typeof fn == 'function')) {
      return undefined;
    }

    args = Array.prototype.slice.call(arguments, 2);

    proxy = function proxy() {
      return fn.apply(context || this, args.concat(Array.prototype.slice.call(arguments)));
    };

    return proxy;
  },
  writeGeometryToWKT: function writeGeometryToWKT(geometry, type) {
    var wkt;

    if (type.toLowerCase() == "point") {
      wkt = 'POINT(' + geometry.lng + ' ' + geometry.lat + ')';
    } else if (type.toLowerCase() == "line") {
      wkt = 'LINESTRING(';
      var linePoints = [];

      for (var m = 0; m < geometry.length; m++) {
        linePoints.push(geometry[m].lng + " " + geometry[m].lat);
      }

      wkt += linePoints.join(",");
      wkt += ')';
    } else if (type.toLowerCase() == "polygon") {
      wkt = 'POLYGON(';
      var polygons = [];

      for (var i = 0; i < geometry.length; i++) {
        var points = [];

        for (var j = 0; j < geometry[i].length; j++) {
          points.push(geometry[i][j].lng + " " + geometry[i][j].lat);

          if (i == geometry.length - 1 && j == geometry[i].length - 1) {
            points.push(geometry[0][0].lng + " " + geometry[0][0].lat);
          }
        }

        polygons.push("(" + points.join(",") + ")");
      }

      wkt += polygons.join(",");
      wkt += ')';
    }

    return wkt;
  },
  getParam: function getParam(param) {
    var local = document.location.search.substring(1);
    var splits = local.split("&");

    for (var i = 0; i < splits.length; i++) {
      var sp = splits[i];

      if (sp.indexOf(param + "=") == 0) {
        var val = sp.substring(param.length + 1);
        return decodeURIComponent(val);
      }
    }
  },
  geodesicArea: function geodesicArea(latLngs) {
    var pointsCount = latLngs.length,
        area = 0.0,
        d2r = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.LatLng.DEG_TO_RAD,
        p1,
        p2;

    if (pointsCount > 2) {
      for (var i = 0; i < pointsCount; i++) {
        p1 = latLngs[i];
        p2 = latLngs[(i + 1) % pointsCount];
        area += (p2.lng - p1.lng) * d2r * (2 + Math.sin(p1.lat * d2r) + Math.sin(p2.lat * d2r));
      }

      area = area * 6378137.0 * 6378137.0 / 2.0;
    }

    return Math.abs(area);
  },
  readableArea: function readableArea(area, isMetric) {
    var areaStr;

    if (isMetric) {
      if (area >= 1000000) {
        areaStr = (area * 0.000001).toFixed(2) + ' 平方公里';
      } else {
        areaStr = area.toFixed(2) + ' 平方米;';
      }
    } else {
      area /= 0.836127; // Square yards in 1 meter

      if (area >= 3097600) {
        //3097600 square yards in 1 square mile
        areaStr = (area / 3097600).toFixed(2) + ' mi&sup2;';
      } else if (area >= 4840) {
        //48040 square yards in 1 acre
        areaStr = (area / 4840).toFixed(2) + ' acres';
      } else {
        areaStr = Math.ceil(area) + ' yd&sup2;';
      }
    }

    return areaStr;
  },
  readableDistance: function readableDistance(distance, isMetric, useFeet) {
    var distanceStr;

    if (isMetric) {
      // show metres when distance is < 1km, then show km
      if (distance > 1000) {
        distanceStr = (distance / 1000).toFixed(2) + ' 千米';
      } else {
        distanceStr = Math.ceil(distance) + ' 米';
      }
    } else {
      distance *= 1.09361;

      if (distance > 1760) {
        distanceStr = (distance / 1760).toFixed(2) + ' miles';
      } else {
        var suffix = ' yd';

        if (useFeet) {
          distance = distance * 3;
          suffix = ' ft';
        }

        distanceStr = Math.ceil(distance) + suffix;
      }
    }

    return distanceStr;
  },
  tryFunc: function tryFunc() {
    var returnValue = null;

    for (var i = 0, len = arguments.length; i < len; i++) {
      var lambda = arguments[i];

      try {
        returnValue = lambda();
        break;
      } catch (e) {//console.log(e);
      }
    }

    return returnValue;
  },
  bind: function bind(func, object) {
    // create a reference to all arguments past the second one
    var args = Array.prototype.slice.apply(arguments, [2]);
    return function () {
      // Push on any additional arguments from the actual function call.
      // These will come after those sent to the bind call.
      var newArgs = args.concat(Array.prototype.slice.apply(arguments, [0]));
      return func.apply(object, newArgs);
    };
  },
  applyDefaults: function applyDefaults(to, from) {
    to = to || {};
    /*
     * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
     * prototype object" when calling hawOwnProperty if the source object is an
     * instance of window.Event.
     */

    var fromIsEvt = typeof window.Event == "function" && from instanceof window.Event;

    for (var key in from) {
      if (to[key] === undefined || !fromIsEvt && from.hasOwnProperty && from.hasOwnProperty(key) && !to.hasOwnProperty(key)) {
        to[key] = from[key];
      }
    }
    /**
     * IE doesn't include the toString property when iterating over an object's
     * properties with the for(property in object) syntax.  Explicitly check if
     * the source has its own toString property.
     */


    if (!fromIsEvt && from && from.hasOwnProperty && from.hasOwnProperty('toString') && !to.hasOwnProperty('toString')) {
      to.toString = from.toString;
    }

    return to;
  },
  cloneLatLngs: function cloneLatLngs(latlngs) {
    var clone = [];

    for (var i = 0, l = latlngs.length; i < l; i++) {
      // Check for nested array (Polyline/Polygon)
      if (Array.isArray(latlngs[i])) {
        clone.push(leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Util.cloneLatLngs(latlngs[i]));
      } else {
        clone.push(this.cloneLatLng(latlngs[i]));
      }
    }

    return clone;
  },
  cloneLatLng: function cloneLatLng(latlng) {
    return leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.latLng(latlng.lat, latlng.lng);
  },
  meterToDegree: function meterToDegree(meter) {
    return meter / (2 * Math.PI * 6371004) * 360;
  },
  degreeToMeter: function degreeToMeter(degree) {
    return 2 * Math.PI * 6371004 * 360 * degree;
  }
});
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Polyline.include({
  // Check to see if this polyline has any linesegments that intersect.
  // NOTE: does not support detecting intersection for degenerate cases.
  intersects: function intersects() {
    var points = this._originalPoints,
        len = points ? points.length : 0,
        i,
        p,
        p1;

    if (this._tooFewPointsForIntersection()) {
      return false;
    }

    for (i = len - 1; i >= 3; i--) {
      p = points[i - 1];
      p1 = points[i];

      if (this._lineSegmentsIntersectsRange(p, p1, i - 2)) {
        return true;
      }
    }

    return false;
  },
  // Check for intersection if new latlng was added to this polyline.
  // NOTE: does not support detecting intersection for degenerate cases.
  newLatLngIntersects: function newLatLngIntersects(latlng, skipFirst) {
    // Cannot check a polyline for intersecting lats/lngs when not added to the map
    if (!this._map) {
      return false;
    }

    return this.newPointIntersects(this._map.latLngToLayerPoint(latlng), skipFirst);
  },
  // Check for intersection if new point was added to this polyline.
  // newPoint must be a layer point.
  // NOTE: does not support detecting intersection for degenerate cases.
  newPointIntersects: function newPointIntersects(newPoint, skipFirst) {
    var points = this._originalPoints,
        len = points ? points.length : 0,
        lastPoint = points ? points[len - 1] : null,
        // The previous previous line segment. Previous line segment doesn't need testing.
    maxIndex = len - 2;

    if (this._tooFewPointsForIntersection(1)) {
      return false;
    }

    return this._lineSegmentsIntersectsRange(lastPoint, newPoint, maxIndex, skipFirst ? 1 : 0);
  },
  // Polylines with 2 sides can only intersect in cases where points are collinear (we don't support detecting these).
  // Cannot have intersection when < 3 line segments (< 4 points)
  _tooFewPointsForIntersection: function _tooFewPointsForIntersection(extraPoints) {
    var points = this._originalPoints,
        len = points ? points.length : 0; // Increment length by extraPoints if present

    len += extraPoints || 0;
    return !this._originalPoints || len <= 3;
  },
  // Checks a line segment intersections with any line segments before its predecessor.
  // Don't need to check the predecessor as will never intersect.
  _lineSegmentsIntersectsRange: function _lineSegmentsIntersectsRange(p, p1, maxIndex, minIndex) {
    var points = this._originalPoints,
        p2,
        p3;
    minIndex = minIndex || 0; // Check all previous line segments (beside the immediately previous) for intersections

    for (var j = maxIndex; j > minIndex; j--) {
      p2 = points[j - 1];
      p3 = points[j];

      if (leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.LineUtil.segmentsIntersect(p, p1, p2, p3)) {
        return true;
      }
    }

    return false;
  }
});
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Polygon.include({
  // Checks a polygon for any intersecting line segments. Ignores holes.
  intersects: function intersects() {
    var polylineIntersects,
        points = this._originalPoints,
        len,
        firstPoint,
        lastPoint,
        maxIndex;

    if (this._tooFewPointsForIntersection()) {
      return false;
    }

    polylineIntersects = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Polyline.prototype.intersects.call(this); // If already found an intersection don't need to check for any more.

    if (polylineIntersects) {
      return true;
    }

    len = points.length;
    firstPoint = points[0];
    lastPoint = points[len - 1];
    maxIndex = len - 2; // Check the line segment between last and first point. Don't need to check the first line segment (minIndex = 1)

    return this._lineSegmentsIntersectsRange(lastPoint, firstPoint, maxIndex, 1);
  }
});

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ RouteService; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ TRouteService; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ PoiService; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ TPoiService; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ GeocoderService; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ TGeocoderService; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ FeatureService; });

// EXTERNAL MODULE: external "L"
var external_L_ = __webpack_require__(0);
var external_L_default = /*#__PURE__*/__webpack_require__.n(external_L_);

// EXTERNAL MODULE: ./src/core/Base.js
var Base = __webpack_require__(1);

// CONCATENATED MODULE: ./src/service/route/RoutePlan.js

var RoutePlan = external_L_default.a.Class.extend({
  options: {
    plan: null
  },
  initialize: function initialize(options) {
    external_L_default.a.setOptions(this, options);
  },

  /**
   * 获取当前方案的总距离
   * @method L.RoutePlan#getDistance
   * @return {string} len - 总距离
   */
  getDistance: function getDistance() {
    var plan = this.options.plan;

    if (plan) {
      return parseInt(plan.distance / 1000) + "公里";
    }

    return null;
  },

  /**
   * 获取当前方案的总时间
   * @method L.RoutePlan#getDistance
   * @return {string} time - 总时间
   */
  getDuration: function getDuration() {
    var plan = this.options.plan;

    if (plan) {
      return this._formatMinute(plan.duration);
    }

    return null;
  },

  /**
   * 获取当前方案的路段数目
   * @method L.RoutePlan#getNumSteps
   * @return {number} num - 路段数目
   */
  getNumSteps: function getNumSteps() {
    var plan = this.options.plan;

    if (plan) {
      return plan.steps.length;
    }

    return null;
  },

  /**
   * 根据路段序号获取该路段信息
   * @method L.RoutePlan#getStep
   * @param  {number} num - 路段序号
   * @return {object} step - 路段数目
   */
  getStep: function getStep(num) {
    var plan = this.options.plan;

    if (plan) {
      var steps = plan.steps;
      return steps[num];
    }

    return null;
  },
  _formatMinute: function _formatMinute(value) {
    var theTime = parseInt(value);
    var theTime1 = 0;

    if (theTime > 60) {
      theTime1 = parseInt(theTime / 60);
      theTime = parseInt(theTime % 60);
    }

    var result = 0;

    if (theTime1 > 0) {
      result = "" + parseInt(theTime1) + "小时";
    }

    result = result + theTime + "分钟";
    return result;
  }
});
/* harmony default export */ var route_RoutePlan = (RoutePlan);
// EXTERNAL MODULE: ./src/util/FetchRequest.js
var FetchRequest = __webpack_require__(3);

// CONCATENATED MODULE: ./src/service/route/RouteService.js




var RouteService = external_L_default.a.Class.extend({
  options: {
    url: null,
    policy: 0,
    onSearchComplete: null,
    start: null,
    end: null,
    waypoints: [],
    currentResult: null
  },
  initialize: function initialize(map, options) {
    this.map = map;
    external_L_default.a.setOptions(this, options);
  },

  /**
   * 设置查询策略
   * @method L.DrivingRoute#setPolicy
   * @param {number}  policy   - 策略值，policy=0 最少时间、policy=1 最短距离、policy=2 避开高速。
   * @param {Boolean} nosearch - 是否查询，值为true则不进行自动查询
   */
  setPolicy: function setPolicy(policy, nosearch) {
    this.options.policy = policy;

    if (!nosearch) {
      this._search();
    }
  },

  /**
   * 根据起始点查询线路
   * @method L.DrivingRoute#search
   * @param {L.LatLng} start - 起点坐标
   * @param {L.LatLng} end   - 终点坐标
   */
  search: function search(start, end) {
    if (start instanceof external_L_default.a.LatLng && end instanceof external_L_default.a.LatLng) {
      this.options.start = start;
      this.options.end = end;

      this._search();
    } else {
      this._failFn();
    }
  },

  /**
   * 设置途经点
   * @method L.DrivingRoute#setWayPoints
   * @param {L.LatLng[]} waypoints - 途经点集合
   * @param {Boolean} nosearch 	- 是否查询，值为true则不进行自动查询
   */
  setWayPoints: function setWayPoints(waypoints, nosearch) {
    if (waypoints && waypoints.length > 0) {
      this.options.waypoints = waypoints;

      if (!nosearch) {
        this._search();
      }
    }
  },

  /**
   * 获取途经点
   * @method L.DrivingRoute#getWayPoints
   * @return {L.LatLng[]} waypoints - 途经点集合
   */
  getWayPoints: function getWayPoints() {
    return this.options.waypoints;
  },

  /**
   * 清除结果
   * @method L.DrivingRoute#clearResults
   */
  clearResults: function clearResults() {
    this.options.policy = 0;
    this.options.start = null;
    this.options.end = null;
    this.options.currentResult = null;
  },

  /**
   * 获取查询结果
   * @method L.DrivingRoute#getResults
   * @return {object} currentResult - 查询结果
   */
  getResults: function getResults() {
    return this.options.currentResult;
  },

  /**
   * 获取起点
   * @method L.DrivingRoute#getStart
   * @return {L.LatLng} start - 起点坐标
   */
  getStart: function getStart() {
    return this.options.start;
  },

  /**
   * 获取终点
   * @method L.DrivingRoute#getEnd
   * @return {L.LatLng} end - 终点坐标
   */
  getEnd: function getEnd() {
    return this.options.end;
  },

  /**
   * 获取结果方案数量
   * @method L.DrivingRoute#getNumPlans
   * @return {number} num - 方案数量
   */
  getNumPlans: function getNumPlans() {
    var routes = this.options.currentResult;

    if (routes && routes.status.toLowerCase() == "ok") {
      return routes.totalCount;
    } else {
      return 0;
    }
  },

  /**
   * 根据方案序号获取对应方案对象
   * @method L.DrivingRoute#getPlan
   * @param  {number}      num - 方案序号
   * @return {L.RoutePlan} plan - 方案数量
   */
  getPlan: function getPlan(num) {
    var total = this.getNumPlans();
    var plan;

    if (total > 0) {
      var plans = this.options.currentResult.results;

      if (typeof num === 'number' && isFinite(num) && num <= total) {
        plan = plans[num];
        return new route_RoutePlan({
          plan: plan
        });
      }
    }

    return false;
  },
  _failFn: function _failFn() {
    var obj = {
      msg: "起始点参数不正确，请传入L.LatLng类型参数",
      status: "error"
    };

    if (this.options.onSearchComplete) {
      this.options.onSearchComplete.call(this, obj);
    }
  },
  _search: function _search() {
    var url = this._queryParam();

    if (url) {
      var that = this;
      FetchRequest["a" /* default */].get(url).then(function (result) {
        that.options.currentResult = result;

        if (that.options.onSearchComplete) {
          that.options.onSearchComplete.call(that, result);
        }
      });
    }
  },
  _queryParam: function _queryParam() {
    var url = this.options.url;
    var start = this.options.start;
    var end = this.options.end;
    var policy = this.options.policy;

    if (start && end && url) {
      var origin = start.lng + "," + start.lat;
      var destination = end.lng + "," + end.lat;
      url = url + "?format=json" + "&origin=" + origin + "&destination=" + destination + "&mode=" + policy;
      var waypoints = this.getWayPoints();

      if (waypoints && waypoints.length > 0) {
        var _waypoints = [];

        for (var i = 0; i < waypoints.length; i++) {
          var lnglat = waypoints[i].lng + "," + waypoints[i].lat;

          _waypoints.push(lnglat);
        }

        url += "&waypoints=" + _waypoints.join(";");
      }

      return url;
    } else {
      return false;
    }
  }
});
var routeService = function routeService(map, options) {
  return new RouteService(map, options);
};
external_L_default.a.geoway.service.routeService = routeService;
external_L_default.a.geoway.service.RouteService = RouteService;
external_L_default.a.DrivingRoute = RouteService;
// EXTERNAL MODULE: ./src/format/route/TRouteResultFormat.js
var TRouteResultFormat = __webpack_require__(22);

// EXTERNAL MODULE: ./src/format/route/TRouteResult.js
var TRouteResult = __webpack_require__(23);

// CONCATENATED MODULE: ./src/service/route/TRouteService.js





var TRouteService = external_L_default.a.Class.extend({
  options: {
    url: "https://api.tianditu.gov.cn/drive",
    tk: "ffa5ef8e4ea43caf693fa0097f8258a6",
    policy: 0,
    onSearchComplete: null,
    start: null,
    end: null,
    waypoints: [],
    currentResult: null
  },
  initialize: function initialize(map, options) {
    this.map = map;
    external_L_default.a.setOptions(this, options);
  },

  /**
   * 设置查询策略
   * @method L.TDrivingRoute#setPolicy
   * @param {number}  policy   - 策略值，policy=0 最少时间、policy=1 最短距离、policy=2 避开高速。
   * @param {Boolean} nosearch - 是否查询，值为true则不进行自动查询
   */
  setPolicy: function setPolicy(policy, nosearch) {
    this.options.policy = policy;

    if (!nosearch) {
      this._search();
    }
  },

  /**
   * 根据起始点查询线路
   * @method L.TDrivingRoute#search
   * @param {L.LatLng} start - 起点坐标
   * @param {L.LatLng} end   - 终点坐标
   */
  search: function search(start, end) {
    if (start instanceof external_L_default.a.LatLng && end instanceof external_L_default.a.LatLng) {
      this.options.start = start;
      this.options.end = end;

      this._search();
    } else {
      this._failFn();
    }
  },

  /**
   * 设置途经点
   * @method L.TDrivingRoute#setWayPoints
   * @param {L.LatLng[]} waypoints - 途经点集合
   * @param {Boolean} nosearch 	- 是否查询，值为true则不进行自动查询
   */
  setWayPoints: function setWayPoints(waypoints, nosearch) {
    if (waypoints && waypoints.length > 0) {
      this.options.waypoints = waypoints;

      if (!nosearch) {
        this._search();
      }
    }
  },

  /**
   * 获取途经点
   * @method L.TDrivingRoute#getWayPoints
   * @return {L.LatLng[]} waypoints - 途经点集合
   */
  getWayPoints: function getWayPoints() {
    return this.options.waypoints;
  },

  /**
   * 清除结果
   * @method L.TDrivingRoute#clearResults
   */
  clearResults: function clearResults() {
    this.options.policy = 0;
    this.options.start = null;
    this.options.end = null;
    this.options.currentResult = null;
  },

  /**
   * 获取查询结果
   * @method L.TDrivingRoute#getResults
   * @return {object} currentResult - 查询结果
   */
  getResults: function getResults() {
    return this.options.currentResult;
  },

  /**
   * 获取起点
   * @method L.TDrivingRoute#getStart
   * @return {L.LatLng} start - 起点坐标
   */
  getStart: function getStart() {
    return this.options.start;
  },

  /**
   * 获取终点
   * @method L.TDrivingRoute#getEnd
   * @return {L.LatLng} end - 终点坐标
   */
  getEnd: function getEnd() {
    return this.options.end;
  },
  _failFn: function _failFn() {
    var obj = {
      msg: "起始点参数不正确，请传入L.LatLng类型参数",
      status: "error"
    };

    if (this.options.onSearchComplete) {
      this.options.onSearchComplete.call(this, obj);
    }
  },
  _search: function _search() {
    var url = this._queryParam();

    if (url) {
      var that = this;
      FetchRequest["a" /* default */].get(url).then(function (result) {
        var parser = new TRouteResultFormat["a" /* TRouteResultFormat */]();
        var resultObj = new TRouteResult["a" /* TRouteResult */](parser.read(result.bodyText));
        that.options.currentResult = resultObj;

        if (that.options.onSearchComplete) {
          that.options.onSearchComplete.call(that, resultObj);
        }
      });
    }
  },
  _queryParam: function _queryParam() {
    var url = this.options.url;
    var start = this.options.start;
    var end = this.options.end;
    var policy = this.options.policy;

    if (start && end && url) {
      var waypoints = this.getWayPoints();
      var mid = "";

      if (waypoints && waypoints.length > 0) {
        var _waypoints = [];

        for (var i = 0; i < waypoints.length; i++) {
          var lnglat = waypoints[i].lng + "," + waypoints[i].lat;

          _waypoints.push(lnglat);
        }

        mid = _waypoints.join(";");
      }

      var origin = start.lng + "," + start.lat;
      var destination = end.lng + "," + end.lat;
      var requestParams = {};
      requestParams.orig = origin;
      requestParams.dest = destination;
      requestParams.style = policy;
      requestParams.mid = mid;
      var allParams = ["orig", "dest", "style", "mid"];
      var queryStr = "?postStr=";
      var postStrArr = [];

      for (var j = 0; j < allParams.length; j++) {
        var item = allParams[j];

        if (item in requestParams) {
          postStrArr.push("'" + item + "':" + "'" + requestParams[item] + "'");
        }
      }

      queryStr += "{" + postStrArr.join(",") + "}";
      queryStr += "&type=search&tk=" + this.options.tk;
      url = url + queryStr;
      return url;
    } else {
      return false;
    }
  }
});
var tRouteService = function tRouteService(map, options) {
  return new TRouteService(map, options);
};
external_L_default.a.geoway.service.tRouteService = tRouteService;
external_L_default.a.geoway.service.TRouteService = TRouteService;
external_L_default.a.TDrivingRoute = TRouteService;
// CONCATENATED MODULE: ./src/service/poi/PoiService.js



var PoiService = external_L_default.a.Class.extend({
  options: {
    url: null,
    pageNum: 0,
    pageSize: 10,
    onSearchComplete: null,
    param: null,
    resultType: 0,
    currentResult: null
  },
  initialize: function initialize(map, options) {
    this.map = map;
    external_L_default.a.setOptions(this, options);
  },

  /**
   * 设置查询服务地址
   * @method L.LocalSearch#setUrl
   * @param {String} url - 服务地址
   */
  setUrl: function setUrl(url) {
    this.options.url = url;
  },

  /**
   * 设置每页查询数目
   * @method L.LocalSearch#setPageSize
   * @param {number} pageSize - 每页条数
   */
  setPageSize: function setPageSize(pageSize) {
    this.options.pageSize = pageSize;
  },

  /**
   * 获取每页查询数目
   * @method L.LocalSearch#getPageSize
   * @return {number} pageSize - 每页条数
   */
  getPageSize: function getPageSize() {
    return this.options.pageSize;
  },

  /**
   * 设置查询成功回调函数
   * @method L.LocalSearch#setSearchCompleteCallback
   * @param {function} fun - 回调函数
   */
  setSearchCompleteCallback: function setSearchCompleteCallback(fun) {
    this.options.onSearchComplete = fun;
  },

  /**
   * 关键字检索
   * @method L.LocalSearch#search
   * @param {string} keyword - 检索关键字
   * @param {number} type - 检索类型
   * type=1 表示普通关键字搜索；
   * type=2 表示视野内搜索；
   * type=3 表示总数搜索。
   */
  search: function search(keyword, type) {
    switch (type) {
      case 1:
        this.options.resultType = 1;

        this._search(keyword, null);

        break;

      case 2:
        this.options.resultType = 2;

        this._searchInView(keyword, null);

        break;

      case 3:
        this.options.resultType = 3;

        this._searchStatistics(keyword, null);

        break;
    }
  },

  /**
   * 分类检索
   * @method L.LocalSearch#searchBySort
   * @param {string} sort - 检索分类编码
   * @param {number} type - 检索类型
   * type=1 表示普通关键字搜索；
   * type=2 表示视野内搜索；
   * type=3 表示总数搜索。
   */
  searchBySort: function searchBySort(sort, type) {
    switch (type) {
      case 1:
        this.options.resultType = 4;

        this._search(null, sort);

        break;

      case 2:
        this.options.resultType = 5;

        this._searchInView(null, sort);

        break;

      case 3:
        this.options.resultType = 6;

        this._searchStatistics(null, sort);

        break;
    }
  },

  /**
   * 按指定bounds检索
   * @method L.LocalSearch#searchInBounds
   * @param {string} keyword - 检索关键字
   * @param {L.LatLngBounds} bounds - 检索范围
   */
  searchInBounds: function searchInBounds(keyword, bounds) {
    this.options.resultType = 7;

    if (bounds instanceof external_L_default.a.LatLngBounds) {
      bounds = [bounds.getSouth(), bounds.getWest(), bounds.getNorth(), bounds.getEast()].join(',');
    }

    var pageNum = this.options.pageNum;
    var pageSize = this.options.pageSize;
    var param = {
      "keyword": keyword,
      "bounds": bounds,
      "pageNum": pageNum,
      "pageSize": pageSize
    };
    this.options.param = param;

    var url = this._queryParam(param);

    if (url) {
      this._doQuery(url);
    }
  },

  /**
   * 按指定bounds检索
   * @method L.LocalSearch#searchInBoundsBySort
   * @param {string} sort - 检索分类编码
   * @param {L.LatLngBounds} bounds - 检索范围
   */
  searchInBoundsBySort: function searchInBoundsBySort(sort, bounds) {
    this.options.resultType = 8;

    if (bounds instanceof external_L_default.a.LatLngBounds) {
      bounds = [bounds.getSouth(), bounds.getWest(), bounds.getNorth(), bounds.getEast()].join(',');
    }

    var pageNum = this.options.pageNum;
    var pageSize = this.options.pageSize;
    var param = {
      "sort": sort,
      "bounds": bounds,
      "pageNum": pageNum,
      "pageSize": pageSize
    };
    this.options.param = param;

    var url = this._queryParam(param);

    if (url) {
      this._doQuery(url);
    }
  },

  /**
   * 根据中心点、半径周边检索
   * @method L.LocalSearch#searchNearby
   * @param {string} keyword - 检索关键字
   * @param {L.LatLng} center - 中心点
   * @param {float} radius - 搜索半径，单位米
   */
  searchNearby: function searchNearby(keyword, center, radius) {
    this.options.resultType = 9;
    var pageNum = this.options.pageNum;
    var pageSize = this.options.pageSize;
    var param = {
      "keyword": keyword,
      "center": center,
      "radius": radius,
      "pageNum": pageNum,
      "pageSize": pageSize
    };
    this.options.param = param;

    var url = this._queryBufferParam(param);

    if (url) {
      this._doQuery(url);
    }
  },

  /**
   * 根据中心点、半径周边检索
   * @method L.LocalSearch#searchNearbyBySort
   * @param {string} sort - 检索分类编码
   * @param {L.LatLng} center - 中心点
   * @param {float} radius - 搜索半径，单位米
   */
  searchNearbyBySort: function searchNearbyBySort(sort, center, radius) {
    this.options.resultType = 10;
    var pageNum = this.options.pageNum;
    var pageSize = this.options.pageSize;
    var param = {
      "sort": sort,
      "center": center,
      "radius": radius,
      "pageNum": pageNum,
      "pageSize": pageSize
    };
    this.options.param = param;

    var url = this._queryBufferParam(param);

    if (url) {
      this._doQuery(url);
    }
  },

  /**
   * 获取当前检索结果
   * @method L.LocalSearch#getResults
   * @return {object} currentResult - 检索结果
   */
  getResults: function getResults() {
    return this.options.currentResult;
  },

  /**
   * 清除检索结果
   * @method L.LocalSearch#clearResults
   */
  clearResults: function clearResults() {
    this.options.currentResult = null;
    this.options.pageNum = 0;
  },

  /**
   * 获取结果总页数
   * @method L.LocalSearch#getTotalPage
   * @return {number} totalPage - 总页数
   */
  getTotalPage: function getTotalPage() {
    var totalPage;
    var result = this.options.currentResult;

    if (result) {
      var totalCount = result.totalCount;

      if (totalCount && totalCount > 0) {
        totalPage = Math.ceil(totalCount / this.options.pageSize) - 1;
      }
    }

    return totalPage;
  },

  /**
   * 检索首页
   * @method L.LocalSearch#firstPage
   */
  firstPage: function firstPage() {
    this.gotoPage(0);
  },

  /**
   * 检索下一页
   * @method L.LocalSearch#nextPage
   */
  nextPage: function nextPage() {
    var param = this.options.param;
    var pageNum = param.pageNum;
    this.gotoPage(pageNum + 1);
  },

  /**
   * 检索上一页
   * @method L.LocalSearch#previousPage
   */
  previousPage: function previousPage() {
    var param = this.options.param;
    var pageNum = param.pageNum;
    this.gotoPage(pageNum - 1);
  },

  /**
   * 检索最后一页
   * @method L.LocalSearch#lastPage
   */
  lastPage: function lastPage() {
    var totalPage = this.getTotalPage();
    this.gotoPage(totalPage);
  },

  /**
   * 检索指定页码
   * @method L.LocalSearch#gotoPage
   * @param {number} pageNum - 指定页码
   */
  gotoPage: function gotoPage(pageNum) {
    var param = this.options.param;
    var totalPage = this.getTotalPage();
    var url;

    if (param && totalPage) {
      if (pageNum > totalPage) {
        pageNum = totalPage;
      } else if (pageNum < 0) {
        pageNum = 0;
      }

      param.pageNum = pageNum;

      if (param["radius"]) {
        url = this._queryBufferParam(param);
      } else {
        url = this._queryParam(param);
      }

      if (url) {
        this._doQuery(url);
      }
    }
  },

  /**
   * 检索距离当前位置最近的点
   * @method L.LocalSearch#searchNear
   * @param {L.LatLng} latlng - 当前位置
   */
  searchNear: function searchNear(latlng) {
    this.options.resultType = 11;
    var url = this.options.url;

    if (!url) {
      return false;
    }

    url = url + '/nearest?location=' + latlng.lat + ',' + latlng.lng;
    var that = this;
    FetchRequest["a" /* default */].get(url).then(function (result) {
      if (that.options.onSearchComplete) {
        that.options.onSearchComplete.call(that, result, that.options.resultType);
      }
    });
  },

  /**
   * ID精确查询
   * @method L.LocalSearch#searchById
   * @param {String} id - 数据id
   */
  searchById: function searchById(id, successFun, failFun) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    url = url + '/detail?id=' + id;
    var that = this;
    FetchRequest["a" /* default */].get(url).then(function (result) {
      successFun.call(that, result);
    })["catch"](function (e) {
      if (failFun) {
        failFun.call(that, e);
      }
    });
  },
  _doQuery: function _doQuery(url) {
    var that = this;
    FetchRequest["a" /* default */].get(url, {}).then(function (result) {
      that.options.currentResult = result;

      if (that.options.onSearchComplete) {
        that.options.onSearchComplete.call(that, result, that.options.resultType);
      }
    });
  },
  _search: function _search(keyword, sort) {
    var pageNum = this.options.pageNum;
    var pageSize = this.options.pageSize;
    var param = {
      "keyword": keyword,
      "sort": sort,
      "pageNum": pageNum,
      "pageSize": pageSize
    };
    this.options.param = param;

    var url = this._queryParam(param);

    if (url) {
      this._doQuery(url);
    }
  },
  _searchInView: function _searchInView(keyword, sort) {
    var bounds = this.map.getBounds();
    var bbox = [bounds.getSouth(), bounds.getWest(), bounds.getNorth(), bounds.getEast()].join(',');
    var pageNum = this.options.pageNum;
    var pageSize = this.options.pageSize;
    var param = {
      "keyword": keyword,
      "sort": sort,
      "bounds": bbox,
      "pageNum": pageNum,
      "pageSize": pageSize
    };
    this.options.param = param;

    var url = this._queryParam(param);

    if (url) {
      this._doQuery(url);
    }
  },
  _searchStatistics: function _searchStatistics(keyword, sort) {
    var param = {
      "keyword": keyword,
      "sort": sort
    };

    var url = this._queryStatParam(param);

    if (url) {
      this._doQuery(url);
    }
  },
  _queryParam: function _queryParam(param) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    var keyword = param.keyword;
    var type = param.sort;
    var bounds = param.bounds;
    var city = param.city;
    var pageNum = param.pageNum;
    var pageSize = param.pageSize;
    url = url + '/search?format=json&page_num=' + pageNum + '&page_size=' + pageSize;

    if (keyword) {
      url += "&q=" + encodeURIComponent(keyword);
    }

    if (type) {
      url += "&type=" + encodeURIComponent(type);
    }

    if (city) {
      url += "&city=" + encodeURIComponent(city);
    }

    if (bounds) {
      url += "&sq_type=bounds&bounds=" + encodeURIComponent(bounds);
    }

    return url;
  },
  _queryBufferParam: function _queryBufferParam(param) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    var keyword = param.keyword;
    var type = param.sort;
    var radius = param.radius;
    var center = param.center;
    url = url + "/search?format=json";

    if (keyword) {
      url += "&q=" + encodeURIComponent(keyword);
    }

    if (type) {
      url += "&type=" + encodeURIComponent(type);
    }

    var pageNum = param.pageNum;
    var pageSize = param.pageSize;
    var addParams = "&page_num={page_num}&page_size={page_size}&sq_type=buffer&location={y},{x}&radius={r}".replace("{page_num}", pageNum).replace("{page_size}", pageSize).replace("{x}", center.lng).replace("{y}", center.lat).replace("{r}", radius);
    url += addParams;
    return url;
  },
  _queryStatParam: function _queryStatParam(param) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    var keyword = param.keyword;
    var type = param.sort;
    url = url + '/statistic?';

    if (keyword) {
      url += "&q=" + encodeURIComponent(keyword);
    }

    if (type) {
      url += "&type=" + encodeURIComponent(type);
    }

    return url;
  }
});
var poiService = function poiService(map, options) {
  return new PoiService(map, options);
};
external_L_default.a.geoway.service.poiService = poiService;
external_L_default.a.geoway.service.PoiService = PoiService;
external_L_default.a.LocalSearch = PoiService;
// CONCATENATED MODULE: ./src/service/poi/TPoiService.js



var TPoiService = external_L_default.a.Class.extend({
  options: {
    url: "https://api.tianditu.gov.cn/search",
    tk: "ffa5ef8e4ea43caf693fa0097f8258a6",
    pageNum: 0,
    pageSize: 10,
    onSearchComplete: null,
    param: null,
    resultType: 0,
    currentResult: null
  },
  initialize: function initialize(map, options) {
    this.map = map;
    external_L_default.a.setOptions(this, options);
  },

  /**
   * 设置查询服务地址
   * @method L.TLocalSearch#setUrl
   * @param {String} url - 服务地址
   */
  setUrl: function setUrl(url) {
    this.options.url = url;
  },

  /**
   * 设置每页查询数目
   * @method L.TLocalSearch#setPageSize
   * @param {number} pageSize - 每页条数
   */
  setPageSize: function setPageSize(pageSize) {
    this.options.pageSize = pageSize;
  },

  /**
   * 获取每页查询数目
   * @method L.TLocalSearch#getPageSize
   * @return {number} pageSize - 每页条数
   */
  getPageSize: function getPageSize() {
    return this.options.pageSize;
  },

  /**
   * 设置查询成功回调函数
   * @method L.TLocalSearch#setSearchCompleteCallback
   * @param {function} fun - 回调函数
   */
  setSearchCompleteCallback: function setSearchCompleteCallback(fun) {
    this.options.onSearchComplete = fun;
  },

  /**
   * 关键字检索
   * @method L.TLocalSearch#search
   * @param {string} keyword - 检索关键字
   * @param {number} type - 检索类型
   * type：搜索类型,1表示普通搜索;2表示视野内搜索;4表示普通建议词搜索;5表示公交规划建议词搜索;7表示 纯POI搜索(不搜公交线）;10表示拉框搜索
   */
  search: function search(keyword, type) {
    this._search(keyword, type);
  },

  /**
   * 按指定bounds检索
   * @method L.TLocalSearch#searchInBounds
   * @param {string} keyword - 检索关键字
   * @param {L.LatLngBounds} bounds - 检索范围
   */
  searchInBounds: function searchInBounds(keyword, bounds) {
    this.options.mapBound = bounds.toBBoxString();

    this._search(keyword, 10);
  },

  /**
   * 根据中心点、半径周边检索
   * @method L.TLocalSearch#searchNearby
   * @param {string} keyword - 检索关键字
   * @param {L.LatLng} center - 中心点
   * @param {float} radius - 搜索半径，单位米
   */
  searchNearby: function searchNearby(keyword, center, radius) {
    var pageNum = this.options.pageNum;
    var pageSize = this.options.pageSize;
    var param = {
      "keyWord": encodeURIComponent(keyword),
      "pageNum": pageNum,
      "pageSize": pageSize,
      "queryType": 3,
      "queryRadius": radius,
      "pointLonlat": center.lng + "," + center.lat
    };
    this.options.param = param;

    this._doSearch();
  },

  /**
   * 获取当前检索结果
   * @method L.TLocalSearch#getResults
   * @return {object} currentResult - 检索结果
   */
  getResults: function getResults() {
    return this.options.currentResult;
  },

  /**
   * 清除检索结果
   * @method L.TLocalSearch#clearResults
   */
  clearResults: function clearResults() {
    this.options.currentResult = null;
    this.options.pageNum = 0;
  },

  /**
   * 获取结果总页数
   * @method L.TLocalSearch#getTotalPage
   * @return {number} totalPage - 总页数
   */
  getTotalPage: function getTotalPage() {
    var totalPage;
    var result = this.options.currentResult;

    if (result) {
      var totalCount = result.count;

      if (totalCount && totalCount > 0) {
        totalPage = Math.ceil(totalCount / this.options.pageSize) - 1;
      }
    }

    return totalPage;
  },

  /**
   * 检索首页
   * @method L.TLocalSearch#firstPage
   */
  firstPage: function firstPage() {
    this.gotoPage(0);
  },

  /**
   * 检索下一页
   * @method L.TLocalSearch#nextPage
   */
  nextPage: function nextPage() {
    var param = this.options.param;
    var pageNum = param.pageNum;
    this.gotoPage(pageNum + 1);
  },

  /**
   * 检索上一页
   * @method L.TLocalSearch#previousPage
   */
  previousPage: function previousPage() {
    var param = this.options.param;
    var pageNum = param.pageNum;
    this.gotoPage(pageNum - 1);
  },

  /**
   * 检索最后一页
   * @method L.TLocalSearch#lastPage
   */
  lastPage: function lastPage() {
    var totalPage = this.getTotalPage();
    this.gotoPage(totalPage);
  },

  /**
   * 检索指定页码
   * @method L.TLocalSearch#gotoPage
   * @param {number} pageNum - 指定页码
   */
  gotoPage: function gotoPage(pageNum) {
    var param = this.options.param;
    var totalPage = this.getTotalPage();

    if (param && totalPage) {
      if (pageNum > totalPage) {
        pageNum = totalPage;
      } else if (pageNum < 0) {
        pageNum = 0;
      }

      param.pageNum = pageNum;

      this._doSearch();
    }
  },
  _search: function _search(keyword, queryType) {
    var pageNum = this.options.pageNum;
    var pageSize = this.options.pageSize;
    var mapBound = this.options.mapBound;
    var param = {
      "keyWord": encodeURIComponent(keyword),
      "pageNum": pageNum,
      "pageSize": pageSize,
      "queryType": queryType,
      "mapBound": mapBound
    };
    this.options.param = param;

    this._doSearch();
  },
  _doSearch: function _doSearch() {
    var param = this.options.param;

    var url = this._queryParam(param);

    if (url) {
      var that = this;
      FetchRequest["a" /* default */].get(url).then(function (result) {
        try {
          var res = JSON.parse(result);
          that.options.currentResult = res;

          if (that.options.onSearchComplete) {
            that.options.onSearchComplete.call(that, res, that.options.queryType);
          }
        } catch (e) {
          if (that.options.onSearchComplete) {
            that.options.onSearchComplete.call(that, result, that.options.queryType);
          }
        }
      });
    }
  },
  _queryParam: function _queryParam(param) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    var requestParams = external_L_default.a.setOptions({}, param);
    var count = param.pageSize;
    var start = param.pageNum * param.pageSize;

    if (this.map) {
      var level = this.map.getZoom();
      requestParams.level = requestParams.level || level;
      var mapBound = this.map.getBounds().toBBoxString();
      requestParams.mapBound = requestParams.mapBound || mapBound;
    }

    requestParams.queryType = requestParams.queryType || 1;
    requestParams.count = count || 10;
    requestParams.start = start || 0;
    var allParams = ["keyWord", "level", "mapBound", "pointLonlat", "queryRadius", "queryType", "specifyAdminCode", "count", "start"];
    var queryStr = "?postStr=";
    var postStrArr = [];

    for (var i = 0; i < allParams.length; i++) {
      var item = allParams[i];

      if (item in requestParams) {
        postStrArr.push("'" + item + "':" + "'" + requestParams[item] + "'");
      }
    }

    queryStr += "{" + postStrArr.join(",") + "}";
    queryStr += "&type=query&tk=" + this.options.tk;
    url = url + queryStr;
    return url;
  }
});
var tPoiService = function tPoiService(map, options) {
  return new TPoiService(map, options);
};
external_L_default.a.geoway.service.tPoiService = tPoiService;
external_L_default.a.geoway.service.TPoiService = TPoiService;
external_L_default.a.TLocalSearch = TPoiService;
// CONCATENATED MODULE: ./src/service/geocoder/GeocoderService.js



var GeocoderService = external_L_default.a.Class.extend({
  options: {
    url: null
  },
  initialize: function initialize(options) {
    external_L_default.a.setOptions(this, options);
  },

  /**
   * 正地理编码查询
   * @method L.Geocoder#getLatLngInfo
   * @param {object}   param - 查询参数address、city、format属性
   * @param {Function} callback - 回调函数
   */
  getLatLngInfo: function getLatLngInfo(param, callback) {
    this._getLatLngInfo(param, callback);
  },

  /**
   * 逆地理编码查询
   * @method L.Geocoder#getLocation
   * @param {L.LatLng} latlng   - 坐标位置
   * @param {Function} callback - 回调函数
   */
  getLocation: function getLocation(latlng, callback) {
    this._getLocation(latlng, callback);
  },
  _getLatLngInfo: function _getLatLngInfo(param, callback) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    var address = param.address;
    var city = param.city;
    var format = param.format || "json";
    url = url + "/geo?format=" + format + "&address=" + address;

    if (city) {
      url = url + "&city=" + city;
    }

    FetchRequest["a" /* default */].get(url).then(function (result) {
      if (callback && typeof callback == "function") {
        callback(result);
      }
    });
  },
  _getLocation: function _getLocation(latlng, callback) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    url = url + "/rgeo?format=json&lon=" + latlng.lng + "&lat=" + latlng.lat;
    FetchRequest["a" /* default */].get(url).then(function (result) {
      if (callback && typeof callback == "function") {
        callback(result);
      }
    });
  }
});
var geocoderService = function geocoderService(options) {
  return new GeocoderService(options);
};
external_L_default.a.geoway.service.geocoderService = geocoderService;
external_L_default.a.geoway.service.GeocoderService = GeocoderService;
external_L_default.a.Geocoder = GeocoderService;
// CONCATENATED MODULE: ./src/service/geocoder/TGeocoderService.js



var TGeocoderService = external_L_default.a.Class.extend({
  options: {
    url: "https://api.tianditu.gov.cn/geocoder",
    tk: "ffa5ef8e4ea43caf693fa0097f8258a6"
  },
  initialize: function initialize(options) {
    external_L_default.a.setOptions(this, options);
  },

  /**
   * 逆地理编码查询
   * @method L.TGeocoder#getLocation
   * @param {L.LatLng} latlng   - 坐标位置
   * @param {Function} callback - 回调函数
   */
  getLocation: function getLocation(latlng, callback) {
    this._getLocation(latlng, callback);
  },
  _getLocation: function _getLocation(latlng, callback) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    var requestParams = {};
    requestParams.lon = latlng.lng;
    requestParams.lat = latlng.lat;
    requestParams.appkey = "8a7b9aac0db21f9dd995e61a14685f05";
    requestParams.ver = 1;
    var allParams = ["lon", "lat", "appkey", "ver"];
    var queryStr = "?postStr=";
    var postStrArr = [];

    for (var i = 0; i < allParams.length; i++) {
      var item = allParams[i];

      if (item in requestParams) {
        postStrArr.push("'" + item + "':" + "'" + requestParams[item] + "'");
      }
    }

    queryStr += "{" + postStrArr.join(",") + "}";
    queryStr += "&type=geocode&tk=" + this.options.tk;
    FetchRequest["a" /* default */].get(url + queryStr).then(function (result) {
      var res = JSON.parse(result.bodyText);

      if (callback && typeof callback == "function") {
        callback(res);
      }
    });
  }
});
var tGeocoderService = function tGeocoderService(options) {
  return new TGeocoderService(options);
};
external_L_default.a.geoway.service.tGeocoderService = tGeocoderService;
external_L_default.a.geoway.service.TGeocoderService = TGeocoderService;
external_L_default.a.TGeocoder = TGeocoderService;
// CONCATENATED MODULE: ./src/format/layer/Wkt.js


var Wkt = __webpack_require__(49);

Wkt.Wkt.prototype.isRectangle = false;

Wkt.Wkt.prototype.trunc = function (coords) {
  var i,
      verts = [];

  for (i = 0; i < coords.length; i += 1) {
    if (Wkt.isArray(coords[i])) {
      verts.push(this.trunc(coords[i]));
    } else {
      // Add the first coord, but skip the last if it is identical
      if (i === 0 || !this.sameCoords(coords[0], coords[i])) {
        verts.push(coords[i]);
      }
    }
  }

  return verts;
};
/**
 * @augments Wkt.Wkt
 * An object of framework-dependent construction methods used to generate
 * objects belonging to the various geometry classes of the framework.
 */


Wkt.Wkt.prototype.construct = {
  /**
   * Creates the framework's equivalent point geometry object.
   * @param   config      {Object}    An optional properties hash the object should use
   * @param   component   {Object}    An optional component to build from
   * @return              {L.marker}
   */
  point: function point(config, component) {
    var coord = component || this.components;

    if (coord instanceof Array) {
      coord = coord[0];
    }

    return external_L_default.a.marker(this.coordsToLatLng(coord), config);
  },

  /**
   * Creates the framework's equivalent multipoint geometry object.
   * @param   config  {Object}    An optional properties hash the object should use
   * @return          {L.featureGroup}
   */
  multipoint: function multipoint(config) {
    var i,
        layers = [],
        coords = this.components;

    for (i = 0; i < coords.length; i += 1) {
      layers.push(this.construct.point.call(this, config, coords[i]));
    }

    return external_L_default.a.featureGroup(layers, config);
  },

  /**
   * Creates the framework's equivalent linestring geometry object.
   * @param   config      {Object}    An optional properties hash the object should use
   * @param   component   {Object}    An optional component to build from
   * @return              {L.polyline}
   */
  linestring: function linestring(config, component) {
    var coords = component || this.components,
        latlngs = this.coordsToLatLngs(coords, 0, this.coordsToLatLng);
    return external_L_default.a.polyline(latlngs, config);
  },

  /**
   * Creates the framework's equivalent multilinestring geometry object.
   * @param   config  {Object}    An optional properties hash the object should use
   * @return          {L.multiPolyline}
   */
  multilinestring: function multilinestring(config) {
    var coords = this.components,
        latlngs = this.coordsToLatLngs(coords, 1, this.coordsToLatLng);

    if (external_L_default.a.multiPolyline) {
      return external_L_default.a.multiPolyline(latlngs, config);
    } else {
      return external_L_default.a.polyline(latlngs, config);
    }
  },

  /**
   * Creates the framework's equivalent polygon geometry object.
   * @param   config      {Object}    An optional properties hash the object should use
   * @return              {L.multiPolygon}
   */
  polygon: function polygon(config) {
    // Truncate the coordinates to remove the closing coordinate
    var coords = this.trunc(this.components),
        latlngs = this.coordsToLatLngs(coords, 1, this.coordsToLatLng);
    return external_L_default.a.polygon(latlngs, config);
  },

  /**
   * Creates the framework's equivalent multipolygon geometry object.
   * @param   config  {Object}    An optional properties hash the object should use
   * @return          {L.multiPolygon}
   */
  multipolygon: function multipolygon(config) {
    // Truncate the coordinates to remove the closing coordinate
    var coords = this.trunc(this.components),
        latlngs = this.coordsToLatLngs(coords, 2, this.coordsToLatLng);

    if (external_L_default.a.multiPolygon) {
      return external_L_default.a.multiPolygon(latlngs, config);
    } else {
      return external_L_default.a.polygon(latlngs, config);
    }
  },

  /**
   * Creates the framework's equivalent collection of geometry objects.
   * @param   config  {Object}    An optional properties hash the object should use
   * @return          {L.featureGroup}
   */
  geometrycollection: function geometrycollection(config) {
    var comps, i, layers;
    comps = this.trunc(this.components);
    layers = [];

    for (i = 0; i < this.components.length; i += 1) {
      layers.push(this.construct[comps[i].type].call(this, comps[i]));
    }

    return external_L_default.a.featureGroup(layers, config);
  }
};
external_L_default.a.Util.extend(Wkt.Wkt.prototype, {
  coordsToLatLngs: external_L_default.a.GeoJSON.coordsToLatLngs,
  // TODO Why doesn't the coordsToLatLng function in L.GeoJSON already suffice?
  coordsToLatLng: function coordsToLatLng(coords, reverse) {
    var lat = reverse ? coords.x : coords.y,
        lng = reverse ? coords.y : coords.x;
    return external_L_default.a.latLng(lat, lng, true);
  }
});
/**
 * @augments Wkt.Wkt
 * A framework-dependent deconstruction method used to generate internal
 * geometric representations from instances of framework geometry. This method
 * uses object detection to attempt to classify members of framework geometry
 * classes into the standard WKT types.
 * @param   obj {Object}    An instance of one of the framework's geometry classes
 * @return      {Object}    A hash of the 'type' and 'components' thus derived
 */

Wkt.Wkt.prototype.deconstruct = function (obj) {
  var attr, _coordsFromLatLngs, features, i, verts, rings, tmp, boundary;
  /**
   * Accepts an Array (arr) of LatLngs from which it extracts each one as a
   *  vertex; calls itself recursively to deal with nested Arrays.
   */


  _coordsFromLatLngs = function coordsFromLatLngs(arr) {
    var i, coords;
    coords = [];

    for (i = 0; i < arr.length; i += 1) {
      if (Wkt.isArray(arr[i])) {
        coords.push(_coordsFromLatLngs(arr[i]));
      } else {
        coords.push({
          x: arr[i].lng,
          y: arr[i].lat
        });
      }
    }

    return coords;
  }; // L.Marker ////////////////////////////////////////////////////////////////


  if (obj.constructor === external_L_default.a.Marker || obj.constructor === external_L_default.a.marker) {
    return {
      type: 'point',
      components: [{
        x: obj.getLatLng().lng,
        y: obj.getLatLng().lat
      }]
    };
  } // L.Rectangle /////////////////////////////////////////////////////////////


  if (obj.constructor === external_L_default.a.Rectangle || obj.constructor === external_L_default.a.rectangle) {
    tmp = obj.getBounds(); // L.LatLngBounds instance

    return {
      type: 'polygon',
      isRectangle: true,
      components: [[{
        // NW corner
        x: tmp.getSouthWest().lng,
        y: tmp.getNorthEast().lat
      }, {
        // NE corner
        x: tmp.getNorthEast().lng,
        y: tmp.getNorthEast().lat
      }, {
        // SE corner
        x: tmp.getNorthEast().lng,
        y: tmp.getSouthWest().lat
      }, {
        // SW corner
        x: tmp.getSouthWest().lng,
        y: tmp.getSouthWest().lat
      }, {
        // NW corner (again, for closure)
        x: tmp.getSouthWest().lng,
        y: tmp.getNorthEast().lat
      }]]
    };
  } // L.Polyline //////////////////////////////////////////////////////////////


  if (obj.constructor === external_L_default.a.Polyline || obj.constructor === external_L_default.a.polyline) {
    verts = [];
    tmp = obj.getLatLngs();

    if (!tmp[0].equals(tmp[tmp.length - 1])) {
      for (i = 0; i < tmp.length; i += 1) {
        verts.push({
          x: tmp[i].lng,
          y: tmp[i].lat
        });
      }

      return {
        type: 'linestring',
        components: verts
      };
    }
  } // L.Polygon ///////////////////////////////////////////////////////////////


  if (obj.constructor === external_L_default.a.Polygon || obj.constructor === external_L_default.a.polygon) {
    rings = [];
    verts = [];
    boundary = obj.getLatLngs()[0]; // First, we deal with the boundary points

    for (i = 0; i < boundary.length; i += 1) {
      verts.push({
        // Add the first coordinate again for closure
        x: boundary[i].lng,
        y: boundary[i].lat
      });
    }

    verts.push({
      // Add the first coordinate again for closure
      x: boundary[0].lng,
      y: boundary[0].lat
    });
    rings.push(verts); // Now, any holes

    if (obj._holes && obj._holes.length > 0) {
      // Reworked to support holes properly
      verts = _coordsFromLatLngs(obj._holes);

      for (i = 0; i < verts.length; i++) {
        verts[i].push(verts[i][0]); // Copy the beginning coords again for closure

        rings.push(verts[i]);
      }
    }

    return {
      type: 'polygon',
      components: rings
    };
  } // L.MultiPolyline /////////////////////////////////////////////////////////
  // L.MultiPolygon //////////////////////////////////////////////////////////
  // L.LayerGroup ////////////////////////////////////////////////////////////
  // L.FeatureGroup //////////////////////////////////////////////////////////


  if (obj.constructor === external_L_default.a.MultiPolyline || obj.constructor === external_L_default.a.MultiPolygon || obj.constructor === external_L_default.a.LayerGroup || obj.constructor === external_L_default.a.FeatureGroup) {
    features = [];
    tmp = obj._layers;

    for (attr in tmp) {
      if (tmp.hasOwnProperty(attr)) {
        if (tmp[attr].getLatLngs || tmp[attr].getLatLng) {
          // Recursively deconstruct each layer
          features.push(this.deconstruct(tmp[attr]));
        }
      }
    }

    return {
      type: function () {
        switch (obj.constructor) {
          case external_L_default.a.MultiPolyline:
            return 'multilinestring';

          case external_L_default.a.MultiPolygon:
            return 'multipolygon';

          case external_L_default.a.FeatureGroup:
            return function () {
              var i, mpgon, mpline, mpoint; // Assume that all layers are of one type (any one type)

              mpgon = true;
              mpline = true;
              mpoint = true;

              for (i in obj._layers) {
                if (obj._layers.hasOwnProperty(i)) {
                  if (obj._layers[i].constructor !== external_L_default.a.Marker) {
                    mpoint = false;
                  }

                  if (obj._layers[i].constructor !== external_L_default.a.Polyline) {
                    mpline = false;
                  }

                  if (obj._layers[i].constructor !== external_L_default.a.Polygon) {
                    mpgon = false;
                  }
                }
              }

              if (mpoint) {
                return 'multipoint';
              }

              if (mpline) {
                return 'multilinestring';
              }

              if (mpgon) {
                return 'multipolygon';
              }

              return 'geometrycollection';
            }();

          default:
            return 'geometrycollection';
        }
      }(),
      components: function () {
        // Pluck the components from each Wkt
        var i, comps;
        comps = [];

        for (i = 0; i < features.length; i += 1) {
          if (features[i].components) {
            comps.push(features[i].components);
          }
        }

        return comps;
      }()
    };
  } // L.Circle ////////////////////////////////////////////////////////////////


  if (obj.constructor === external_L_default.a.Circle || obj.constructor === external_L_default.a.circle) {
    console.log('Deconstruction of L.Circle objects is not yet supported');
  } else {
    console.log('The passed object does not have any recognizable properties.');
  }
};

/* harmony default export */ var layer_Wkt = (Wkt);
// CONCATENATED MODULE: ./src/service/feature/FeatureAttr.js



var FeatureAttr = external_L_default.a.Class.extend({
  featureService: null,
  fields: null,
  options: {
    isEdit: false,
    //属性框用途，新增要素或编辑要素
    layerId: null,
    //数据集id
    feature: null,
    //当前编辑或添加要素对象
    fId: null,
    //要素主键id
    position: {
      top: 10,
      right: 10
    },
    width: 360,
    height: 310
  },
  initialize: function initialize(featureService, options) {
    this.featureService = featureService;
    external_L_default.a.setOptions(this, options);
    this.getFields(options.layerId);
  },
  getFields: function getFields(layerId) {
    var that = this;
    this.featureService.infoById(layerId, function (res) {
      that.fields = res.layer.fields;
    }, function (e) {
      console.log(e);
    });
  },
  findFieldType: function findFieldType(field) {
    var obj = this.fields.find(function (item) {
      return item.name === field;
    });

    if (obj) {
      return obj.type;
    } else {
      return null;
    }
  },
  render: function render(attributes) {
    var options = this.options;
    var style = "height: ".concat(options.height, "px; width: ").concat(options.width, "px;");

    for (var key in options.position) {
      style += "".concat(key, ": ").concat(options.position[key], "px;");
    }

    var htmlTemplate = "<div class=\"attr-panel\" style=\"".concat(style, "\"><h2>\u5C5E\u6027\u4FE1\u606F<i></i></h2><div class=\"attr-con\"><div class=\"attr-main\"><ul>");

    for (var field in attributes) {
      var fieldValue = attributes[field] || "";
      htmlTemplate += "<li><span style=\"width:40%;\">".concat(field, "</span><span style=\"width:60%;\"><input type=\"text\" value=\"").concat(fieldValue, "\"/></span></li>");
    }

    htmlTemplate += "</ul></div><div class=\"attr-btn\"><button type=\"button\">\u4FDD\u5B58</button><button type=\"button\">\u5220\u9664</button></div></div>";
    var domId = "attr-panel-wrap";
    var container = document.getElementById(domId) || external_L_default.a.DomUtil.create('div', 'attr-panel-wrap');
    container.id = domId;
    container.innerHTML = htmlTemplate;
    var bodyEl = document.getElementsByTagName('body')[0];
    bodyEl.appendChild(container); //绑定弹框关闭事件

    external_L_default.a.DomEvent.on(document.querySelector('.attr-panel i'), 'click', this.close, this); //绑定保存事件

    external_L_default.a.DomEvent.on(document.querySelector('.attr-btn :nth-child(1)'), 'click', this.saveHandle, this); //绑定删除事件

    external_L_default.a.DomEvent.on(document.querySelector('.attr-btn :nth-child(2)'), 'click', this["delete"], this);
  },
  close: function close() {
    if (this.options.feature.editor) {
      this.options.feature.disableEdit();
    }

    var bodyEl = document.getElementsByTagName('body')[0];
    var container = document.getElementsByClassName('attr-panel-wrap')[0];
    bodyEl.removeChild(container);
  },
  saveHandle: function saveHandle() {
    var list = document.getElementsByTagName('li');
    var attributes = {};

    for (var i = 0; i < list.length; i++) {
      var child = list[i].childNodes;
      var field = child[0].innerText;
      var fieldType = this.findFieldType(field);
      var value = child[1].firstChild.value;

      if (["int", "short", "long"].includes(fieldType)) {
        attributes[field] = parseInt(value);
      } else if (["float", "double"].includes(fieldType)) {
        attributes[field] = parseFloat(value);
      } else {
        attributes[field] = value;
      }
    }

    var data = {};
    data.attributes = attributes;
    var wkt = new layer_Wkt.Wkt();
    wkt.fromObject(this.options.feature);
    data.geometry = wkt.write();

    if (this.options.isEdit) {
      data.fId = this.options.fId;
    }

    this.save([data]);
  },
  "delete": function _delete() {
    var that = this;
    var options = this.options;

    if (!options.isEdit) {
      this.featureService.featureGroup.removeLayer(options.feature);
      that.close();
    } else {
      this.featureService.deleteFeatures(options.layerId, options.fId, function (res) {
        that.featureService.fire("feature:delete", res);
        that.close();
      }, function (e) {
        console.error(e);
      });
    }
  },
  save: function save(data) {
    var that = this;
    var options = this.options;

    if (!options.isEdit) {
      this.featureService.addFeatures(options.layerId, data, function (res) {
        that.featureService.fire("feature:save", res);
        that.close();
      }, function (e) {
        console.error(e);
      });
    } else {
      this.featureService.updateFeatures(options.layerId, data, function (res) {
        that.featureService.fire("feature:save", res);
        that.close();
      }, function (e) {
        console.error(e);
      });
    }
  }
});
/* harmony default export */ var feature_FeatureAttr = (FeatureAttr);
// CONCATENATED MODULE: ./src/service/feature/FeatureService.js




var FeatureService = external_L_default.a.Evented.extend({
  options: {
    url: null
  },
  initialize: function initialize(featureGroup, options) {
    this.featureGroup = featureGroup;
    external_L_default.a.setOptions(this, options);
  },

  /**
   * 设置查询服务地址
   * @method L.geoway.service.FeatureService#setUrl
   * @param {string} url - 服务地址
   */
  setUrl: function setUrl(url) {
    this.options.url = url;
  },

  /**
   * 获取地图服务元数据
   * @method L.geoway.service.FeatureService#info
   * @param {Function} successFun -成功回调
   * @param {Function} failFun -失败回调
   */
  info: function info(successFun, failFun) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    url = url + '/info';
    FetchRequest["a" /* default */].get(url).then(function (result) {
      if (result.status === "ok") {
        successFun(result);
      } else {
        if (failFun) {
          failFun(result);
        }
      }
    })["catch"](function (e) {
      if (failFun) {
        failFun(e);
      }
    });
  },

  /**
   * 获取地图服务中某个图层元数据
   * @method L.geoway.service.FeatureService#infoById
   * @param {string} layerID -图层id
   * @param {Function} successFun -成功回调
   * @param {Function} failFun -失败回调
   */
  infoById: function infoById(layerID, successFun, failFun) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    url = url + '/' + layerID + '/info';
    FetchRequest["a" /* default */].get(url).then(function (result) {
      if (result.status === "ok") {
        successFun(result);
      } else {
        if (failFun) {
          failFun(result);
        }
      }
    })["catch"](function (e) {
      if (failFun) {
        failFun(e);
      }
    });
  },

  /**
   * 对单个图层进行空间&属性查询
   * @method L.geoway.service.FeatureService#query
   * @param {Object} params - 查询参数
   * @param {string} params.layerId - 图层id
   * @param {string} [params.geometry] - 用于查询的几何图形,wkt字符串
   * @param {string} [params.spatialOper=Intersects] - 空间关系，如：Intersects（默认）、Touches、Crosses、Within、Contains
   * @param {string} [params.where] - 属性查询语句，例如：name like %区%
   * @param {string} [params.orderBy] - 排序字段，多个用逗号(,)分隔
   * @param {boolean} [params.getGeometry=true]- 是否返回要输的图形信息，默认true
   * @param {number} [params.pageNum=0] - 查询分页数，默认为0
   * @param {number} [params.pageSize=10] - 每页结果返回个数，默认为10
   * @param {Function} successFun -成功回调
   * @param {Function} failFun -失败回调
   */
  query: function query(params, successFun, failFun) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    if (!params && !params.layerId) {
      return false;
    }

    url = url + '/' + params.layerId + '/query';
    var data = {};

    for (var key in params) {
      if (key === 'layerId') {
        continue;
      }

      data[key] = params[key];
    }

    FetchRequest["a" /* default */].get(url, data).then(function (result) {
      if (result.status === 'ok') {
        successFun(result);
      } else {
        if (failFun) {
          failFun(result);
        }
      }
    })["catch"](function (e) {
      if (failFun) {
        failFun(e);
      }
    });
  },

  /**
   * 对多个图层进行空间&属性查询
   * @method L.geoway.service.FeatureService#queryMulti
   * @param {Object} params -查询参数
   * @param {string} [params.geometry] -用于查询的几何图形,wkt字符串
   * @param {string} [params.spatialOper=Intersects] -空间关系，如：Intersects、Touches、Crosses、Within、Contains
   * @param {boolean} [params.getGeometry=TRUE] -是否返回要输的图形信息
   * @param {Object[]} params.layers -要查询的图层及图层上的自定义条件
   * @param {string} params.layers[].layerid -图层ID
   * @param {string} [params.layers[].where] -属性查询条件
   * @param {string} [params.layers[].orderBy] -排序字段
   * @param {number} [params.layers[].pageNum=0] -当前页码
   * @param {number} [params.layers[].pageSize=10] -每页条数
   * @param {Function} successFun -成功回调
   * @param {Function} failFun -失败回调
   */
  queryMulti: function queryMulti(params, successFun, failFun) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    url = url + '/querymulti';
    params.layers = JSON.stringify(params.layers);
    FetchRequest["a" /* default */].get(url, params).then(function (result) {
      if (result.status === 'ok') {
        successFun(result);
      } else {
        if (failFun) {
          failFun(result);
        }
      }
    })["catch"](function (e) {
      if (failFun) {
        failFun(e);
      }
    });
  },

  /**
   * identify查询
   * @method L.geoway.service.FeatureService#identify
   * @param {number} x -i查询x坐标
   * @param {number} y -i查询y坐标
   * @param {Function} successFun -成功回调
   * @param {Function} failFun -失败回调
   */
  identify: function identify(data, successFun, failFun) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    url = url + '/identify';
    FetchRequest["a" /* default */].get(url, data).then(function (result) {
      if (result.status === 'ok') {
        successFun(result);
      } else {
        if (failFun) {
          failFun(result);
        }
      }
    })["catch"](function (e) {
      if (failFun) {
        failFun(e);
      }
    });
  },

  /**
   * 获取要素详细信息
   * @method L.geoway.service.FeatureService#detail
   * @param {string} layerID - 地图中图层ID
   * @param {string} fids - 要素的objectid,多个用逗号分隔
   * @param {Function} successFun -成功回调
   * @param {Function} failFun -失败回调
   */
  detail: function detail(layerID, fids, successFun, failFun) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    url = url + '/' + layerID + '/detail';
    FetchRequest["a" /* default */].get(url, {
      fids: fids
    }).then(function (result) {
      if (result.status === 'ok') {
        successFun(result);
      } else {
        if (failFun) {
          failFun(result);
        }
      }
    })["catch"](function (e) {
      if (failFun) {
        failFun(e);
      }
    });
  },

  /**
   * 添加要素
   * @method L.geoway.service.FeatureService#addFeatures
   * @param {string} layerID - 地图中图层ID
   * @param {Object} data - 添加的feature json数据
   * @param {Function} successFun -成功回调
   * @param {Function} failFun -失败回调
   * 参数示例 data= [{
     geometry:"POLYGON((116.68750000000011 28.125000000000057,116.68750000000011 28.166666667000072,116.75000000000011 28.166666667000072,116.75000000000011 28.125000000000057,116.68750000000011 28.125000000000057))",
     attributes:
     {F_FRAME:"H50G093044_v",
      NEW_MAPNO:"H50G093044_v",
      SHAPE_Leng:2000,
      F_RENDER:0
      }}];
   */
  addFeatures: function addFeatures(layerID, data, successFun, failFun) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    url = url + '/' + layerID + '/addFeatures';
    FetchRequest["a" /* default */].post(url, data).then(function (result) {
      if (result.status === 'ok') {
        successFun(result);
      } else {
        if (failFun) {
          failFun(result);
        }
      }
    })["catch"](function (e) {
      if (failFun) {
        failFun(e);
      }
    });
  },

  /**
   * 编辑要素
   * @method L.geoway.service.FeatureService#updateFeatures
   * @param {string} layerID - 地图中图层ID
   * @param {Object} data
   * @param {Function} successFun -成功回调
   * @param {Function} failFun -失败回调
   */
  updateFeatures: function updateFeatures(layerID, data, successFun, failFun) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    url = url + '/' + layerID + '/updateFeatures';
    FetchRequest["a" /* default */].post(url, data).then(function (result) {
      if (result.status === 'ok') {
        successFun(result);
      } else {
        if (failFun) {
          failFun(result);
        }
      }
    })["catch"](function (e) {
      if (failFun) {
        failFun(e.message);
      }
    });
  },

  /**
   * 删除要素
   * @method L.geoway.service.FeatureService#deleteFeatures
   * @param {string} layerID - 地图中图层ID
   * @param {string} objectIds - 删除要素的主键，多个用逗号分隔
   * @param {Function} successFun -成功回调
   * @param {Function} failFun -失败回调
   */
  deleteFeatures: function deleteFeatures(layerID, objectIds, successFun, failFun) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    url = url + '/' + layerID + '/deleteFeatures' + '?objectIds=' + objectIds;
    FetchRequest["a" /* default */].post(url).then(function (result) {
      if (result.status === 'ok') {
        successFun(result);
      } else {
        if (failFun) {
          failFun(result);
        }
      }
    })["catch"](function (e) {
      if (failFun) {
        failFun(e);
      }
    });
  },

  /**
   * 缓冲区分析
   * @method L.geoway.service.FeatureService#bufferAnalysis
   * @param {string} layerID - 地图中图层ID
   * @param {Object} data - 查询参数，json对象
   * @param {number} data.fId -要素主键id
   * @param {number} data.distance - 缓冲区半径，单位m
   * @param {number} data.type=1 - 类型1、2、3，默认值为1
   * @param {number} data.accuracy=8 - 图形精度，默认值为8
   * @param {Function} successFun -成功回调
   * @param {Function} failFun -失败回调
   */
  bufferAnalysis: function bufferAnalysis(layerID, data, successFun, failFun) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    url = url + '/' + layerID + '/bufferAnalysis';
    FetchRequest["a" /* default */].post(url, data).then(function (result) {
      if (result.status === 'ok') {
        successFun(result);
      } else {
        if (failFun) {
          failFun(result);
        }
      }
    })["catch"](function (e) {
      if (failFun) {
        failFun(e);
      }
    });
  },

  /**
   * 叠加分析
   * @method L.geoway.service.FeatureService#overlayAnalysis
   * @param {Object} data - 查询参数，json对象
   * @param {number} data.sourceLayer -源图层id
   * @param {number} data.targetLayer -目标图层id
   * @param {Function} successFun -成功回调
   * @param {Function} failFun -失败回调
   */
  overlayAnalysis: function overlayAnalysis(data, successFun, failFun) {
    var url = this.options.url;

    if (!url) {
      return false;
    }

    url = url + '/overlayAnalysis';
    FetchRequest["a" /* default */].post(url, data).then(function (result) {
      if (result.status === 'ok') {
        successFun(result);
      } else {
        if (failFun) {
          failFun(result);
        }
      }
    })["catch"](function (e) {
      if (failFun) {
        failFun(e);
      }
    });
  },

  /**
   * 配置要素服务属性框，并显示。
   * @method L.geoway.service.FeatureService#showAttr
   * @param {Object} options -属性配置
   * @param {boolean} [options.isEdit] -属性框用途，新增要素或编辑要素
   * @param {number} options.layerId -数据集id
   * @param {Object} options.feature -当前编辑或添加要素对象
   * @param {number} options.fId -要素主键id
   * @param {Object} [options.position] -属性框位置
   * @param {number} [options.width] -属性框宽度
   * @param {number} [options.height] -属性框高度
   * @param {Object} attributes -要素属性信息
   */
  showAttr: function showAttr(options, attributes) {
    var featureAttr = new feature_FeatureAttr(this, options);
    featureAttr.render(attributes);
  }
});
var FeatureService_featureService = function featureService(featureGroup, options) {
  return new FeatureService(featureGroup, options);
};
external_L_default.a.geoway.service.featureService = FeatureService_featureService;
external_L_default.a.geoway.service.FeatureService = FeatureService;
// CONCATENATED MODULE: ./src/service/index.js









/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./src/layer/label/avoid/GDistance.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by matt on 2017/3/5.
 */
var GDistance = /*#__PURE__*/function () {
  function GDistance() {
    _classCallCheck(this, GDistance);
  }

  _createClass(GDistance, [{
    key: "getLengthPoint",
    value: function getLengthPoint(fromX, fromY, toX, toY, len, index) {
      var dx = toX - fromX;
      var dy = toY - fromY;
      var x_new;
      var y_new;

      if (dx == 0) {
        x_new = toX;

        if (dy > 0) {
          y_new = fromY + len;
        } else {
          y_new = fromY - len;
        }

        if (index == null) {
          return [x_new, y_new];
        } else {
          return [x_new, y_new, index];
        }
      }

      var tan = dy / dx;
      var sec = Math.sqrt(tan * tan + 1);
      var dx_new = Math.abs(len / sec);
      var dy_new = Math.abs(dx_new * tan);

      if (dx > 0) {
        x_new = fromX + dx_new;
      } else {
        x_new = fromX - dx_new;
      }

      if (dy > 0) {
        y_new = fromY + dy_new;
      } else {
        y_new = fromY - dy_new;
      }

      if (index == null) {
        return [x_new, y_new];
      } else {
        return [x_new, y_new, index];
      }
    }
  }, {
    key: "getAngle",
    value: function getAngle(p1, p2) {
      if (p2[0] - p1[0] == 0) {
        if (p2[1] > p1[0]) {
          return 90;
        } else {
          return -90;
        }
      }

      var k = (p2[1] - p1[1]) / (p2[0] - p1[0]);
      var angle = 360 * Math.atan(k) / (2 * Math.PI);
      return angle;
    }
  }, {
    key: "length",
    value: function length(x0, y0, x1, y1) {
      var dx = x1 - x0;
      var dy = y1 - y0;
      var len = Math.sqrt(dx * dx + dy * dy);
      return len;
    }
  }, {
    key: "getNodePath",
    value: function getNodePath(coords, interval) {
      var previous = [];
      var points = {};
      var pointList = [];
      var intervalLength = interval.length; //初始化标记长度等于单位长度

      var fun_getInterval = function fun_getInterval(interval) {
        var value = interval[0];
        interval.splice(0, 1);
        return value;
      };

      var markLength = fun_getInterval(interval);
      var index = 0;

      while (true) {
        if (pointList.length == intervalLength) {
          points.index = index;
          points.pointList = pointList;
          return points;
        }

        if (index >= coords.length) {
          points.index = index;
          points.pointList = pointList;
          return points;
        }

        var x = coords[index];
        var y = coords[index + 1]; //判断上一个节点是否为空

        if (previous.length == 0) {
          //如果为空就设置当前点到 上一个节点上
          previous[0] = x;
          previous[1] = y;
          continue;
        } else {
          //如果不为空则需要求上一个节点与当前结点的距离
          var lengthPath = this.length(previous[0], previous[1], x, y); //把节点长度加起来

          if (lengthPath >= markLength) {
            //如果长度大于标记长度，则需要上一点到标记成都的点
            var savePoint = this.getLengthPoint(previous[0], previous[1], x, y, markLength, null);
            var angle = this.getAngle(previous, [x, y]);

            if (angle == 90) {
              angle = 0;
            }

            if (angle == -90) {
              angle = 0;
            }

            if (angle == 0) {
              angle = 0.5;
            } //保证竖方向的字是正的


            if (angle >= 45) {
              angle = angle - 90;
            } else {
              if (angle <= -45) {
                angle = angle + 90;
              }
            }

            var pointAngle = [savePoint, angle];
            pointList.push(pointAngle);
            previous[0] = savePoint[0];
            previous[1] = savePoint[1];
            markLength = fun_getInterval(interval);
          } else {
            markLength = markLength - lengthPath;
            previous[0] = x;
            previous[1] = y;
            index = index + 2;
          }
        }
      }

      points.index = index;
      points.pointList = pointList;
      return points;
    }
  }]);

  return GDistance;
}();

/* harmony default export */ var avoid_GDistance = (GDistance);
// EXTERNAL MODULE: ./src/util/gistools/GisTools.js
var GisTools = __webpack_require__(8);

// EXTERNAL MODULE: ./src/layer/label/avoid/AvoidUtil.js
var AvoidUtil = __webpack_require__(6);

// CONCATENATED MODULE: ./src/layer/label/avoid/GCutLine.js
function GCutLine_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GCutLine_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function GCutLine_createClass(Constructor, protoProps, staticProps) { if (protoProps) GCutLine_defineProperties(Constructor.prototype, protoProps); if (staticProps) GCutLine_defineProperties(Constructor, staticProps); return Constructor; }





var GCutLine_GCutLine = /*#__PURE__*/function () {
  function GCutLine() {
    GCutLine_classCallCheck(this, GCutLine);
  }

  GCutLine_createClass(GCutLine, null, [{
    key: "cutLineFeature",
    value: function cutLineFeature(feature, style) {
      var fs = [];
      var index = 0;

      if (feature.sourceData.length < 4) {
        return fs;
      }

      var cutFunctionArray = [{
        weight: feature.codeAvoidWeight,
        fun: this.createLineCodeFeatrue
      }, {
        weight: feature.weight,
        fun: this.createLineTextFeatrue
      }, {
        weight: feature.arrowAvoidWeight,
        fun: this.createLineArrowFeatrue
      }];
      cutFunctionArray = this.sort(cutFunctionArray);

      for (var i = 0; i < cutFunctionArray.length; i++) {
        var cutFun = cutFunctionArray[i].fun;
        var f = cutFun.call(this, feature, style, index);
        index = f.index;

        if (f.feature) {
          fs.push(f.feature);
        }
      } // let lineText = this.createLineTextFeatrue(feature,style,index);
      // index = lineText.index;
      // if(lineText.feature){
      //     fs.push(lineText.feature);
      // }
      //
      // let lineCode= this.createLineCodeFeatrue(feature,style,index);
      // index = lineCode.index;
      // if(lineCode.feature){
      //     fs.push(lineCode.feature);
      // }
      //
      // let lineArrow= this.createLineArrowFeatrue(feature,style,index);
      // if(lineArrow.feature){
      //     fs.push(lineArrow.feature);
      // }


      return fs;
    } //线编码，线文字，线箭头权重排序.

  }, {
    key: "sort",
    value: function sort(array) {
      if (array.length > 0) {
        //从大到少排序
        return array.sort(function (a, b) {
          if (a.weight < b.weight) {
            return 1;
          } else if (a.weight == b.weight) {
            return 0;
          } else {
            return -1;
          }
        });
      }
    }
    /**
     * 创建线文字注记
     *  Parameters :
     *  feature
     *  index - 可用的line的index位置
     */

  }, {
    key: "createLineTextFeatrue",
    value: function createLineTextFeatrue(feature, style, index) {
      var line = feature.sourceData;
      var d = new avoid_GDistance();
      var gaps = [];
      var textFeature = null;

      if (AvoidUtil["a" /* default */].isNotNull(feature.label) && index < line.length) {
        //线注记的文字内容
        feature.label = feature.label + '';

        for (var count = 0; count < feature.label.length; count++) {
          gaps.push(style.lineHeight * 1.2 + 2 + style.gap);
        }

        gaps[0] = gaps[0] + 30;
        var cloneGaps = [].concat(gaps);
        var points = d.getNodePath(line, gaps);
        var textPoints = points.pointList;

        if (textPoints.length > 0) {
          index = points.index;

          if (style.isTransverse) {
            textFeature = this.cloneFeature(feature);
            textFeature.attributeId = textFeature.attributeId + '_text';
            textFeature.sourceAngleData = [textPoints[0]];
            textFeature.lineType = 'text'; // return {feature:textFeature,index:index};
          } else {
            //需要延长的字个数
            var delayLength = feature.label.length - textPoints.length;

            if (delayLength > 0) {
              index = line.length; //摆不下的字数少于3个字延长

              if (delayLength < style.extendedNum) {
                this.delayTextPoint(line, textPoints, feature.label, style.chinaLabelWidth + style.gap);
              } else {
                return {
                  feature: null,
                  index: index
                };
              }
            }

            var p1 = [textPoints[0][0][0], textPoints[0][0][1]];
            var p2 = textPoints[textPoints.length - 1][0]; //获取两点连线与x轴的夹角

            var angle = AvoidUtil["a" /* default */].getAngle(p1, p2);
            textFeature = this.cloneFeature(feature);
            textFeature.angle = angle;

            if (style.changeDirection != false) {
              //改变方向
              //判断是否应该换方向
              var showChanged = this.isChangeDirection(feature.label, p1, p2, angle);

              if (showChanged) {
                textPoints = textPoints.reverse();
              }
            }

            textFeature.attributeId = textFeature.attributeId + '_text';
            textFeature.sourceAngleData = textPoints;
            textFeature.lineType = 'text';
          }
        } //平移


        if (style.lineOffset && textFeature) {
          if (textFeature.sourceAngleData.length == 1) {
            textFeature.sourceAngleData[0][0][1] = textFeature.sourceAngleData[0][0][1] - style.lineOffset;
          } else {
            textFeature.sourceAngleData = GisTools["a" /* default */].lineOffset(textFeature.sourceAngleData, style.lineOffset);
          }
        }
      }

      return {
        feature: textFeature,
        index: index
      };
    }
    /**
     * 创建线编码注记
     *  Parameters :
     *  feature
     *  index - 可用的line的index位置
     */

  }, {
    key: "createLineCodeFeatrue",
    value: function createLineCodeFeatrue(feature, style, index) {
      var line = feature.sourceData;
      var d = new avoid_GDistance();
      var gaps = [];
      var codeFeature = null;
      var roadLabel = feature.roadCodeLabel; //如果有道路编码

      if (style.showRoadCode && AvoidUtil["a" /* default */].isNotNull(roadLabel) && index < line.length) {
        var codeLine = line.slice(index, line.length - 1); //默认是30个像素

        gaps.push(30);
        var cPoints = d.getNodePath(codeLine, gaps);
        var codePoints = cPoints.pointList;

        if (codePoints.length == 1) {
          index = index + cPoints.index;
          codeFeature = this.cloneFeature(feature);
          codeFeature.attributeId = codeFeature.attributeId + '_code';
          codeFeature.sourceAngleData = codePoints;
          codeFeature.lineType = 'code';
          codeFeature.label = roadLabel + '';
          codeFeature.weight = feature.codeAvoidWeight;
        } //
        // if(codePoints.length ==0){
        //     codeFeature =  this.cloneFeature(feature);
        //     codeFeature.attributeId = codeFeature.attributeId+'_code';
        //     codeFeature.sourceAngleData = [[[line[0],line[1]],0]];
        //     codeFeature.lineType = 'code';
        //     codeFeature.label = roadLabel+'';
        //     index = index  + 2;
        //     return {feature:codeFeature,index:index};
        // }

      }

      return {
        feature: codeFeature,
        index: index
      };
    }
    /**
     * 创建线箭头注记
     *  Parameters :
     *  feature
     *  index - 可用的line的index位置
     */

  }, {
    key: "createLineArrowFeatrue",
    value: function createLineArrowFeatrue(feature, style, index) {
      var line = feature.sourceData;
      var d = new avoid_GDistance();
      var gaps = [];
      var arrowFeature = null; //如果有箭头

      if (style.showArrow && index < line.length) {
        var direction = style.arrowDirectionValue;

        if (style.arrowDirectionField) {
          direction = feature.attributes[style.arrowDirectionField];
        }

        style.arrowSize = style.arrowSize ? style.arrowSize : 6;
        style.arrowDistance = style.arrowDistance ? style.arrowDistance : 12;
        style.arrowLineWidth = style.arrowLineWidth ? style.arrowLineWidth : 2;
        style.arrowStrokeStyle = style.arrowStrokeStyle ? style.arrowStrokeStyle : '#666666';
        style.arrowFillStyle = style.arrowFillStyle ? style.arrowFillStyle : '#666666';
        style.arrowDirectionValue = style.arrowDirectionValue ? style.arrowDirectionValue : 0;
        var arrowLine = line.slice(index, line.length - 1);
        gaps.push(16);

        if (direction == 0) {
          gaps.push(style.arrowSize);
          gaps.push(style.arrowDistance);
        } else {
          gaps.push(style.arrowDistance);
          gaps.push(style.arrowSize);
        }

        var aPoints = d.getNodePath(arrowLine, gaps);
        var arrowPoints = aPoints.pointList;

        if (arrowPoints.length == 3) {
          arrowFeature = this.cloneFeature(feature);
          arrowFeature.attributeId = arrowFeature.attributeId + '_arrow';
          arrowFeature.sourceAngleData = arrowPoints;
          arrowFeature.lineType = 'arrow';
          arrowFeature.weight = feature.arrowAvoidWeight;
        }
      }

      return {
        feature: arrowFeature,
        index: index
      };
    }
    /**
     * 当线文字放不下时，获取延长线上的点
     *  Parameters :
     *  line - 原始线坐标
     *  textPoints - 切割之后的点坐标
     *  label - 线注记
     *  gap - 每个字之间的间隔
     *  showChanged
     *
     */

  }, {
    key: "delayTextPoint",
    value: function delayTextPoint(line, textPoints, label, gap) {
      var fristPoint = null;
      var secondPoint = null; //如果只能放下一个字

      if (textPoints.length == 1) {
        fristPoint = [line[0], line[1]];
      } else {
        fristPoint = textPoints[textPoints.length - 2][0];
      }

      secondPoint = textPoints[textPoints.length - 1][0];
      var angle = textPoints[textPoints.length - 1][1];
      var len = textPoints.length;

      for (var i = 1; i < label.length - len + 1; i++) {
        var p = this.getPoint(fristPoint, secondPoint, gap * i);
        var textPoint = [p, angle];
        textPoints.push(textPoint);
      }
    }
    /**
     * 克隆feature
     *  Parameters :
     *  feature - 单个线注记要素
     */

  }, {
    key: "cloneFeature",
    value: function cloneFeature(feature) {
      return {
        type: feature.type,
        datas: feature.datas,
        centerPoint: feature.centerPoint,
        sourceData: feature.sourceData,
        label: feature.label,
        roadCodeLabel: feature.roadCodeLabel,
        attributes: feature.attributes,
        attributeId: feature.attributeId,
        styleId: feature.styleId,
        textures: feature.textures,
        xyz: feature.xyz,
        lineType: feature.lineType,
        weight: feature.weight
      };
    }
    /**
     * 是否需要改变线的方向
     *  Parameters :
     *  p1 - 线段起点
     *  p2 -线段的重点
     *  angle - 两点连线与x轴的夹角
     */

  }, {
    key: "isChangeDirection",
    value: function isChangeDirection(label, p1, p2, angle) {
      var showChange = false; //判断是否包含汉字

      if (/.*[\u4e00-\u9fa5]+.*$/.test(label)) {
        //如果是垂直线
        if (p1[0] == p2[0]) {
          if (p1[1] > p2[1]) {
            showChange = true;
            return showChange;
          }
        } //如果是反斜线，并且夹角与x轴的夹角大于45度


        if (angle < -45 && angle > -90) {
          if (p1[0] < p2[0]) {
            showChange = true;
          }
        } else {
          if (p1[0] > p2[0]) {
            showChange = true;
          }
        }
      } else {
        if (p1[0] > p2[0]) {
          showChange = true;
        }
      }

      return showChange;
    }
    /**
     * 求两点之间的距离
     */

  }, {
    key: "getDistance",
    value: function getDistance(p1, p2) {
      var calX = p2[0] - p1[0];
      var calY = p2[1] - p1[1];
      return Math.pow(calX * calX + calY * calY, 0.5);
    }
    /**
     * 获取线的长度
     */

  }, {
    key: "getLineDistance",
    value: function getLineDistance(line) {
      if (line.length < 4) {
        return 0;
      }

      var dis = 0;

      for (var i = 0; i < line.length / 2 - 1; i++) {
        var p1 = [line[2 * i], line[2 * i + 1]];
        var p2 = [line[2 * (i + 1)], line[2 * (i + 1) + 1]];
        dis = dis + this.getDistance(p1, p2);
      }

      return dis;
    }
    /**
     * 已知两点，延长距离，获取延长线上的点坐标
     */

  }, {
    key: "getPoint",
    value: function getPoint(p1, p2, d) {
      var xab = p2[0] - p1[0];
      var yab = p2[1] - p1[1];
      var xd = p2[0];
      var yd = p2[1];

      if (xab == 0) {
        if (yab > 0) {
          yd = p2[1] + d;
        } else {
          yd = p2[1] - d;
        }
      } else {
        var xbd = Math.sqrt(d * d / (yab / xab * (yab / xab) + 1));

        if (xab < 0) {
          xbd = -xbd;
        }

        xd = p2[0] + xbd;
        yd = p2[1] + yab / xab * xbd;
      }

      return [xd, yd];
    }
  }]);

  return GCutLine;
}();

/* harmony default export */ var avoid_GCutLine = (GCutLine_GCutLine);
// CONCATENATED MODULE: ./src/layer/label/avoid/ParseLabelData.js
function ParseLabelData_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ParseLabelData_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ParseLabelData_createClass(Constructor, protoProps, staticProps) { if (protoProps) ParseLabelData_defineProperties(Constructor.prototype, protoProps); if (staticProps) ParseLabelData_defineProperties(Constructor, staticProps); return Constructor; }


 //import textureManager from './../../../../src/process/texture/TextureManager';

var TextureManager = null;

var ParseLabelData_ParseLabelData = /*#__PURE__*/function () {
  function ParseLabelData() {
    ParseLabelData_classCallCheck(this, ParseLabelData);
  }

  ParseLabelData_createClass(ParseLabelData, null, [{
    key: "parseLayerDatas",

    /**
     * 解析瓦片内注记数据
     * @param layerDatas
     * @param styleMap
     * @param isClient
     * @param maxExtent
     * @param extent
     * @param res
     * @param tileSize
     */
    value: function parseLayerDatas(layerDatas, styleMap, xyz, isClient, maxExtent, extent, res, tileSize) {
      var pointFeatures = [];
      var lineFeatures = [];

      for (var layername in layerDatas) {
        if (layername == '_layerAvoids') {
          continue;
        }

        var layerData = layerDatas[layername];
        layerData.xyz = xyz;
        var propertyGetter = ParseLabelData.getProperty(layerData.fieldsConfig);

        if (layerData.type == 1) {
          var pfs = ParseLabelData.parsePointLayer(layerData, layername, propertyGetter, styleMap, isClient, maxExtent, extent, res, tileSize);
          pointFeatures = pointFeatures.concat(pfs);
        }

        if (layerData.type == 2) {
          var lfs = ParseLabelData.parseLineLayer(layerData, layername, propertyGetter, styleMap, isClient, maxExtent, extent, res, tileSize);
          lineFeatures = lineFeatures.concat(lfs);
        }
      }

      return {
        pointFeatures: pointFeatures,
        lineFeatures: lineFeatures
      };
    }
  }, {
    key: "updateFeatureAttr",
    value: function updateFeatureAttr(features, styleMap, ratio, textures, isClient, maxExtent, extent, res, tileSize) {
      for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        var style = styleMap[feature.styleId];

        if (isClient) {
          feature.iconImg = textures[style.texture];
        } else {
          if (TextureManager == null) {
            TextureManager = null;
          }

          if (style.texture) {
            var texture = TextureManager.getTexture(style.texture);

            if (texture != null) {
              feature.iconImg = texture.toPattern(ratio);
            }
          }
        }

        ParseLabelData.parsePoint(feature, style, isClient, maxExtent, extent, res, tileSize);
      }

      return features;
    }
    /**
     *  解析点图层数据
     */

  }, {
    key: "parsePointLayer",
    value: function parsePointLayer(layerData, layername, propertyGetter, styleMap, isClient, maxExtent, extent, res, tileSize) {
      var pointFeatures = [];

      for (var i = 0; i < layerData.features.length; i++) {
        var feature = layerData.features[i];
        var style = styleMap[feature.styleId];

        if (!style || !style.show || style.type != "_default__" && !style.labelfield && !style.texture) {
          continue;
        }

        feature.centerPoint = feature[2];
        feature.attributeId = layername + '__' + feature[1][propertyGetter.idIndex];
        feature.layerName = layername;
        feature.xyz = layerData.xyz;
        feature.propertyGetter = propertyGetter;
        feature.type = layerData.type;
        feature.weight = feature.avoidWeight;

        if (feature.avoidWeight == null || isNaN(feature.avoidWeight)) {
          feature.avoidWeight = style.avoidWeight;
          feature.weight = feature.avoidWeight;

          if (feature.weight == null) {
            feature.weight = 0;
            feature.avoidWeight = 0;
          }
        }

        if (style.isImportant) {
          feature.avoidWeight = 99999999;
          feature.weight = 99999999;
        }

        pointFeatures.push(feature);
      }

      return pointFeatures;
    }
    /**
     *  解析线图层数据
     */

  }, {
    key: "parseLineLayer",
    value: function parseLineLayer(layerData, layername, propertyGetter, styleMap, isClient, maxExtent, extent, res, tileSize) {
      var lineFeatures = [];

      for (var i = 0; i < layerData.features.length; i++) {
        var feature = layerData.features[i];
        var style = styleMap[feature.styleId];

        if (!style || !style.show || style.type != "_default__" && !style.labelfield && !style.roadCodeLabel) {
          continue;
        }

        feature.layerName = layername;
        var features = ParseLabelData.parseLine(feature, style, layerData, propertyGetter, isClient, maxExtent, extent, res, tileSize);
        lineFeatures = lineFeatures.concat(features);
      }

      return lineFeatures;
    }
    /**
     *  解析点数据
     * @param feature
     * @param style
     * @param isClient
     * @returns {Array}
     */

  }, {
    key: "parsePoint",
    value: function parsePoint(feature, style, isClient, maxExtent, extent, res, tileSize) {
      feature.attributes = ParseLabelData.getAttributes(feature[1], feature.propertyGetter);
      var point = feature[2];
      var sourceAngleData = [[point, 0]];
      var label = feature.attributes[style.labelfield];
      feature.primaryId = feature.attributeId + '_row_' + feature.xyz.y + '_col_' + feature.xyz.x + '_level_' + feature.xyz.l + '_x_' + sourceAngleData[0][0][0] + '_y_' + sourceAngleData[0][0][1]; //去掉尾部的空格

      feature.label = AvoidUtil["a" /* default */].formatLabel(label);
      feature.weight = feature.avoidWeight;
      var radius = 0;

      if (style.pointBoxDisance) {
        radius = style.pointBoxDisance * 0.5;
      }

      feature.filterBox = [feature.centerPoint[0] - radius, feature.centerPoint[1] - radius, feature.centerPoint[0] + radius, feature.centerPoint[1] + radius]; // feature.directions = directions;

      feature.sourceData = point;
      feature.sourceAngleData = sourceAngleData;

      if (isClient) {
        feature.id = Math.round(Math.random() * 256 * 256 * 256);
        feature.datas = ParseLabelData.transformData(sourceAngleData, feature.xyz, maxExtent, extent, res, tileSize);
      } else {
        feature.datas = sourceAngleData;
      }

      return feature;
    }
    /**
     *  解析线数据
     * @param itemData
     * @param style
     * @param isClient
     * @returns {Array}
     */

  }, {
    key: "parseLine",
    value: function parseLine(feature, style, layerData, propertyGetter, isClient, maxExtent, extent, res, tileSize) {
      if (feature[2].length == 0) {
        return [];
      }

      var lines = [];
      ParseLabelData.processLineString(lines, feature[2], feature, style, layerData, propertyGetter, isClient, maxExtent, extent, res, tileSize);
      return lines;
    }
  }, {
    key: "processLineString",
    value: function processLineString(lines, components, feature, style, layerData, propertyGetter, isClient, maxExtent, extent, res, tileSize) {
      if (Array.isArray(components[0])) {
        var len = components.length;

        for (var i = 0; i < len; i++) {
          var component = components[i];
          ParseLabelData.processLineString(lines, component, feature, style, layerData, propertyGetter, isClient, maxExtent, extent, res, tileSize);
        }
      } else {
        var ls = ParseLabelData.parseMultiLine(feature, components, layerData, propertyGetter, style, isClient, maxExtent, extent, res, tileSize);

        for (var _i = 0; _i < ls.length; _i++) {
          lines.push(ls[_i]);
        }
      }
    }
    /**
     *  解析多线数据
     * @param itemData
     * @param style
     * @param isClient
     * @returns {Array}
     */

  }, {
    key: "parseMultiLine",
    value: function parseMultiLine(feature, line, layerData, propertyGetter, style, isClient, maxExtent, extent, res, tileSize) {
      var attributes = ParseLabelData.getAttributes(feature[1], propertyGetter);
      var multiLines = [];
      var label = attributes[style.labelfield];
      var roadCodeLabel = attributes[style.roadCodeLabel]; //去掉尾部的空格

      label = AvoidUtil["a" /* default */].formatLabel(label); //去掉尾部的空格

      roadCodeLabel = AvoidUtil["a" /* default */].formatLabel(roadCodeLabel);
      var attributeId = feature.layerName + '__' + feature[1][propertyGetter.idIndex];
      var weight = feature.avoidWeight;

      if (style.isImportant) {
        weight = 99999999;
      }

      var featureItem = {
        type: layerData.type,
        sourceData: line,
        label: label,
        weight: feature.avoidWeight,
        codeAvoidWeight: feature.codeAvoidWeight,
        arrowAvoidWeight: feature.arrowAvoidWeight,
        roadCodeLabel: roadCodeLabel,
        attributes: attributes,
        attributeId: attributeId,
        styleId: feature.styleId,
        xyz: layerData.xyz,
        layerName: feature.layerName
      };
      multiLines = multiLines.concat(ParseLabelData.cutLineFeature(featureItem, style, isClient, false, maxExtent, extent, res, tileSize));
      return multiLines;
    }
    /**
     *  切割线注记
     * @param feature
     * @param style
     * @param isClient
     * @param isLocal
     * @returns {*}
     */

  }, {
    key: "cutLineFeature",
    value: function cutLineFeature(feature, style, isClient, isLocal, maxExtent, extent, res, tileSize) {
      if (isClient) {
        if (style.type == '_default__') {
          feature.sourceAngleData = ParseLabelData.lineToSourceAngleData(feature.sourceData);
          feature.datas = ParseLabelData.transformData(feature.sourceAngleData, feature.xyz, maxExtent, extent, res, tileSize);
          return [feature];
        }
      }

      var features = avoid_GCutLine.cutLineFeature(feature, style, isClient); //默认外扩为10

      var radius = 0.1;

      for (var i = 0; i < features.length; i++) {
        var f = features[i];
        f.primaryId = f.attributeId + '_row_' + feature.xyz.y + '_col_' + feature.xyz.x + '_level_' + feature.xyz.l + '_x_' + f.sourceAngleData[0][0][0] + '_y_' + f.sourceAngleData[0][0][1];

        if (isClient) {
          //转换为屏幕坐标
          if (isLocal) {
            f.datas = feature.transformData(this.extent, this.res);
          } else {
            f.datas = ParseLabelData.transformData(f.sourceAngleData, f.xyz, maxExtent, extent, res, tileSize);
          } //用于拾取的id


          f.id = Math.round(Math.random() * 256 * 256 * 256);
        } else {
          f.datas = f.sourceAngleData;
        }

        f.layerName = feature.layerName; //获取注记的中心点

        if (f.lineType == 'text') {
          var centerIndex = Math.floor(f.sourceAngleData.length / 2);
          f.centerPoint = f.sourceAngleData[centerIndex][0];

          if (style.lineTextBoxDisance) {
            //杭州的外扩距离设置太大，导致大片没线注记，故注释掉了这段
            radius = style.lineTextBoxDisance * 0.5;
          }
        } //获取注记的中心点


        if (f.lineType == 'code') {
          f.centerPoint = f.sourceAngleData[0][0];

          if (style.lineCodeBoxDisance) {
            radius = style.lineCodeBoxDisance * 0.5;
          }
        } //获取注记的中心点


        if (f.lineType == 'arrow') {
          f.centerPoint = f.sourceAngleData[1][0];
        } //第二次过滤的box


        f.filterBox = [f.centerPoint[0] - radius, f.centerPoint[1] - radius, f.centerPoint[0] + radius, f.centerPoint[1] + radius];
      }

      return features;
    }
    /**
     * 将线注记原始坐标带点和角度的格式，和切过的线的格式一致（针对默认样式的线主机）
     * Parameters:
     * line - 线注记原始数据
     * Returns:
     */

  }, {
    key: "lineToSourceAngleData",
    value: function lineToSourceAngleData(line) {
      var sourceAngleData = [];

      for (var i = 0; i < line.length; i++) {
        var x = line[i];
        var y = line[i + 1];
        sourceAngleData.push([[x, y], 0]);
        i++;
      }

      return sourceAngleData;
    }
  }, {
    key: "transformData",

    /**
     * 将瓦片内坐标转换为当前屏幕坐标
     * Parameters:
     * points - 瓦片内坐标数组,item示例：[[12,20],0] [12,20]为点坐标，0为旋转的角度
     * xyz - 瓦片的层行列号
     * Returns:
     * rdata - 本地屏幕内坐标数组
     */
    value: function transformData(points, xyz, maxExtent, extent, res, tileSize) {
      //取出当前视口左上角的地理坐标
      var left = extent[0];
      var top = extent[3]; //地图最大的范围

      var mLeft = maxExtent[0];
      var mTop = maxExtent[3]; //计算坐上角的屏幕坐标

      var x = (left - mLeft) / res;
      var y = (mTop - top) / res;
      var rPoint = [];

      for (var i = 0; i < points.length; i++) {
        var point = points[i][0];
        var gx = point[0] + xyz.x * tileSize;
        var gy = point[1] + xyz.y * tileSize;
        var p = [gx - x, gy - y];
        rPoint.push([p, points[i][1]]);
      }

      return rPoint;
    }
  }, {
    key: "parseAvoidLine",

    /**
     * 解析图元线要素
     * Parameters:
     * layerAvoids - 需要避让的线图层数据
     * xyz - 层行列号对象
     * maxExtent 地图的最大范围
     * extent 地图的当前视口
     * isClient 是否为客户端
     * Returns:
     * avoidLineFeatures - 需要避让的线要素
     */
    value: function parseAvoidLine(layerAvoids, xyz, isClient, maxExtent, extent, res, tileSize) {
      var avoidLineFeatures = [];

      for (var weight in layerAvoids) {
        var lines = layerAvoids[weight];
        weight = parseInt(weight);

        for (var i = 0; i < lines.length; i++) {
          var feature = {};
          feature.weight = weight;
          feature.sourceDatas = lines[i];

          if (isClient) {
            feature.datas = ParseLabelData.transformAvoidLine(lines[i], xyz, maxExtent, extent, res, tileSize);
          }

          feature.xyz = xyz;
          avoidLineFeatures.push(feature);
        }
      }

      return avoidLineFeatures;
    }
  }, {
    key: "transformAvoidLine",

    /**
     * 将瓦片内坐标转换为当前屏幕坐标
     * Parameters:
     * line - 原始的需要避让的线
     * xyz - 瓦片的层行列号
     * Returns:
     * rdata - 本地屏幕内坐标数组
     */
    value: function transformAvoidLine(line, xyz, maxExtent, extent, res, tileSize) {
      //取出当前视口左上角的地理坐标
      var left = extent[0];
      var top = extent[3]; //地图最大的范围

      var mLeft = maxExtent[0];
      var mTop = maxExtent[3]; //计算坐上角的屏幕坐标

      var x = (left - mLeft) / res;
      var y = (mTop - top) / res;
      var newLine = [];

      for (var i = 0; i < line.length / 2; i++) {
        var px = line[2 * i];
        var py = line[2 * i + 1];
        var gx = px + xyz.x * tileSize;
        var gy = py + xyz.y * tileSize;
        newLine.push(gx - x);
        newLine.push(gy - y);
      }

      return newLine;
    }
  }, {
    key: "getProperty",
    value: function getProperty(fieldsConfig) {
      var propertyConfig = {};
      var idIndex = 0;

      for (var i = 0; i < fieldsConfig.length; i++) {
        if (fieldsConfig[i].id == 'true' || fieldsConfig[i].id == true) {
          idIndex = fieldsConfig[i].index;
        }

        propertyConfig[fieldsConfig[i].name] = parseInt(fieldsConfig[i].index);
      }

      return {
        propertyConfig: propertyConfig,
        idIndex: idIndex
      };
    }
  }, {
    key: "getAttributes",
    value: function getAttributes(feature, propertyGetter) {
      var attributes = {};
      var propertyConfig = propertyGetter.propertyConfig;

      for (var name in propertyConfig) {
        attributes[name] = feature[propertyConfig[name]];
      }

      return attributes;
    }
  }]);

  return ParseLabelData;
}();

/* harmony default export */ var avoid_ParseLabelData = __webpack_exports__["a"] = (ParseLabelData_ParseLabelData);

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ WMTSCapabilities; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ WMSCapabilities; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ TRouteResultFormat["a" /* TRouteResultFormat */]; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ TRouteResult["a" /* TRouteResult */]; });

// UNUSED EXPORTS: Format, FormatXML, VersionedOGC, OWSCommon_v1, OWSCommon_v110, WMTSCapabilities_v110, WMSCapabilities_v1, WMSCapabilities_v11, WMSCapabilities_v111

// EXTERNAL MODULE: ./src/format/Format.js
var format_Format = __webpack_require__(17);

// EXTERNAL MODULE: ./src/format/Format.XML.js
var Format_XML = __webpack_require__(5);

// EXTERNAL MODULE: ./src/core/Base.js
var Base = __webpack_require__(1);

// EXTERNAL MODULE: external "L"
var external_L_ = __webpack_require__(0);
var external_L_default = /*#__PURE__*/__webpack_require__.n(external_L_);

// CONCATENATED MODULE: ./src/format/Format.XML.VersionedOGC.js



var VersionedOGC = Format_XML["a" /* default */].extend({
  defaultVersion: null,
  version: null,
  profile: null,
  allowFallback: false,
  name: null,
  stringifyOutput: false,
  parser: null,
  initialize: function initialize(options) {
    Format_XML["a" /* default */].prototype.initialize.apply(this, [options]);
  },
  getVersion: function getVersion(root, options) {
    var version; // read

    if (root) {
      version = this.version;

      if (!version) {
        version = root.getAttribute("version");

        if (!version) {
          version = this.defaultVersion;
        }
      }
    } else {
      // write
      version = options && options.version || this.version || this.defaultVersion;
    }

    return version;
  },
  getParser: function getParser(version) {
    version = version || this.defaultVersion;

    if (!this.parser || this.parser.VERSION != version) {
      var format = external_L_default.a.geoway.format[this.name]["v" + version.replace(/\./g, "_")];

      if (format) {
        this.parser = new format(this.options);
      }
    }

    return this.parser;
  },

  /**
   * write document 对象
   * @method L.Format.XML.VersionedOGC#write
   * @param {Object} obj - document对象
   * @param {Object} options - 版本参数，默认不用写
   * @return {String} document - string to document
   */
  write: function write(obj, options) {
    var version = this.getVersion(null, options);
    this.parser = this.getParser(version);
    var root = this.parser.write(obj, options);

    if (this.stringifyOutput === false) {
      return root;
    } else {
      return Format_XML["a" /* default */].prototype.write.apply(this, [root]);
    }
  },

  /**
   * read string xml
   * @method L.Format.XML.VersionedOGC#read
   * @param {string} data - xml string
   * @param {Object} options - 版本参数，默认不用写
   * @return {Object} obj - string to document
   */
  read: function read(data, options) {
    if (typeof data == "string") {
      data = Format_XML["a" /* default */].prototype.read.apply(this, [data]);
    }

    var root = data.documentElement;
    var version = this.getVersion(root);
    this.parser = this.getParser(version); // Select the parser

    var obj = this.parser.read(data, options); // Parse the data

    obj.version = version;
    return obj;
  }
});
/* harmony default export */ var Format_XML_VersionedOGC = (VersionedOGC);
// EXTERNAL MODULE: ./src/util/Util.js
var Util = __webpack_require__(10);

// CONCATENATED MODULE: ./src/format/wmts/OWSCommon.v1.js



var OWSCommon_v1 = Format_XML["a" /* default */].extend({
  regExes: {
    trimSpace: /^\s*|\s*$/g,
    removeSpace: /\s*/g,
    splitSpace: /\s+/,
    trimComma: /\s*,\s*/g
  },
  read: function read(data) {
    var ows = {};
    this.readChildNodes(data, ows);
    return ows;
  },
  readers: {
    "ows": {
      "Exception": function Exception(node, exceptionReport) {
        var exception = {
          code: node.getAttribute('exceptionCode'),
          locator: node.getAttribute('locator'),
          texts: []
        };
        exceptionReport.exceptions.push(exception);
        this.readChildNodes(node, exception);
      },
      "ExceptionText": function ExceptionText(node, exception) {
        var text = this.getChildValue(node);
        exception.texts.push(text);
      },
      "ServiceIdentification": function ServiceIdentification(node, obj) {
        obj.serviceIdentification = {};
        this.readChildNodes(node, obj.serviceIdentification);
      },
      "Title": function Title(node, obj) {
        obj.title = this.getChildValue(node);
      },
      "Abstract": function Abstract(node, serviceIdentification) {
        serviceIdentification["abstract"] = this.getChildValue(node);
      },
      "Keywords": function Keywords(node, serviceIdentification) {
        serviceIdentification.keywords = {};
        this.readChildNodes(node, serviceIdentification.keywords);
      },
      "Keyword": function Keyword(node, keywords) {
        keywords[this.getChildValue(node)] = true;
      },
      "ServiceType": function ServiceType(node, serviceIdentification) {
        serviceIdentification.serviceType = {
          codeSpace: node.getAttribute('codeSpace'),
          value: this.getChildValue(node)
        };
      },
      "ServiceTypeVersion": function ServiceTypeVersion(node, serviceIdentification) {
        serviceIdentification.serviceTypeVersion = this.getChildValue(node);
      },
      "Fees": function Fees(node, serviceIdentification) {
        serviceIdentification.fees = this.getChildValue(node);
      },
      "AccessConstraints": function AccessConstraints(node, serviceIdentification) {
        serviceIdentification.accessConstraints = this.getChildValue(node);
      },
      "ServiceProvider": function ServiceProvider(node, obj) {
        obj.serviceProvider = {};
        this.readChildNodes(node, obj.serviceProvider);
      },
      "ProviderName": function ProviderName(node, serviceProvider) {
        serviceProvider.providerName = this.getChildValue(node);
      },
      "ProviderSite": function ProviderSite(node, serviceProvider) {
        serviceProvider.providerSite = this.getAttributeNS(node, this.namespaces.xlink, "href");
      },
      "ServiceContact": function ServiceContact(node, serviceProvider) {
        serviceProvider.serviceContact = {};
        this.readChildNodes(node, serviceProvider.serviceContact);
      },
      "IndividualName": function IndividualName(node, serviceContact) {
        serviceContact.individualName = this.getChildValue(node);
      },
      "PositionName": function PositionName(node, serviceContact) {
        serviceContact.positionName = this.getChildValue(node);
      },
      "ContactInfo": function ContactInfo(node, serviceContact) {
        serviceContact.contactInfo = {};
        this.readChildNodes(node, serviceContact.contactInfo);
      },
      "Phone": function Phone(node, contactInfo) {
        contactInfo.phone = {};
        this.readChildNodes(node, contactInfo.phone);
      },
      "Voice": function Voice(node, phone) {
        phone.voice = this.getChildValue(node);
      },
      "Address": function Address(node, contactInfo) {
        contactInfo.address = {};
        this.readChildNodes(node, contactInfo.address);
      },
      "DeliveryPoint": function DeliveryPoint(node, address) {
        address.deliveryPoint = this.getChildValue(node);
      },
      "City": function City(node, address) {
        address.city = this.getChildValue(node);
      },
      "AdministrativeArea": function AdministrativeArea(node, address) {
        address.administrativeArea = this.getChildValue(node);
      },
      "PostalCode": function PostalCode(node, address) {
        address.postalCode = this.getChildValue(node);
      },
      "Country": function Country(node, address) {
        address.country = this.getChildValue(node);
      },
      "ElectronicMailAddress": function ElectronicMailAddress(node, address) {
        address.electronicMailAddress = this.getChildValue(node);
      },
      "Role": function Role(node, serviceContact) {
        serviceContact.role = this.getChildValue(node);
      },
      "OperationsMetadata": function OperationsMetadata(node, obj) {
        obj.operationsMetadata = {};
        this.readChildNodes(node, obj.operationsMetadata);
      },
      "Operation": function Operation(node, operationsMetadata) {
        var name = node.getAttribute("name");
        operationsMetadata[name] = {};
        this.readChildNodes(node, operationsMetadata[name]);
      },
      "DCP": function DCP(node, operation) {
        operation.dcp = {};
        this.readChildNodes(node, operation.dcp);
      },
      "HTTP": function HTTP(node, dcp) {
        dcp.http = {};
        this.readChildNodes(node, dcp.http);
      },
      "Get": function Get(node, http) {
        if (!http.get) {
          http.get = [];
        }

        var obj = {
          url: this.getAttributeNS(node, this.namespaces.xlink, "href")
        };
        this.readChildNodes(node, obj);
        http.get.push(obj);
      },
      "Post": function Post(node, http) {
        if (!http.post) {
          http.post = [];
        }

        var obj = {
          url: this.getAttributeNS(node, this.namespaces.xlink, "href")
        };
        this.readChildNodes(node, obj);
        http.post.push(obj);
      },
      "Parameter": function Parameter(node, operation) {
        if (!operation.parameters) {
          operation.parameters = {};
        }

        var name = node.getAttribute("name");
        operation.parameters[name] = {};
        this.readChildNodes(node, operation.parameters[name]);
      },
      "Constraint": function Constraint(node, obj) {
        if (!obj.constraints) {
          obj.constraints = {};
        }

        var name = node.getAttribute("name");
        obj.constraints[name] = {};
        this.readChildNodes(node, obj.constraints[name]);
      },
      "Value": function Value(node, allowedValues) {
        allowedValues[this.getChildValue(node)] = true;
      },
      "OutputFormat": function OutputFormat(node, obj) {
        obj.formats.push({
          value: this.getChildValue(node)
        });
        this.readChildNodes(node, obj);
      },
      "WGS84BoundingBox": function WGS84BoundingBox(node, obj) {
        var boundingBox = {};
        boundingBox.crs = node.getAttribute("crs");

        if (obj.BoundingBox) {
          obj.BoundingBox.push(boundingBox);
        } else {
          obj.projection = boundingBox.crs;
          boundingBox = obj;
        }

        this.readChildNodes(node, boundingBox);
      },
      "BoundingBox": function BoundingBox(node, obj) {
        // FIXME: We consider that BoundingBox is the same as WGS84BoundingBox
        // LowerCorner = "min_x min_y"
        // UpperCorner = "max_x max_y"
        // It should normally depend on the projection
        this.readers['ows']['WGS84BoundingBox'].apply(this, [node, obj]);
      },
      "LowerCorner": function LowerCorner(node, obj) {
        var str = this.getChildValue(node).replace(this.regExes.trimSpace, "");
        str = str.replace(this.regExes.trimComma, ",");
        var pointList = str.split(this.regExes.splitSpace);
        obj.left = pointList[0];
        obj.bottom = pointList[1];
      },
      "UpperCorner": function UpperCorner(node, obj) {
        var str = this.getChildValue(node).replace(this.regExes.trimSpace, "");
        str = str.replace(this.regExes.trimComma, ",");
        var pointList = str.split(this.regExes.splitSpace);
        obj.right = pointList[0];
        obj.top = pointList[1];
        var southWest = external_L_default.a.latLng(obj.bottom, obj.left);
        var northEast = external_L_default.a.latLng(obj.top, obj.right);
        obj.bounds = external_L_default.a.latLngBounds(southWest, northEast);
        delete obj.left;
        delete obj.bottom;
        delete obj.right;
        delete obj.top;
      },
      "Language": function Language(node, obj) {
        obj.language = this.getChildValue(node);
      }
    }
  },
  writers: {
    "ows": {
      "BoundingBox": function BoundingBox(options, nodeName) {
        var node = this.createElementNSPlus(nodeName || "ows:BoundingBox", {
          attributes: {
            crs: options.projection
          }
        });
        this.writeNode("ows:LowerCorner", options, node);
        this.writeNode("ows:UpperCorner", options, node);
        return node;
      },
      "LowerCorner": function LowerCorner(options) {
        var node = this.createElementNSPlus("ows:LowerCorner", {
          value: options.bounds.left + " " + options.bounds.bottom
        });
        return node;
      },
      "UpperCorner": function UpperCorner(options) {
        var node = this.createElementNSPlus("ows:UpperCorner", {
          value: options.bounds.right + " " + options.bounds.top
        });
        return node;
      },
      "Identifier": function Identifier(identifier) {
        var node = this.createElementNSPlus("ows:Identifier", {
          value: identifier
        });
        return node;
      },
      "Title": function Title(title) {
        var node = this.createElementNSPlus("ows:Title", {
          value: title
        });
        return node;
      },
      "Abstract": function Abstract(abstractValue) {
        var node = this.createElementNSPlus("ows:Abstract", {
          value: abstractValue
        });
        return node;
      },
      "OutputFormat": function OutputFormat(format) {
        var node = this.createElementNSPlus("ows:OutputFormat", {
          value: format
        });
        return node;
      }
    }
  }
});
/* harmony default export */ var wmts_OWSCommon_v1 = (OWSCommon_v1);
// CONCATENATED MODULE: ./src/format/wmts/OWSCommon.v1_1_0.js



var OWSCommon_v110 = wmts_OWSCommon_v1.extend({
  namespaces: {
    ows: "http://www.opengis.net/ows/1.1",
    xlink: "http://www.w3.org/1999/xlink"
  },
  readers: {
    "ows": external_L_default.a.Util.applyDefaults({
      "ExceptionReport": function ExceptionReport(node, obj) {
        obj.exceptionReport = {
          version: node.getAttribute('version'),
          language: node.getAttribute('xml:lang'),
          exceptions: []
        };
        this.readChildNodes(node, obj.exceptionReport);
      },
      "AllowedValues": function AllowedValues(node, parameter) {
        parameter.allowedValues = {};
        this.readChildNodes(node, parameter.allowedValues);
      },
      "AnyValue": function AnyValue(node, parameter) {
        parameter.anyValue = true;
      },
      "DataType": function DataType(node, parameter) {
        parameter.dataType = this.getChildValue(node);
      },
      "Range": function Range(node, allowedValues) {
        allowedValues.range = {};
        this.readChildNodes(node, allowedValues.range);
      },
      "MinimumValue": function MinimumValue(node, range) {
        range.minValue = this.getChildValue(node);
      },
      "MaximumValue": function MaximumValue(node, range) {
        range.maxValue = this.getChildValue(node);
      },
      "Identifier": function Identifier(node, obj) {
        obj.identifier = this.getChildValue(node);
      },
      "SupportedCRS": function SupportedCRS(node, obj) {
        obj.supportedCRS = this.getChildValue(node);
      }
    }, wmts_OWSCommon_v1.prototype.readers["ows"])
  },
  writers: {
    "ows": external_L_default.a.Util.applyDefaults({
      "Range": function Range(range) {
        var node = this.createElementNSPlus("ows:Range", {
          attributes: {
            'ows:rangeClosure': range.closure
          }
        });
        this.writeNode("ows:MinimumValue", range.minValue, node);
        this.writeNode("ows:MaximumValue", range.maxValue, node);
        return node;
      },
      "MinimumValue": function MinimumValue(minValue) {
        var node = this.createElementNSPlus("ows:MinimumValue", {
          value: minValue
        });
        return node;
      },
      "MaximumValue": function MaximumValue(maxValue) {
        var node = this.createElementNSPlus("ows:MaximumValue", {
          value: maxValue
        });
        return node;
      },
      "Value": function Value(value) {
        var node = this.createElementNSPlus("ows:Value", {
          value: value
        });
        return node;
      }
    }, wmts_OWSCommon_v1.prototype.writers["ows"])
  }
});
/* harmony default export */ var OWSCommon_v1_1_0 = (OWSCommon_v110);
// CONCATENATED MODULE: ./src/format/wmts/WMTSCapabilities.js


var WMTSCapabilities = Format_XML_VersionedOGC.extend({
  name: "WMTSCapabilities",
  defaultVersion: "1.0.0",
  yx: {
    "urn:ogc:def:crs:EPSG::4326": true,
    "urn:ogc:def:crs:EPSG::4490": true,
    "urn:ogc:def:crs:EPSG::900913": true,
    "urn:ogc:def:crs:EPSG::4610": true
  },
  xy: {
    "urn:ogc:def:crs:EPSG::3857": true,
    "urn:ogc:def:crs:EPSG::3785": true,
    "urn:ogc:def:crs:EPSG::102100": true
  }
});
external_L_default.a.geoway.format.WMTSCapabilities = WMTSCapabilities;
external_L_default.a.Format = external_L_default.a.Format ? external_L_default.a.Format : {};
external_L_default.a.Format.WMTSCapabilities = WMTSCapabilities;
// CONCATENATED MODULE: ./src/format/wmts/WMTSCapabilities.v1_0_0.js




var WMTSCapabilities_v110 = OWSCommon_v1_1_0.extend({
  version: "1.0.0",
  namespaces: {
    ows: "http://www.opengis.net/ows/1.1",
    wmts: "http://www.opengis.net/wmts/1.0",
    xlink: "http://www.w3.org/1999/xlink"
  },
  yx: null,
  defaultPrefix: "wmts",
  initialize: function initialize(options) {
    Format_XML["a" /* default */].prototype.initialize.apply(this, [options]);
    this.options = options;
    var yx = external_L_default.a.extend({}, WMTSCapabilities.prototype.yx);
    this.yx = external_L_default.a.extend(yx, this.yx);
  },
  read: function read(data) {
    if (typeof data == "string") {
      data = Format_XML["a" /* default */].prototype.read.apply(this, [data]);
    }

    if (data && data.nodeType == 9) {
      data = data.documentElement;
    }

    var capabilities = {};
    this.readNode(data, capabilities);
    capabilities.version = this.version;
    return capabilities;
  },
  readers: {
    "wmts": {
      "Capabilities": function Capabilities(node, obj) {
        this.readChildNodes(node, obj);
      },
      "Contents": function Contents(node, obj) {
        obj.contents = {};
        obj.contents.layers = [];
        obj.contents.tileMatrixSets = {};
        this.readChildNodes(node, obj.contents);
      },
      "Layer": function Layer(node, obj) {
        var layer = {
          styles: [],
          formats: [],
          dimensions: [],
          tileMatrixSetLinks: []
        };
        layer.layers = [];
        this.readChildNodes(node, layer);
        obj.layers.push(layer);
      },
      "Style": function Style(node, obj) {
        var style = {};
        style.isDefault = node.getAttribute("isDefault") === "true";
        this.readChildNodes(node, style);
        obj.styles.push(style);
      },
      "Format": function Format(node, obj) {
        obj.formats.push(this.getChildValue(node));
      },
      "TileMatrixSetLink": function TileMatrixSetLink(node, obj) {
        var tileMatrixSetLink = {};
        this.readChildNodes(node, tileMatrixSetLink);
        obj.tileMatrixSetLinks.push(tileMatrixSetLink);
      },
      "TileMatrixSet": function TileMatrixSet(node, obj) {
        // node could be child of wmts:Contents or wmts:TileMatrixSetLink
        // duck type wmts:Contents by looking for layers
        if (obj.layers) {
          // TileMatrixSet as object type in schema
          var tileMatrixSet = {
            matrixIds: []
          };
          this.readChildNodes(node, tileMatrixSet);
          obj.tileMatrixSets[tileMatrixSet.identifier] = tileMatrixSet;
        } else {
          // TileMatrixSet as string type in schema
          obj.tileMatrixSet = this.getChildValue(node);
        }
      },
      "TileMatrix": function TileMatrix(node, obj) {
        var tileMatrix = {
          supportedCRS: obj.supportedCRS
        };
        this.readChildNodes(node, tileMatrix);
        obj.matrixIds.push(tileMatrix);
      },
      "ScaleDenominator": function ScaleDenominator(node, obj) {
        obj.scaleDenominator = parseFloat(this.getChildValue(node));
      },
      "TopLeftCorner": function TopLeftCorner(node, obj) {
        var topLeftCorner = this.getChildValue(node);
        var coords = topLeftCorner.split(" "); // decide on axis order for the given CRS

        var yx;

        if (obj.supportedCRS) {
          // extract out version from URN
          var crs = obj.supportedCRS.replace(/urn:ogc:def:crs:(\w+):.+:(\w+)$/, "urn:ogc:def:crs:$1::$2");
          yx = !!this.yx[crs];
        }

        if (yx) {
          obj.topLeftCorner = external_L_default.a.latLng(coords[0], coords[1]);
        } else {
          obj.topLeftCorner = external_L_default.a.latLng(coords[1], coords[0]);
        }
      },
      "TileWidth": function TileWidth(node, obj) {
        obj.tileWidth = parseInt(this.getChildValue(node));
      },
      "TileHeight": function TileHeight(node, obj) {
        obj.tileHeight = parseInt(this.getChildValue(node));
      },
      "MatrixWidth": function MatrixWidth(node, obj) {
        obj.matrixWidth = parseInt(this.getChildValue(node));
      },
      "MatrixHeight": function MatrixHeight(node, obj) {
        obj.matrixHeight = parseInt(this.getChildValue(node));
      },
      "ResourceURL": function ResourceURL(node, obj) {
        obj.resourceUrl = obj.resourceUrl || {};
        var resourceType = node.getAttribute("resourceType");

        if (!obj.resourceUrls) {
          obj.resourceUrls = [];
        }

        var resourceUrl = obj.resourceUrl[resourceType] = {
          format: node.getAttribute("format"),
          template: node.getAttribute("template"),
          resourceType: resourceType
        };
        obj.resourceUrls.push(resourceUrl);
      },
      // not used for now, can be added in the future though

      /*"Themes": function(node, obj) {
          obj.themes = [];
          this.readChildNodes(node, obj.themes);
      },
      "Theme": function(node, obj) {
          var theme = {};
          this.readChildNodes(node, theme);
          obj.push(theme);
      },*/
      "WSDL": function WSDL(node, obj) {
        obj.wsdl = {};
        obj.wsdl.href = node.getAttribute("xlink:href"); // TODO: other attributes of <WSDL> element
      },
      "ServiceMetadataURL": function ServiceMetadataURL(node, obj) {
        obj.serviceMetadataUrl = {};
        obj.serviceMetadataUrl.href = node.getAttribute("xlink:href"); // TODO: other attributes of <ServiceMetadataURL> element
      },
      "LegendURL": function LegendURL(node, obj) {
        obj.legend = {};
        obj.legend.href = node.getAttribute("xlink:href");
        obj.legend.format = node.getAttribute("format");
      },
      "Dimension": function Dimension(node, obj) {
        var dimension = {
          values: []
        };
        this.readChildNodes(node, dimension);
        obj.dimensions.push(dimension);
      },
      "Default": function Default(node, obj) {
        obj["default"] = this.getChildValue(node);
      },
      "Value": function Value(node, obj) {
        obj.values.push(this.getChildValue(node));
      }
    },
    "ows": OWSCommon_v1_1_0.prototype.readers["ows"]
  }
});
external_L_default.a.geoway.format.WMTSCapabilities.v1_0_0 = WMTSCapabilities_v110;
// CONCATENATED MODULE: ./src/format/wms/WMSCapabilities.js



var WMSCapabilities = Format_XML_VersionedOGC.extend({
  name: "WMSCapabilities",
  defaultVersion: "1.1.1"
});
external_L_default.a.geoway.format.WMSCapabilities = WMSCapabilities;
external_L_default.a.Format = external_L_default.a.Format ? external_L_default.a.Format : {};
external_L_default.a.Format.WMSCapabilities = WMSCapabilities;
// CONCATENATED MODULE: ./src/format/wms/WMSCapabilities.v1.js



var WMSCapabilities_v1 = Format_XML["a" /* default */].extend({
  namespaces: {
    wms: "http://www.opengis.net/wms",
    xlink: "http://www.w3.org/1999/xlink",
    xsi: "http://www.w3.org/2001/XMLSchema-instance"
  },
  defaultPrefix: "wms",
  read: function read(data) {
    if (typeof data == "string") {
      data = Format_XML["a" /* default */].prototype.read.apply(this, [data]);
    }

    if (data && data.nodeType == 9) {
      data = data.documentElement;
    }

    var capabilities = {};
    this.readNode(data, capabilities);
    return capabilities;
  },
  readers: {
    "wms": {
      "Service": function Service(node, obj) {
        obj.service = {};
        this.readChildNodes(node, obj.service);
      },
      "Name": function Name(node, obj) {
        obj.name = this.getChildValue(node);
      },
      "Title": function Title(node, obj) {
        obj.title = this.getChildValue(node);
      },
      "Abstract": function Abstract(node, obj) {
        obj["abstract"] = this.getChildValue(node);
      },
      "BoundingBox": function BoundingBox(node) {
        var bbox = {};
        bbox.bbox = [parseFloat(node.getAttribute("minx")), parseFloat(node.getAttribute("miny")), parseFloat(node.getAttribute("maxx")), parseFloat(node.getAttribute("maxy"))];
        var res = {
          x: parseFloat(node.getAttribute("resx")),
          y: parseFloat(node.getAttribute("resy"))
        };

        if (!(isNaN(res.x) && isNaN(res.y))) {
          bbox.res = res;
        } // return the bbox so that descendant classes can set the
        // CRS and SRS and add it to the obj


        return bbox;
      },
      "OnlineResource": function OnlineResource(node, obj) {
        obj.href = this.getAttributeNS(node, this.namespaces.xlink, "href");
      },
      "ContactInformation": function ContactInformation(node, obj) {
        obj.contactInformation = {};
        this.readChildNodes(node, obj.contactInformation);
      },
      "ContactPersonPrimary": function ContactPersonPrimary(node, obj) {
        obj.personPrimary = {};
        this.readChildNodes(node, obj.personPrimary);
      },
      "ContactPerson": function ContactPerson(node, obj) {
        obj.person = this.getChildValue(node);
      },
      "ContactOrganization": function ContactOrganization(node, obj) {
        obj.organization = this.getChildValue(node);
      },
      "ContactPosition": function ContactPosition(node, obj) {
        obj.position = this.getChildValue(node);
      },
      "ContactAddress": function ContactAddress(node, obj) {
        obj.contactAddress = {};
        this.readChildNodes(node, obj.contactAddress);
      },
      "AddressType": function AddressType(node, obj) {
        obj.type = this.getChildValue(node);
      },
      "Address": function Address(node, obj) {
        obj.address = this.getChildValue(node);
      },
      "City": function City(node, obj) {
        obj.city = this.getChildValue(node);
      },
      "StateOrProvince": function StateOrProvince(node, obj) {
        obj.stateOrProvince = this.getChildValue(node);
      },
      "PostCode": function PostCode(node, obj) {
        obj.postcode = this.getChildValue(node);
      },
      "Country": function Country(node, obj) {
        obj.country = this.getChildValue(node);
      },
      "ContactVoiceTelephone": function ContactVoiceTelephone(node, obj) {
        obj.phone = this.getChildValue(node);
      },
      "ContactFacsimileTelephone": function ContactFacsimileTelephone(node, obj) {
        obj.fax = this.getChildValue(node);
      },
      "ContactElectronicMailAddress": function ContactElectronicMailAddress(node, obj) {
        obj.email = this.getChildValue(node);
      },
      "Fees": function Fees(node, obj) {
        var fees = this.getChildValue(node);

        if (fees && fees.toLowerCase() != "none") {
          obj.fees = fees;
        }
      },
      "AccessConstraints": function AccessConstraints(node, obj) {
        var constraints = this.getChildValue(node);

        if (constraints && constraints.toLowerCase() != "none") {
          obj.accessConstraints = constraints;
        }
      },
      "Capability": function Capability(node, obj) {
        obj.capability = {
          nestedLayers: [],
          layers: []
        };
        this.readChildNodes(node, obj.capability);
      },
      "Request": function Request(node, obj) {
        obj.request = {};
        this.readChildNodes(node, obj.request);
      },
      "GetCapabilities": function GetCapabilities(node, obj) {
        obj.getcapabilities = {
          formats: []
        };
        this.readChildNodes(node, obj.getcapabilities);
      },
      "Format": function Format(node, obj) {
        if (external_L_default.a.Util.isArray(obj.formats)) {
          obj.formats.push(this.getChildValue(node));
        } else {
          obj.format = this.getChildValue(node);
        }
      },
      "DCPType": function DCPType(node, obj) {
        this.readChildNodes(node, obj);
      },
      "HTTP": function HTTP(node, obj) {
        this.readChildNodes(node, obj);
      },
      "Get": function Get(node, obj) {
        obj.get = {};
        this.readChildNodes(node, obj.get); // backwards compatibility

        if (!obj.href) {
          obj.href = obj.get.href;
        }
      },
      "Post": function Post(node, obj) {
        obj.post = {};
        this.readChildNodes(node, obj.post); // backwards compatibility

        if (!obj.href) {
          obj.href = obj.get.href;
        }
      },
      "GetMap": function GetMap(node, obj) {
        obj.getmap = {
          formats: []
        };
        this.readChildNodes(node, obj.getmap);
      },
      "GetFeatureInfo": function GetFeatureInfo(node, obj) {
        obj.getfeatureinfo = {
          formats: []
        };
        this.readChildNodes(node, obj.getfeatureinfo);
      },
      "Exception": function Exception(node, obj) {
        obj.exception = {
          formats: []
        };
        this.readChildNodes(node, obj.exception);
      },
      "Layer": function Layer(node, obj) {
        var parentLayer, capability;

        if (obj.capability) {
          capability = obj.capability;
          parentLayer = obj;
        } else {
          capability = obj;
        }

        var attrNode = node.getAttributeNode("queryable");
        var queryable = attrNode && attrNode.specified ? node.getAttribute("queryable") : null;
        attrNode = node.getAttributeNode("cascaded");
        var cascaded = attrNode && attrNode.specified ? node.getAttribute("cascaded") : null;
        attrNode = node.getAttributeNode("opaque");
        var opaque = attrNode && attrNode.specified ? node.getAttribute('opaque') : null;
        var noSubsets = node.getAttribute('noSubsets');
        var fixedWidth = node.getAttribute('fixedWidth');
        var fixedHeight = node.getAttribute('fixedHeight');
        var parent = parentLayer || {},
            extend = external_L_default.a.Util.extend;
        var layer = {
          nestedLayers: [],
          styles: parentLayer ? [].concat(parentLayer.styles) : [],
          srs: parentLayer ? extend({}, parent.srs) : {},
          metadataURLs: [],
          bbox: parentLayer ? extend({}, parent.bbox) : {},
          llbbox: parent.llbbox,
          dimensions: parentLayer ? extend({}, parent.dimensions) : {},
          authorityURLs: parentLayer ? extend({}, parent.authorityURLs) : {},
          identifiers: {},
          keywords: [],
          queryable: queryable && queryable !== "" ? queryable === "1" || queryable === "true" : parent.queryable || false,
          cascaded: cascaded !== null ? parseInt(cascaded) : parent.cascaded || 0,
          opaque: opaque ? opaque === "1" || opaque === "true" : parent.opaque || false,
          noSubsets: noSubsets !== null ? noSubsets === "1" || noSubsets === "true" : parent.noSubsets || false,
          fixedWidth: fixedWidth != null ? parseInt(fixedWidth) : parent.fixedWidth || 0,
          fixedHeight: fixedHeight != null ? parseInt(fixedHeight) : parent.fixedHeight || 0,
          minScale: parent.minScale,
          maxScale: parent.maxScale,
          attribution: parent.attribution
        };
        obj.nestedLayers.push(layer);
        layer.capability = capability;
        this.readChildNodes(node, layer);
        delete layer.capability;

        if (layer.name) {
          var parts = layer.name.split(":"),
              request = capability.request,
              gfi = request.getfeatureinfo;

          if (parts.length > 0) {
            layer.prefix = parts[0];
          }

          capability.layers.push(layer);

          if (layer.formats === undefined) {
            layer.formats = request.getmap.formats;
          }

          if (layer.infoFormats === undefined && gfi) {
            layer.infoFormats = gfi.formats;
          }
        }
      },
      "Attribution": function Attribution(node, obj) {
        obj.attribution = {};
        this.readChildNodes(node, obj.attribution);
      },
      "LogoURL": function LogoURL(node, obj) {
        obj.logo = {
          width: node.getAttribute("width"),
          height: node.getAttribute("height")
        };
        this.readChildNodes(node, obj.logo);
      },
      "Style": function Style(node, obj) {
        var style = {};
        obj.styles.push(style);
        this.readChildNodes(node, style);
      },
      "LegendURL": function LegendURL(node, obj) {
        var legend = {
          width: node.getAttribute("width"),
          height: node.getAttribute("height")
        };
        obj.legend = legend;
        this.readChildNodes(node, legend);
      },
      "MetadataURL": function MetadataURL(node, obj) {
        var metadataURL = {
          type: node.getAttribute("type")
        };
        obj.metadataURLs.push(metadataURL);
        this.readChildNodes(node, metadataURL);
      },
      "DataURL": function DataURL(node, obj) {
        obj.dataURL = {};
        this.readChildNodes(node, obj.dataURL);
      },
      "FeatureListURL": function FeatureListURL(node, obj) {
        obj.featureListURL = {};
        this.readChildNodes(node, obj.featureListURL);
      },
      "AuthorityURL": function AuthorityURL(node, obj) {
        var name = node.getAttribute("name");
        var authority = {};
        this.readChildNodes(node, authority);
        obj.authorityURLs[name] = authority.href;
      },
      "Identifier": function Identifier(node, obj) {
        var authority = node.getAttribute("authority");
        obj.identifiers[authority] = this.getChildValue(node);
      },
      "KeywordList": function KeywordList(node, obj) {
        this.readChildNodes(node, obj);
      },
      "SRS": function SRS(node, obj) {
        obj.srs[this.getChildValue(node)] = true;
      }
    }
  }
});
external_L_default.a.geoway.format.WMSCapabilities.v1 = WMSCapabilities_v1;
// CONCATENATED MODULE: ./src/format/wms/WMSCapabilities.v1_1.js




var WMSCapabilities_v11 = WMSCapabilities_v1.extend({
  readers: {
    "wms": external_L_default.a.Util.applyDefaults({
      "WMT_MS_Capabilities": function WMT_MS_Capabilities(node, obj) {
        this.readChildNodes(node, obj);
      },
      "Keyword": function Keyword(node, obj) {
        if (obj.keywords) {
          obj.keywords.push(this.getChildValue(node));
        }
      },
      "DescribeLayer": function DescribeLayer(node, obj) {
        obj.describelayer = {
          formats: []
        };
        this.readChildNodes(node, obj.describelayer);
      },
      "GetLegendGraphic": function GetLegendGraphic(node, obj) {
        obj.getlegendgraphic = {
          formats: []
        };
        this.readChildNodes(node, obj.getlegendgraphic);
      },
      "GetStyles": function GetStyles(node, obj) {
        obj.getstyles = {
          formats: []
        };
        this.readChildNodes(node, obj.getstyles);
      },
      "PutStyles": function PutStyles(node, obj) {
        obj.putstyles = {
          formats: []
        };
        this.readChildNodes(node, obj.putstyles);
      },
      "UserDefinedSymbolization": function UserDefinedSymbolization(node, obj) {
        var userSymbols = {
          supportSLD: parseInt(node.getAttribute("SupportSLD")) == 1,
          userLayer: parseInt(node.getAttribute("UserLayer")) == 1,
          userStyle: parseInt(node.getAttribute("UserStyle")) == 1,
          remoteWFS: parseInt(node.getAttribute("RemoteWFS")) == 1
        };
        obj.userSymbols = userSymbols;
      },
      "LatLonBoundingBox": function LatLonBoundingBox(node, obj) {
        obj.llbbox = [parseFloat(node.getAttribute("minx")), parseFloat(node.getAttribute("miny")), parseFloat(node.getAttribute("maxx")), parseFloat(node.getAttribute("maxy"))];
      },
      "BoundingBox": function BoundingBox(node, obj) {
        var bbox = WMSCapabilities_v1.prototype.readers["wms"].BoundingBox.apply(this, [node, obj]);
        bbox.srs = node.getAttribute("SRS");
        obj.bbox[bbox.srs] = bbox;
      },
      "ScaleHint": function ScaleHint() {},
      "Dimension": function Dimension(node, obj) {
        var name = node.getAttribute("name").toLowerCase();
        var dim = {
          name: name,
          units: node.getAttribute("units"),
          unitsymbol: node.getAttribute("unitSymbol")
        };
        obj.dimensions[dim.name] = dim;
      },
      "Extent": function Extent(node, obj) {
        var name = node.getAttribute("name").toLowerCase();

        if (name in obj["dimensions"]) {
          var extent = obj.dimensions[name];
          extent.nearestVal = node.getAttribute("nearestValue") === "1";
          extent.multipleVal = node.getAttribute("multipleValues") === "1";
          extent.current = node.getAttribute("current") === "1";
          extent["default"] = node.getAttribute("default") || "";
          var values = this.getChildValue(node);
          extent.values = values.split(",");
        }
      }
    }, WMSCapabilities_v1.prototype.readers["wms"])
  }
});
external_L_default.a.geoway.format.WMSCapabilities.v1_1 = WMSCapabilities_v11;
// CONCATENATED MODULE: ./src/format/wms/WMSCapabilities.v1_1_1.js




var WMSCapabilities_v111 = WMSCapabilities_v11.extend({
  version: "1.1.1",
  readers: {
    "wms": external_L_default.a.Util.applyDefaults({
      "SRS": function SRS(node, obj) {
        obj.srs[this.getChildValue(node)] = true;
      }
    }, WMSCapabilities_v11.prototype.readers["wms"])
  }
});
external_L_default.a.geoway.format.WMSCapabilities.v1_1_1 = WMSCapabilities_v111;
// EXTERNAL MODULE: ./src/format/route/TRouteResultFormat.js
var TRouteResultFormat = __webpack_require__(22);

// EXTERNAL MODULE: ./src/format/route/TRouteResult.js
var TRouteResult = __webpack_require__(23);

// CONCATENATED MODULE: ./src/format/index.js


















/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./src/util/gistools/BoxSet.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _quadrant_left = 1;
var _quadrant_left_bottom = 2;
var _quadrant_bottom = 3;
var _quadrant_right_bottom = 4;
var _quadrant_right = 5;
var _quadrant_right_top = 6;
var _quadrant_top = 7;
var _quadrant_left_top = 8;
var _inner = 9;
var _save = 1;
var _question = 2;
var _out = 3;

var BoxSet = /*#__PURE__*/function () {
  function BoxSet(left, right, bottom, top, base, bufferPercent) {
    _classCallCheck(this, BoxSet);

    if (bufferPercent == null) {
      bufferPercent = 5;
    }

    var buffer = base * 5 / 100;
    this.left = left - buffer;
    this.right = right + buffer;
    this.bottom = bottom - buffer;
    this.top = top + buffer;
    this.previous = BoxSet.createEmptyDoubleArray();
    this.now = BoxSet.createEmptyDoubleArray();
    this.question = BoxSet.createEmptyDoubleArray();
    this.point_previous_quadrant = -1;
    this.point_now_quadrant = -1;
    this.point_question_quadrant = -1;
  }

  _createClass(BoxSet, [{
    key: "copy",
    value: function copy(form, to) {
      to[0] = form[0];
      to[1] = form[1];
    }
  }, {
    key: "isQuadrant",
    value: function isQuadrant(point) {
      var x = point[0];
      var y = point[1];

      if (x < this.left) {
        if (y > this.top) {
          return _quadrant_left_top;
        }

        if (y < this.bottom) {
          return _quadrant_left_bottom;
        } else {
          return _quadrant_left;
        }
      }

      if (x > this.right) {
        if (y > this.top) {
          return _quadrant_right_top;
        }

        if (y < this.bottom) {
          return _quadrant_right_bottom;
        } else {
          return _quadrant_right;
        }
      } else {
        if (y > this.top) {
          return _quadrant_top;
        }

        if (y < this.bottom) {
          return _quadrant_bottom;
        } else {
          return _inner;
        }
      }
    }
  }, {
    key: "passrule",
    value: function passrule(point_previous_quadrant, point_now_quadrant) {
      if (point_previous_quadrant == 1) {
        if (point_now_quadrant == 1 || point_now_quadrant == 2 || point_now_quadrant == 8) {
          return _question;
        } else {
          return _save;
        }
      }

      if (point_previous_quadrant == 2) {
        if (point_now_quadrant == 1 || point_now_quadrant == 2 || point_now_quadrant == 8 || point_now_quadrant == 3 || point_now_quadrant == 4) {
          return _question;
        } else {
          return _save;
        }
      }

      if (this.point_previous_quadrant == 3) {
        if (this.point_now_quadrant == 2 || this.point_now_quadrant == 3 || this.point_now_quadrant == 4) {
          return _question;
        } else {
          return _save;
        }
      }

      if (point_previous_quadrant == 4) {
        if (point_now_quadrant == 2 || point_now_quadrant == 3 || point_now_quadrant == 4 || point_now_quadrant == 5 || point_now_quadrant == 6) {
          return _question;
        } else {
          return _save;
        }
      }

      if (point_previous_quadrant == 5) {
        if (point_now_quadrant == 4 || point_now_quadrant == 5 || point_now_quadrant == 6) {
          return _question;
        } else {
          return _save;
        }
      }

      if (point_previous_quadrant == 6) {
        if (point_now_quadrant == 4 || point_now_quadrant == 5 || point_now_quadrant == 6 || point_now_quadrant == 7 || point_now_quadrant == 8) {
          return _question;
        } else {
          return _save;
        }
      }

      if (point_previous_quadrant == 7) {
        if (point_now_quadrant == 6 || point_now_quadrant == 7 || point_now_quadrant == 8) {
          return _question;
        } else {
          return _save;
        }
      }

      if (point_previous_quadrant == 8) {
        if (point_now_quadrant == 6 || point_now_quadrant == 7 || point_now_quadrant == 8 || point_now_quadrant == 1 || point_now_quadrant == 2) {
          return _question;
        } else {
          return _save;
        }
      }

      if (point_previous_quadrant == 9) {
        return _save;
      } else {
        return _save;
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this.previous[0] = NaN;
      this.previous[1] = NaN;
      this.question[0] = NaN;
      this.question[1] = NaN;
      this.now[0] = NaN;
      this.now[1] = NaN;
      this.point_previous_quadrant = -1;
      this.point_now_quadrant = -1;
      this.point_question_quadrant = -1;
    }
  }, {
    key: "in",
    value: function _in(now) {
      if (now[0] < this.left || now[0] > this.right) {
        return false;
      }

      if (now[1] < this.bottom || now[1] > this.top) {
        return false;
      }

      return true;
    }
  }, {
    key: "push",
    value: function push(x, y) {
      this.now[0] = x;
      this.now[1] = y;

      if (BoxSet.isEmpty(this.previous)) {
        this.copy(this.now, this.previous);
        this.point_previous_quadrant = this.isQuadrant(this.now);
        return [this.now];
      } else {
        this.point_now_quadrant = this.isQuadrant(this.now);
        var passrule = this.passrule(this.point_previous_quadrant, this.point_now_quadrant);

        if (passrule == _save) {
          this.point_previous_quadrant = this.isQuadrant(this.now);
          this.copy(this.now, this.previous);

          if (!BoxSet.isEmpty(this.question)) {
            var returnPoint = [];
            this.copy(this.question, returnPoint);
            this.question = BoxSet.createEmptyDoubleArray();
            return [returnPoint, this.now];
          } else {
            return [this.now];
          }
        }

        if (passrule == _question) {
          //如果存疑，则需要和存疑点比对
          if (!BoxSet.isEmpty(this.question)) {
            //point_question_quadrant = this.isQuadrant(question);
            passrule = this.passrule(this.point_question_quadrant, this.point_now_quadrant);

            if (passrule == _save) {
              var _returnPoint = [];
              this.copy(this.question, _returnPoint);
              this.question = BoxSet.createEmptyDoubleArray();
              return [_returnPoint, this.now];
            } // if (passrule == _question) {
            // }

          }

          this.copy(this.now, this.question);
          this.point_question_quadrant = this.point_now_quadrant;
          return null;
        } else {
          return null;
        }
      }
    }
  }], [{
    key: "createEmptyDoubleArray",
    value: function createEmptyDoubleArray() {
      return [NaN, NaN];
    }
  }, {
    key: "isEmpty",
    value: function isEmpty(array) {
      if (array == null) {
        return true;
      }

      if (isNaN(array[0]) || isNaN(array[1])) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "length",
    value: function length(x0, y0, x1, y1) {
      var dx = x1 - x0;
      var dy = y1 - y0;
      var len = Math.sqrt(dx * dx + dy * dy);
      return len;
    }
  }]);

  return BoxSet;
}();

/* harmony default export */ var gistools_BoxSet = (BoxSet);
// EXTERNAL MODULE: ./src/util/gistools/GisTools.js
var GisTools = __webpack_require__(8);

// EXTERNAL MODULE: ./src/layer/label/avoid/Util.js
var Util = __webpack_require__(7);

// EXTERNAL MODULE: ./src/layer/label/avoid/AvoidUtil.js
var AvoidUtil = __webpack_require__(6);

// CONCATENATED MODULE: ./src/layer/label/avoid/GDrawGeomerty.js
function GDrawGeomerty_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GDrawGeomerty_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function GDrawGeomerty_createClass(Constructor, protoProps, staticProps) { if (protoProps) GDrawGeomerty_defineProperties(Constructor.prototype, protoProps); if (staticProps) GDrawGeomerty_defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by kongjian on 2017/6/26.
 * 绘制点，线面的工具类
 */





var _boxSet512 = new gistools_BoxSet(0, 512, 0, 512, 512, 5);

var _boxSet256 = new gistools_BoxSet(0, 256, 0, 256, 256, 5);

var _boxSet256_0 = new gistools_BoxSet(0, 256, 0, 256, 256, 5);

var _boxSet256_1 = new gistools_BoxSet(256, 512, 0, 256, 256, 5);

var _boxSet256_2 = new gistools_BoxSet(0, 256, 256, 512, 256, 5);

var _boxSet256_3 = new gistools_BoxSet(256, 512, 256, 512, 256, 5);

var GDrawGeomerty_GDrawGeomerty = /*#__PURE__*/function () {
  function GDrawGeomerty() {
    GDrawGeomerty_classCallCheck(this, GDrawGeomerty);
  }

  GDrawGeomerty_createClass(GDrawGeomerty, null, [{
    key: "draw",

    /**
     * 画注记
     * Parameters:
     * features - 设置过样式，转换过为屏幕坐标，避让过的注记数据
     */
    value: function draw(ctx, features, styleMap, ratio, checkDraw, isChangeFont, hitCtx, hitDetection, quadrant, debug) {
      ctx.lineJoin = "round";
      var drewMap = null;

      if (checkDraw) {
        drewMap = new Map();
      } //如果是调试模式，先会被隐藏的，后画能正常显示的


      if (debug) {
        features = this.sort(features);
      }

      for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        var style = styleMap[feature.styleId]; //画点注记

        if (feature.type == 1) {
          this.drawPointIcon(ctx, feature, style, ratio, drewMap, hitCtx, hitDetection);
          this.drawPoint(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection, quadrant);

          if (debug) {
            this.drawAvoidBox(ctx, feature.box, feature.hidden);
          }

          continue;
        } //画线注记


        if (feature.type == 2) {
          this.drawLine(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection, quadrant);

          if (debug) {
            for (var j = 0; j < feature.boxs.length; j++) {
              var box = feature.boxs[j];
              this.drawAvoidBox(ctx, box, feature.hidden);
            }
          }
        }
      }

      drewMap = null;
    }
  }, {
    key: "drawDefaultStyle",

    /**
     * 画默认样式注记
     * Parameters:
     * features - 设置过样式，转换过为屏幕坐标，避让过的注记数据
     */
    value: function drawDefaultStyle(ctx, features, styleMap, ratio, checkDraw, isChangeFont, hitCtx, hitDetection) {
      var drewMap = null;

      if (checkDraw) {
        drewMap = new Map();
      }

      for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        var style = styleMap[feature.styleId]; //画点注记

        if (feature.type == 1) {
          this.drawPointDefaultStyle(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection);
          continue;
        } //画线注记


        if (feature.type == 2) {
          this.drawLineDefaultStyle(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection);
        }
      }

      drewMap = null;
    }
  }, {
    key: "drawPointIcon",

    /**
     * 画点注记图标
     * Parameters:
     *  ctx - 画布对象
     *  hitCtx - 画拾取box的画布对象
     * hitDetection - 是否绘制拾取的box
     * feature - 设置过样式，转换过为屏幕坐标，避让过的注记数据
     */
    value: function drawPointIcon(ctx, feature, style, ratio, drewMap, hitCtx, hitDetection) {
      if (!style.texture) {
        return;
      }

      var width = style.graphicWidth;
      var height = style.graphicHeight;
      var img = feature.iconImg;

      if (!img) {
        return;
      }

      if (!width || !height) {
        width = img.width;
        height = img.height;

        if (drewMap) {
          width = width / ratio;
          height = height / ratio;
        }
      }

      var xOffset = style.graphicXOffset - 0.5 * width;
      var yOffset = style.graphicYOffset - 0.5 * height;
      var pointOffsetX = style.pointOffsetX;
      var pointOffsetY = style.pointOffsetY;

      if (!pointOffsetX) {
        pointOffsetX = 0;
      }

      if (!pointOffsetY) {
        pointOffsetY = 0;
      }

      var point = [feature.datas[0][0][0], feature.datas[0][0][1]];
      point[0] = point[0] + pointOffsetX;
      point[1] = point[1] + pointOffsetY;
      var x = point[0] + xOffset;
      var y = point[1] + yOffset;
      var opacity = style.pointFillAlpha || 1; // 画过的不画

      if (drewMap) {
        var drewMark = style.texture + "_" + x + "_" + y;

        if (drewMap.get(drewMark) == null) {
          drewMap.set(drewMark, true);
        } else {
          return;
        }
      }

      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.drawImage(img, x * ratio, y * ratio, width * ratio, height * ratio);
      ctx.restore(); //拾取检测用的矩形

      if (hitDetection) {
        hitCtx.save();
        this.setHitContextStyle(hitCtx, feature.id);
        hitCtx.fillRect(x, y, width, height);
        hitCtx.restore();
      }
    }
    /**
     * 画点注记
     * Parameters:
     *  ctx - 画布对象
     *  hitCtx - 画拾取box的画布对象
     * hitDetection - 是否绘制拾取的box
     * feature - 设置过样式，转换过为屏幕坐标，避让过的注记数据
     */

  }, {
    key: "drawPoint",
    value: function drawPoint(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection, quadrant) {
      if (!feature.label) {
        return;
      } //不在范围内的不绘制


      var pt = feature.textPoint;

      if (drewMap) {
        //如果这个注记不在渲染格网里面，则不绘制；
        var polyIn = GisTools["a" /* default */].boxToPolyArr(feature.box[0], feature.box[1], feature.box[2], feature.box[3]);
        var polyOut;

        if (ctx.canvas.width / ratio == 512) {
          polyOut = GisTools["a" /* default */].boxToPolyArr(-20, -20, 532, 532);
        } else if (ctx.canvas.width / ratio == 256) {
          switch (quadrant) {
            case 0:
              polyOut = GisTools["a" /* default */].boxToPolyArr(-15, -15, 271, 271);
              break;

            case 1:
              polyOut = GisTools["a" /* default */].boxToPolyArr(-15 + 256, -15, 271 + 256, 271);
              break;

            case 2:
              polyOut = GisTools["a" /* default */].boxToPolyArr(-15, -15 + 256, 271, 271 + 256);
              break;

            case 3:
              polyOut = GisTools["a" /* default */].boxToPolyArr(-15 + 256, -15 + 256, 271 + 256, 271 + 256);
              break;
          }
        }

        if (GisTools["a" /* default */].polyWith(polyOut, polyIn) == 3) {
          return;
        }

        var drewKey = feature.label + "_" + pt[0] + "_" + pt[1];

        if (drewMap.get(drewKey) == null) {
          drewMap.set(drewKey, true);
        } else {
          return;
        }
      }

      var labelRows = feature.label.split(' ');
      var numRows = labelRows.length;
      var lineHeight = style.pointHeight;
      lineHeight = lineHeight + 2;
      var pointFillFont = AvoidUtil["a" /* default */].formatFont(style.pointFillFont, ratio, isChangeFont);
      var pointStrokeFont = AvoidUtil["a" /* default */].formatFont(style.pointStrokeFont, ratio, isChangeFont);
      ctx.save();
      ctx.font = pointStrokeFont;
      var maxWidth = 0;
      var rowWidths = [];

      for (var i = 0; i < numRows; i++) {
        var itemWdith = Util["a" /* default */].measureText(labelRows[i].replace(/&nbsp;/g, " "), ctx.font, ctx);
        rowWidths.push(itemWdith);

        if (itemWdith > maxWidth) {
          maxWidth = itemWdith;
        }
      }

      ctx.restore();
      var rectX = pt[0] - style.pointBackgroundGap;
      var rectY = pt[1] - style.pointBackgroundGap - style.pointHeight / 2;

      if (style.pointHashBackground == true) {
        ctx.save();
        ctx.globalAlpha = style.pointBackgroundAlpha;
        ctx.strokeStyle = style.pointBackgroundLineColor;
        ctx.lineWidth = style.pointBackgroundLineWidth;
        ctx.fillStyle = style.pointBackgroundColor;
        ctx.font = style.pointFillFont;
        this.drawRoundRect(ctx, rectX, rectY, maxWidth / ratio + style.pointBackgroundGap * 2, style.pointHeight * numRows + style.pointBackgroundGap * 2 + (numRows - 1) * 2, style.pointBackgroundRadius, ratio);
        ctx.fill();
        ctx.restore();
      } //获取文字在图标的哪个方向


      var direction = this.getPointTextDirection(pt[0], feature.datas[0][0][0], maxWidth);
      this.drawPointText(ctx, labelRows, direction, style, pointFillFont, pointStrokeFont, lineHeight, ratio, pt, rowWidths, maxWidth, feature); //拾取检测用的矩形

      if (hitDetection) {
        if (style.pointHashBackground == true) {
          hitCtx.save();
          this.setHitContextStyle(hitCtx, feature.id);
          this.drawHitRoundRect(hitCtx, rectX, rectY, maxWidth / ratio + style.pointBackgroundGap * 2, lineHeight * numRows + style.pointBackgroundGap * 2, style.pointBackgroundRadius);
          hitCtx.fill();
          hitCtx.restore();
        } else {
          hitCtx.save();
          this.setHitContextStyle(hitCtx, feature.id);
          hitCtx.textBaseline = "middle";
          hitCtx.fillRect(pt[0], pt[1] - style.pointHeight / 2, maxWidth / ratio, lineHeight * numRows);
          hitCtx.restore();
        }
      }
    }
  }, {
    key: "getPointTextDirection",
    value: function getPointTextDirection(textPointX, iconPointX, maxWidth) {
      //文字在图标的右侧
      if (textPointX > iconPointX) {
        return 0;
      } //文字在图标左侧


      if (iconPointX > textPointX + maxWidth) {
        return 1;
      }

      return 2;
    }
  }, {
    key: "drawPointText",
    value: function drawPointText(ctx, labelRows, direction, style, pointFillFont, pointStrokeFont, lineHeight, ratio, pt, rowWidths, maxWidth, feature) {
      var numRows = labelRows.length;

      for (var i = 0; i < numRows; i++) {
        var rowWidth = rowWidths[i];
        var x = pt[0]; //文字在图标左侧

        if (direction == 1) {
          x = pt[0] + (maxWidth - rowWidth);
        } //文字在图标上方或者下方


        if (direction == 2) {
          x = pt[0] + (maxWidth - rowWidth) * 0.5;
        }

        if (style.pointHashOutline == true) {
          ctx.save();
          ctx.textBaseline = "middle";
          ctx.globalAlpha = style.pointStrokeAlpha;
          ctx.strokeStyle = style.pointStrokeStyle;
          ctx.lineWidth = style.pointLineWidth;
          ctx.font = pointStrokeFont;
          ctx.strokeText(labelRows[i].replace(/&nbsp;/g, " "), x * ratio, (pt[1] + lineHeight * i) * ratio);
          ctx.restore();
        }

        ctx.save();
        ctx.textBaseline = "middle";
        ctx.globalAlpha = style.pointFillAlpha;

        if (feature.hasOwnProperty('lightColor')) {
          ctx.fillStyle = feature.lightColor;
        } else {
          if (feature.hidden) {
            ctx.fillStyle = '#969393';
          } else {
            ctx.fillStyle = style.pointFillStyle;
          }
        }

        ctx.font = pointFillFont;
        ctx.fillText(labelRows[i].replace(/&nbsp;/g, " "), x * ratio, (pt[1] + lineHeight * i) * ratio);
        ctx.restore();
      }
    }
    /**
     * 画线注记
     * Parameters:
     *  ctx - 画布对象
     * hitCtx - 画拾取box的画布对象
     * hitDetection - 是否绘制拾取的box
     * feature - 设置过样式，转换过为屏幕坐标，避让过的注记数据
     */

  }, {
    key: "drawLine",
    value: function drawLine(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection, quadrant) {
      if (feature.lineType == 'text') {
        this.drawLineText(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection, quadrant);
      }

      if (feature.lineType == 'code') {
        this.drawLineCode(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection);
      }

      if (feature.lineType == 'arrow') {
        this.drawLineArrow(ctx, feature, style, ratio, drewMap, hitCtx, hitDetection);
      }
    }
    /**
     * 画线文本注记
     * Parameters:
     *  ctx - 画布对象
     * hitCtx - 画拾取box的画布对象
     * hitDetection - 是否绘制拾取的box
     * feature - 设置过样式，转换过为屏幕坐标，避让过的注记数据
     */

  }, {
    key: "drawLineText",
    value: function drawLineText(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection, quadrant) {
      var label = feature.label;
      var textPoints = feature.textPoints;
      var lineBoxSet;

      if (drewMap) {
        // 如果是512 则使用boxset 512
        if (ctx.canvas.width / ratio == 512) {
          lineBoxSet = _boxSet512;
        } else if (ctx.canvas.width / ratio == 256) {
          // lineBoxSet = _boxSet256;
          switch (quadrant) {
            case 0:
              lineBoxSet = _boxSet256_0;
              break;

            case 1:
              lineBoxSet = _boxSet256_1;
              break;

            case 2:
              lineBoxSet = _boxSet256_2;
              break;

            case 3:
              lineBoxSet = _boxSet256_3;
              break;
          }
        }
      }

      var lineFillFont = AvoidUtil["a" /* default */].formatFont(style.lineFillFont, ratio, isChangeFont);
      var lineStrokeFont = AvoidUtil["a" /* default */].formatFont(style.lineStrokeFont, ratio, isChangeFont); //去掉尾部的空格
      //只有一个点，或者是有线背景矩形框

      if (style.lineHashBackground == true || textPoints.length == 1) {
        var index = Math.floor(textPoints.length / 2);
        var localPoint = textPoints[index][0];

        if (textPoints.length == 1) {
          this.drawBgText(ctx, label, ratio, localPoint, style.backgroundAlpha, style.backgroundLineColor, style.backgroundLineWidth, style.backgroundColor, style.lineFillFont, style.lineBackgroundGap, style.lineHeight, style.lineBackgroundRadius, style.lineHashOutline, style.lineStrokeAlpha, style.lineStrokeStyle, style.lineLineWidth, style.lineStrokeFont, style.lineFillAlpha, style.lineFillStyle, hitCtx, hitDetection, feature.id, style.lineHashBackground, isChangeFont, feature);
        } else {
          this.drawBgText(ctx, label, ratio, localPoint, style.backgroundAlpha, style.backgroundLineColor, style.backgroundLineWidth, style.backgroundColor, style.lineFillFont, style.lineBackgroundGap, style.lineHeight, style.lineBackgroundRadius, style.lineHashOutline, style.lineStrokeAlpha, style.lineStrokeStyle, style.lineLineWidth, style.lineStrokeFont, style.lineFillAlpha, style.lineFillStyle, hitCtx, hitDetection, feature.id, true, isChangeFont, feature);
        }
      } else {
        var lineFillStyle = feature.lineFillStyle ? feature.lineFillStyle : style.lineFillStyle; //开始绘制线注记

        for (var j = 0; j < label.length; j++) {
          var pa = textPoints[j];
          var angle = pa[1];
          var point = pa[0];
          var labelChar = label.charAt(j);

          if (drewMap) {
            var drewKey = labelChar + "_" + point[0] + "_" + point[1] + "_" + angle;

            if (drewMap.get(drewKey) != null) {
              continue;
            }

            drewMap.set(drewKey, true);

            if (!lineBoxSet["in"]([point[0] / ratio, point[1] / ratio])) {
              continue;
            }
          }

          if (style.lineHashOutline == true) {
            ctx.save();
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.globalAlpha = style.lineStrokeAlpha;
            ctx.strokeStyle = style.lineStrokeStyle;
            ctx.lineWidth = style.lineLineWidth;
            ctx.font = lineStrokeFont;
            ctx.translate(point[0] * ratio, point[1] * ratio);
            ctx.rotate(angle * Math.PI / 180);
            ctx.strokeText(labelChar, 0, 0);
            ctx.restore();
          }

          ctx.save();
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.globalAlpha = style.lineFillAlpha;

          if (feature.hasOwnProperty('lightColor')) {
            ctx.fillStyle = feature.lightColor;
          } else {
            if (feature.hidden) {
              ctx.fillStyle = '#969393';
            } else {
              ctx.fillStyle = lineFillStyle;
            }
          }

          ctx.font = lineFillFont;
          ctx.translate(point[0] * ratio, point[1] * ratio);
          ctx.rotate(angle * Math.PI / 180);
          ctx.fillText(labelChar, 0, 0);
          ctx.restore(); //拾取检测用的矩形

          if (hitDetection) {
            hitCtx.save();
            this.setHitContextStyle(hitCtx, feature.id);
            hitCtx.translate(point[0], point[1]);
            hitCtx.rotate(angle * Math.PI / 180);
            hitCtx.fillRect(-style.lineHeight * 1.2 * 0.5, -style.lineHeight * 1.2 * 0.5, style.lineHeight * 1.2, style.lineHeight * 1.2);
            hitCtx.restore();
          }
        }
      }
    }
    /**
     * 画线编码注记
     * Parameters:
     *  ctx - 画布对象
     * hitCtx - 画拾取box的画布对象
     * hitDetection - 是否绘制拾取的box
     * feature - 设置过样式，转换过为屏幕坐标，避让过的注记数据
     */

  }, {
    key: "drawLineCode",
    value: function drawLineCode(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection) {
      var localPoint = feature.codePoint;
      var codeLabel = feature.label;

      if (style.showRoadCode == true && codeLabel && codeLabel.length > 0) {
        this.drawBgText(ctx, codeLabel, ratio, localPoint, style.codeBackgroundAlpha, style.codeBackgroundLineColor, style.codeBackgroundLineWidth, style.codeBackgroundColor, style.codeLineFillFont, style.codeLineBackgroundGap, style.codeLineHeight, style.codeLineBackgroundRadius, style.codeLineHashOutline, style.codeLineStrokeAlpha, style.codeLineStrokeStyle, style.codeLineLineWidth, style.codeLineStrokeFont, style.codeLineFillAlpha, style.codeLineFillStyle, hitCtx, hitDetection, feature.id, true, isChangeFont, feature);
      }
    }
    /**
     * 画线箭头
     * Parameters:
     *  ctx - 画布对象
     * hitCtx - 画拾取box的画布对象
     * hitDetection - 是否绘制拾取的box
     * feature - 设置过样式，转换过为屏幕坐标，避让过的注记数据
     */

  }, {
    key: "drawLineArrow",
    value: function drawLineArrow(ctx, feature, style, ratio, drewMap, hitCtx, hitDetection) {
      var points = feature.arrowPoint;
      var direction = style.arrowDirectionValue;

      if (style.arrowDirectionField) {
        direction = feature.attributes[style.arrowDirectionField];
      }

      var p1 = points[0][0];
      var p2 = points[1][0];

      if (direction == 0) {
        p1 = points[1][0];
        p2 = points[2][0];
      }

      ctx.save();
      ctx.lineWidth = style.arrowLineWidth;
      ctx.strokeStyle = style.arrowFillStyle;

      if (feature.hasOwnProperty('lightColor')) {
        ctx.fillStyle = feature.lightColor;
      } else {
        if (feature.hidden) {
          ctx.fillStyle = '#969393';
        } else {
          ctx.fillStyle = style.arrowFillStyle;
        }
      } //画线


      ctx.beginPath();
      ctx.moveTo(p1[0] * ratio, p1[1] * ratio);
      ctx.lineTo(p2[0] * ratio, p2[1] * ratio);
      ctx.stroke();
      var startRadians = 0;
      var radians = 0;

      if (p2[0] == p1[0]) {
        if (direction && p2[1] > p1[1] || !direction && p2[1] < p1[1]) {
          startRadians = Math.PI;
        }
      } else {
        startRadians = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));
        radians = (p2[0] > p1[0] ? 90 : -90) * Math.PI / 180;
      } //画箭头


      if (direction == 0) {
        startRadians = startRadians - radians;
        this.drawArrowhead(ctx, p1[0], p1[1], startRadians, ratio, style.arrowSize);
      } else {
        startRadians = startRadians + radians;
        this.drawArrowhead(ctx, p2[0], p2[1], startRadians, ratio, style.arrowSize);
      }

      ctx.restore();
    }
    /**
     * 画箭头的头
     * Parameters:
     */

  }, {
    key: "drawArrowhead",
    value: function drawArrowhead(ctx, x, y, radians, ratio, size) {
      ctx.beginPath();
      ctx.translate(x * ratio, y * ratio);
      ctx.rotate(radians);
      ctx.moveTo(0, -size * ratio);
      ctx.lineTo(size * 0.5 * ratio, 0);
      ctx.lineTo(-size * 0.5 * ratio, 0);
      ctx.closePath();
      ctx.fill();
    }
    /**
     * 画圆角矩形
     */

  }, {
    key: "drawRoundRect",
    value: function drawRoundRect(ctx, x, y, width, height, radius, ratio) {
      ctx.beginPath();
      ctx.arc((x + radius) * ratio, (y + radius) * ratio, radius * ratio, Math.PI, Math.PI * 3 / 2);
      ctx.lineTo((width - radius + x) * ratio, y * ratio);
      ctx.arc((width - radius + x) * ratio, (radius + y) * ratio, radius * ratio, Math.PI * 3 / 2, Math.PI * 2);
      ctx.lineTo((width + x) * ratio, (height + y - radius) * ratio);
      ctx.arc((width - radius + x) * ratio, (height - radius + y) * ratio, radius * ratio, 0, Math.PI * 1 / 2);
      ctx.lineTo((radius + x) * ratio, (height + y) * ratio);
      ctx.arc((radius + x) * ratio, (height - radius + y) * ratio, radius * ratio, Math.PI * 1 / 2, Math.PI);
      ctx.closePath();
    }
    /**
     * 绘制带背景的线文本
     */

  }, {
    key: "drawBgText",
    value: function drawBgText(ctx, label, ratio, localPoint, backgroundAlpha, backgroundLineColor, backgroundLineWidth, backgroundColor, lineFillFont, lineBackgroundGap, lineHeight, lineBackgroundRadius, lineHashOutline, lineStrokeAlpha, lineStrokeStyle, lineLineWidth, lineStrokeFont, lineFillAlpha, lineFillStyle, hitCtx, hitDetection, featureId, isDrawbg, isChangeFont, feature) {
      localPoint[0] = Math.round(localPoint[0]);
      localPoint[1] = Math.round(localPoint[1]);
      ctx.save();
      ctx.globalAlpha = backgroundAlpha;
      ctx.strokeStyle = backgroundLineColor;
      ctx.lineWidth = backgroundLineWidth;
      ctx.fillStyle = backgroundColor;
      ctx.font = AvoidUtil["a" /* default */].formatFont(lineFillFont, 1, isChangeFont);
      var w = Util["a" /* default */].measureText(label, ctx.font, ctx);
      var rectX = localPoint[0] - w / 2 - lineBackgroundGap;
      var rectY = localPoint[1] - lineHeight / 2 - lineBackgroundGap;

      if (isDrawbg) {
        this.drawRoundRect(ctx, rectX, rectY, w + lineBackgroundGap * 2, lineHeight + lineBackgroundGap * 2, lineBackgroundRadius, ratio);
        ctx.fill();
      }

      ctx.restore();
      lineFillFont = AvoidUtil["a" /* default */].formatFont(lineFillFont, ratio, isChangeFont);
      lineStrokeFont = AvoidUtil["a" /* default */].formatFont(lineStrokeFont, ratio, isChangeFont);

      if (lineHashOutline == true) {
        ctx.save();
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.globalAlpha = lineStrokeAlpha;
        ctx.strokeStyle = lineStrokeStyle;
        ctx.lineWidth = lineLineWidth;
        ctx.font = lineStrokeFont;
        ctx.translate(localPoint[0] * ratio, localPoint[1] * ratio);
        ctx.strokeText(label, 0, 0);
        ctx.restore();
      }

      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.globalAlpha = lineFillAlpha;

      if (feature.hasOwnProperty('lightColor')) {
        ctx.fillStyle = feature.lightColor;
      } else {
        if (feature.hidden) {
          ctx.fillStyle = '#969393';
        } else {
          ctx.fillStyle = lineFillStyle;
        }
      }

      ctx.font = lineFillFont;
      ctx.translate(localPoint[0] * ratio, localPoint[1] * ratio);
      ctx.fillText(label, 0, 0);
      ctx.restore(); //拾取检测用的矩形

      if (hitDetection) {
        hitCtx.save();
        this.setHitContextStyle(hitCtx, featureId);
        this.drawHitRoundRect(hitCtx, rectX, rectY, w + lineBackgroundGap * 2, lineHeight + lineBackgroundGap * 2, lineBackgroundRadius);
        hitCtx.fill();
        hitCtx.restore();
      }
    }
    /**
     * 绘制点的默认样式
     */

  }, {
    key: "drawPointDefaultStyle",
    value: function drawPointDefaultStyle(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection) {
      var pt = feature.datas[0][0];
      ctx.save();
      ctx.fillStyle = style.pointFillStyle;
      ctx.beginPath();
      ctx.arc(pt[0], pt[1], style.radius, 0, 2 * Math.PI);
      ctx.fill();
      ctx.restore(); //拾取检测用的矩形

      if (hitDetection) {
        hitCtx.save();
        this.setHitContextStyle(hitCtx, feature.id);
        hitCtx.beginPath();
        hitCtx.arc(pt[0], pt[1], style.radius, 0, 2 * Math.PI);
        hitCtx.fill();
        hitCtx.restore();
      }
    }
    /**
     * 绘制线的默认样式
     */

  }, {
    key: "drawLineDefaultStyle",
    value: function drawLineDefaultStyle(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection) {
      var datas = feature.datas;
      ctx.save();
      ctx.lineWidth = style.lineWidth;
      ctx.strokeStyle = style.lineFillStyle;
      ctx.beginPath();
      ctx.moveTo(datas[0][0][0], datas[0][0][1]);

      for (var i = 1; i < datas.length; i++) {
        ctx.lineTo(datas[i][0][0], datas[i][0][1]);
      }

      ctx.stroke();
      ctx.restore();
    }
    /**
     * 根据featureId生成颜色值
     */

  }, {
    key: "featureIdToHex",
    value: function featureIdToHex(featureId) {
      var id = Number(featureId) + 1;
      var hex = "000000" + id.toString(16);
      var len = hex.length;
      hex = "#" + hex.substring(len - 6, len);
      return hex;
    }
  }, {
    key: "setHitContextStyle",
    value: function setHitContextStyle(hitCtx, featureId) {
      var hex = this.featureIdToHex(featureId);
      hitCtx.globalAlpha = 1;
      hitCtx.fillStyle = hex;
    }
    /**
     * 绘制拾取背景框
     */

  }, {
    key: "drawHitRoundRect",
    value: function drawHitRoundRect(hitCtx, x, y, width, height, radius) {
      hitCtx.beginPath();
      hitCtx.arc(x + radius, y + radius, radius, Math.PI, Math.PI * 3 / 2);
      hitCtx.lineTo(width - radius + x, y);
      hitCtx.arc(width - radius + x, radius + y, radius, Math.PI * 3 / 2, Math.PI * 2);
      hitCtx.lineTo(width + x, height + y - radius);
      hitCtx.arc(width - radius + x, height - radius + y, radius, 0, Math.PI * 1 / 2);
      hitCtx.lineTo(radius + x, height + y);
      hitCtx.arc(radius + x, height - radius + y, radius, Math.PI * 1 / 2, Math.PI);
      hitCtx.closePath();
    }
    /**
     *  画线注记的线
     * @param ctx
     * @param features
     * @param styleMap
     * @param ratio
     * @param checkDraw
     * @param isChangeFont
     * @param hitCtx
     * @param hitDetection
     * @param canvaLayer
     */

  }, {
    key: "drawLines",
    value: function drawLines(ctx, features, styleMap, ratio, checkDraw, isChangeFont, hitCtx, hitDetection, canvaLayer) {
      var drewMap = null;

      if (checkDraw) {
        drewMap = new Map();
      }

      for (var i = 0; i < features.length; i++) {
        var feature = features[i]; //画线注记

        if (feature.type == 2) {
          var data = canvaLayer.lineToSourceAngleData(feature.sourceData);
          feature.lines = canvaLayer.transformData(data, feature.xyz);
          var style = styleMap[feature.styleId];
          this.drawLineStyle(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection);
        }
      }

      drewMap = null;
    }
  }, {
    key: "drawLineStyle",

    /**
     * 绘制线的默认样式
     */
    value: function drawLineStyle(ctx, feature, style, ratio, drewMap, isChangeFont, hitCtx, hitDetection) {
      var datas = feature.lines;
      ctx.save();
      ctx.lineWidth = style.lineWidth;
      ctx.strokeStyle = style.lineFillStyle;
      ctx.beginPath();
      ctx.moveTo(datas[0][0][0], datas[0][0][1]);

      for (var i = 1; i < datas.length; i++) {
        ctx.lineTo(datas[i][0][0], datas[i][0][1]);
      }

      ctx.stroke();
      ctx.restore();
    } //画避让盒子

  }, {
    key: "drawAvoidBox",
    value: function drawAvoidBox(ctx, box, hidden) {
      ctx.save();
      ctx.lineWidth = 1;

      if (hidden) {
        ctx.strokeStyle = '#969393';
      } else {
        ctx.strokeStyle = '#2d8cf0';
      }

      ctx.beginPath();
      ctx.moveTo(box[0], box[1]);
      ctx.lineTo(box[2], box[1]);
      ctx.lineTo(box[2], box[3]);
      ctx.lineTo(box[0], box[3]);
      ctx.lineTo(box[0], box[1]);
      ctx.stroke();
      ctx.restore();
    } //隐藏的注记排前面先画

  }, {
    key: "sort",
    value: function sort(features) {
      if (features.length > 0) {
        //从大到少排序
        return features.sort(function (a, b) {
          if (!a.hidden && b.hidden) {
            return 1;
          }

          if (a.hidden && !b.hidden) {
            return -1;
          }

          return 0;
        });
      }
    }
  }]);

  return GDrawGeomerty;
}();

/* harmony default export */ var avoid_GDrawGeomerty = __webpack_exports__["a"] = (GDrawGeomerty_GDrawGeomerty);

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);

var TipPopup = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Popup.extend({
  includes: leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Evented.prototype,
  initialize: function initialize(options, source) {
    this._sort = "tip-popup";
    leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Popup.prototype.initialize.call(this, options, source);
  },
  _getEvents: function _getEvents() {
    var events = {
      viewreset: this._updatePosition
    };

    if (this._animated) {
      events.zoomanim = this._zoomAnimation;
    }

    if (this.options.keepInView) {
      events.moveend = this._adjustPan;
    }

    return events;
  },

  /**
   * 在地图上开启弹框
   * @method L.TipPopup#openOn
   * @param {L.Map} map - 地图对象
   */
  openOn: function openOn(map) {
    map.openTipPopup(this);
  },
  _initLayout: function _initLayout() {
    var prefix = 'leaflet-popup',
        containerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' + (this._animated ? 'animated' : 'hide'),
        container = this._container = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.DomUtil.create('div', containerClass);
    var wrapper = this._wrapper = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.DomUtil.create('div', prefix + '-content-wrapper measure-tip-wrapper', container);
    leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.DomEvent.disableClickPropagation(wrapper);
    this._contentNode = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.DomUtil.create('div', prefix + '-tipcontent', wrapper);
    leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.DomEvent.disableScrollPropagation(this._contentNode);
    leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.DomEvent.on(wrapper, 'contextmenu', leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.DomEvent.stopPropagation);
  }
});
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Map.include({
  /**
   * 在地图上开启弹框
   * @method L.Map#openTipPopup
   * @param {L.TipPopup} popup - 提示框
   * @param {L.LatLng} latlng - 弹框坐标位置
   * @param {object} options - 弹框参数，参见L.Popup
   */
  openTipPopup: function openTipPopup(popup, latlng, options) {
    if (!(popup instanceof leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Popup)) {
      var content = popup;
      popup = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.TipPopup(options).setLatLng(latlng).setContent(content);
    }

    popup._isOpen = true;
    this._popup = popup;
    return this.addLayer(popup);
  },

  /**
   * 在地图上关闭弹框
   * @method L.Map#closePopup
   * @param {L.TipPopup} popup - 提示框
   */
  closePopup: function closePopup(popup) {
    if (!popup || popup === this._popup) {
      popup = this._popup;
      this._popup = null;
    }
    /*重写弹框关闭时不关闭提示浮云框*/


    if (popup && popup._sort != "tip-popup") {
      this.removeLayer(popup);
      popup._isOpen = false;
    }

    return this;
  }
});
/* harmony default export */ __webpack_exports__["a"] = (TipPopup);

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by kongjian on 2017/6/30.
 */



var FilterLayer = /*#__PURE__*/function () {
  function FilterLayer() {
    _classCallCheck(this, FilterLayer);

    //过滤图层的唯一标识
    this.id = null; //过滤条件

    this.filters = {}; //过滤数据的唯一id标识

    this.idFilter = null; //过滤字符串,与制图系统中的过滤字符串一致，如果同时也有filters，服务会优先使用filterStr

    this.filterStr = null; //是否显示

    this.display = true; //高亮对象,默认为null时，使用配图的默认样式。 示例：{"color":"%23f00fff","opacity":0.9}， 其中颜色值必须用%23开头

    this.color = null;
  }
  /**
   * 添加字段过滤条件
   * Parameters :
   * key - 如： Q_fcode_S_EQ，表示fcode等于value的值
   * value - 如：2101010500
   */


  _createClass(FilterLayer, [{
    key: "addFilterField",
    value: function addFilterField(key, value) {
      this.filters[key] = value;
    }
    /**
     * 添加字段过滤条件
     * Parameters :
     * key
     */

  }, {
    key: "removeFilterField",
    value: function removeFilterField(key) {
      delete this.filters[key];
    }
  }]);

  return FilterLayer;
}();

leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.geoway.FilterLayer = FilterLayer;
/* harmony default export */ __webpack_exports__["a"] = (FilterLayer);

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);

var Format = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Class.extend({
  options: null,
  initialize: function initialize(options) {
    this.options = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.setOptions(this, options);
  },
  destroy: function destroy() {},
  read: function read() {},
  write: function write() {}
});
/* harmony default export */ __webpack_exports__["a"] = (Format);

/***/ }),
/* 18 */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by kongjian on 2017/6/30.
 */



var Filter = /*#__PURE__*/function () {
  function Filter() {
    _classCallCheck(this, Filter);

    //该值为ture时，后面的layers是全部要显示的，如果为false，后面的layers全部不显示,顶替上面的cmdAll
    this.otherDisplay = true; //图层集合

    this.layers = []; //里面存放layerName，最终渲染的图层顺序以该图层存放的顺序为准，如果为空数组，则以样式文件中的顺序为准. 注记图层，该属性会被忽略

    this.order = [];
  }
  /**
   * 添加过滤图层
   * Parameters :
   * filterLayer - 过滤图层
   */


  _createClass(Filter, [{
    key: "addFilterLayer",
    value: function addFilterLayer(filterLayer) {
      this.layers.push(filterLayer);
    }
    /**
     * 移除过滤图层
     * Parameters :
     * filterLayerId - 过滤图层ID
     */

  }, {
    key: "removeFilterLayerById",
    value: function removeFilterLayerById(filterLayerId) {
      for (var i = 0; i < this.layers.length; i++) {
        if (this.layers[i].id == filterLayerId) {
          this.layers.splice(i, 1);
        }
      }
    }
  }]);

  return Filter;
}();

leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.geoway.Filter = Filter;
/* harmony default export */ __webpack_exports__["a"] = (Filter);

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ CRS; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ crs; });

// EXTERNAL MODULE: external "L"
var external_L_ = __webpack_require__(0);
var external_L_default = /*#__PURE__*/__webpack_require__.n(external_L_);

// CONCATENATED MODULE: ./node_modules/proj4/lib/global.js
/* harmony default export */ var global = (function (defs) {
  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  defs.WGS84 = defs['EPSG:4326'];
  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857

  defs.GOOGLE = defs['EPSG:3857'];
  defs['EPSG:900913'] = defs['EPSG:3857'];
  defs['EPSG:102113'] = defs['EPSG:3857'];
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/values.js
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_WGS84 = 4; // WGS84 or equivalent

var PJD_NODATUM = 5; // WGS84 or equivalent

var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
var HALF_PI = Math.PI / 2; // ellipoid pj_set_ell.c

var SIXTH = 0.1666666666666666667;
/* 1/6 */

var RA4 = 0.04722222222222222222;
/* 17/360 */

var RA6 = 0.02215608465608465608;
var EPSLN = 1.0e-10; // you'd think you could use Number.EPSILON above but that makes
// Mollweide get into an infinate loop.

var D2R = 0.01745329251994329577;
var R2D = 57.29577951308232088;
var FORTPI = Math.PI / 4;
var TWO_PI = Math.PI * 2; // SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.

var SPI = 3.14159265359;
// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/PrimeMeridian.js
var PrimeMeridian_exports = {};

PrimeMeridian_exports.greenwich = 0.0; //"0dE",

PrimeMeridian_exports.lisbon = -9.131906111111; //"9d07'54.862\"W",

PrimeMeridian_exports.paris = 2.337229166667; //"2d20'14.025\"E",

PrimeMeridian_exports.bogota = -74.080916666667; //"74d04'51.3\"W",

PrimeMeridian_exports.madrid = -3.687938888889; //"3d41'16.58\"W",

PrimeMeridian_exports.rome = 12.452333333333; //"12d27'8.4\"E",

PrimeMeridian_exports.bern = 7.439583333333; //"7d26'22.5\"E",

PrimeMeridian_exports.jakarta = 106.807719444444; //"106d48'27.79\"E",

PrimeMeridian_exports.ferro = -17.666666666667; //"17d40'W",

PrimeMeridian_exports.brussels = 4.367975; //"4d22'4.71\"E",

PrimeMeridian_exports.stockholm = 18.058277777778; //"18d3'29.8\"E",

PrimeMeridian_exports.athens = 23.7163375; //"23d42'58.815\"E",

PrimeMeridian_exports.oslo = 10.722916666667; //"10d43'22.5\"E"
// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/units.js
/* harmony default export */ var constants_units = ({
  ft: {
    to_meter: 0.3048
  },
  'us-ft': {
    to_meter: 1200 / 3937
  }
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/match.js
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }

  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, '');
  var i = -1;
  var testkey, processedKey;

  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, '');

    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}
// CONCATENATED MODULE: ./node_modules/proj4/lib/projString.js




/* harmony default export */ var projString = (function (defData) {
  var self = {};
  var paramObj = defData.split('+').map(function (v) {
    return v.trim();
  }).filter(function (a) {
    return a;
  }).reduce(function (p, a) {
    var split = a.split('=');
    split.push(true);
    p[split[0].toLowerCase()] = split[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params = {
    proj: 'projName',
    datum: 'datumCode',
    rf: function rf(v) {
      self.rf = parseFloat(v);
    },
    lat_0: function lat_0(v) {
      self.lat0 = v * D2R;
    },
    lat_1: function lat_1(v) {
      self.lat1 = v * D2R;
    },
    lat_2: function lat_2(v) {
      self.lat2 = v * D2R;
    },
    lat_ts: function lat_ts(v) {
      self.lat_ts = v * D2R;
    },
    lon_0: function lon_0(v) {
      self.long0 = v * D2R;
    },
    lon_1: function lon_1(v) {
      self.long1 = v * D2R;
    },
    lon_2: function lon_2(v) {
      self.long2 = v * D2R;
    },
    alpha: function alpha(v) {
      self.alpha = parseFloat(v) * D2R;
    },
    lonc: function lonc(v) {
      self.longc = v * D2R;
    },
    x_0: function x_0(v) {
      self.x0 = parseFloat(v);
    },
    y_0: function y_0(v) {
      self.y0 = parseFloat(v);
    },
    k_0: function k_0(v) {
      self.k0 = parseFloat(v);
    },
    k: function k(v) {
      self.k0 = parseFloat(v);
    },
    a: function a(v) {
      self.a = parseFloat(v);
    },
    b: function b(v) {
      self.b = parseFloat(v);
    },
    r_a: function r_a() {
      self.R_A = true;
    },
    zone: function zone(v) {
      self.zone = parseInt(v, 10);
    },
    south: function south() {
      self.utmSouth = true;
    },
    towgs84: function towgs84(v) {
      self.datum_params = v.split(",").map(function (a) {
        return parseFloat(a);
      });
    },
    to_meter: function to_meter(v) {
      self.to_meter = parseFloat(v);
    },
    units: function units(v) {
      self.units = v;
      var unit = match(constants_units, v);

      if (unit) {
        self.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function from_greenwich(v) {
      self.from_greenwich = v * D2R;
    },
    pm: function pm(v) {
      var pm = match(PrimeMeridian_exports, v);
      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
    },
    nadgrids: function nadgrids(v) {
      if (v === '@null') {
        self.datumCode = 'none';
      } else {
        self.nadgrids = v;
      }
    },
    axis: function axis(v) {
      var legalAxis = "ewnsud";

      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self.axis = v;
      }
    }
  };

  for (paramName in paramObj) {
    paramVal = paramObj[paramName];

    if (paramName in params) {
      paramOutname = params[paramName];

      if (typeof paramOutname === 'function') {
        paramOutname(paramVal);
      } else {
        self[paramOutname] = paramVal;
      }
    } else {
      self[paramName] = paramVal;
    }
  }

  if (typeof self.datumCode === 'string' && self.datumCode !== "WGS84") {
    self.datumCode = self.datumCode.toLowerCase();
  }

  return self;
});
// CONCATENATED MODULE: ./node_modules/wkt-parser/parser.js
/* harmony default export */ var parser = (parseString);
var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/; // const ignoredChar = /[\s_\-\/\(\)]/g;

function Parser(text) {
  if (typeof text !== 'string') {
    throw new Error('not a string');
  }

  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}

Parser.prototype.readCharicter = function () {
  var _char = this.text[this.place++];

  if (this.state !== QUOTED) {
    while (whitespace.test(_char)) {
      if (this.place >= this.text.length) {
        return;
      }

      _char = this.text[this.place++];
    }
  }

  switch (this.state) {
    case NEUTRAL:
      return this.neutral(_char);

    case KEYWORD:
      return this.keyword(_char);

    case QUOTED:
      return this.quoted(_char);

    case AFTERQUOTE:
      return this.afterquote(_char);

    case NUMBER:
      return this.number(_char);

    case ENDED:
      return;
  }
};

Parser.prototype.afterquote = function (_char2) {
  if (_char2 === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }

  if (endThings.test(_char2)) {
    this.word = this.word.trim();
    this.afterItem(_char2);
    return;
  }

  throw new Error('havn\'t handled "' + _char2 + '" in afterquote yet, index ' + this.place);
};

Parser.prototype.afterItem = function (_char3) {
  if (_char3 === ',') {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }

    this.word = null;
    this.state = NEUTRAL;
    return;
  }

  if (_char3 === ']') {
    this.level--;

    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }

    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();

    if (!this.currentObject) {
      this.state = ENDED;
    }

    return;
  }
};

Parser.prototype.number = function (_char4) {
  if (digets.test(_char4)) {
    this.word += _char4;
    return;
  }

  if (endThings.test(_char4)) {
    this.word = parseFloat(this.word);
    this.afterItem(_char4);
    return;
  }

  throw new Error('havn\'t handled "' + _char4 + '" in number yet, index ' + this.place);
};

Parser.prototype.quoted = function (_char5) {
  if (_char5 === '"') {
    this.state = AFTERQUOTE;
    return;
  }

  this.word += _char5;
  return;
};

Parser.prototype.keyword = function (_char6) {
  if (keyword.test(_char6)) {
    this.word += _char6;
    return;
  }

  if (_char6 === '[') {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;

    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }

    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }

  if (endThings.test(_char6)) {
    this.afterItem(_char6);
    return;
  }

  throw new Error('havn\'t handled "' + _char6 + '" in keyword yet, index ' + this.place);
};

Parser.prototype.neutral = function (_char7) {
  if (latin.test(_char7)) {
    this.word = _char7;
    this.state = KEYWORD;
    return;
  }

  if (_char7 === '"') {
    this.word = '';
    this.state = QUOTED;
    return;
  }

  if (digets.test(_char7)) {
    this.word = _char7;
    this.state = NUMBER;
    return;
  }

  if (endThings.test(_char7)) {
    this.afterItem(_char7);
    return;
  }

  throw new Error('havn\'t handled "' + _char7 + '" in neutral yet, index ' + this.place);
};

Parser.prototype.output = function () {
  while (this.place < this.text.length) {
    this.readCharicter();
  }

  if (this.state === ENDED) {
    return this.root;
  }

  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};

function parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}
// CONCATENATED MODULE: ./node_modules/wkt-parser/process.js
function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }

  var thing = key ? {} : obj;
  var out = value.reduce(function (newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);

  if (key) {
    obj[key] = out;
  }
}

function sExpr(v, obj) {
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }

  var key = v.shift();

  if (key === 'PARAMETER') {
    key = v.shift();
  }

  if (v.length === 1) {
    if (Array.isArray(v[0])) {
      obj[key] = {};
      sExpr(v[0], obj[key]);
      return;
    }

    obj[key] = v[0];
    return;
  }

  if (!v.length) {
    obj[key] = true;
    return;
  }

  if (key === 'TOWGS84') {
    obj[key] = v;
    return;
  }

  if (key === 'AXIS') {
    if (!(key in obj)) {
      obj[key] = [];
    }

    obj[key].push(v);
    return;
  }

  if (!Array.isArray(key)) {
    obj[key] = {};
  }

  var i;

  switch (key) {
    case 'UNIT':
    case 'PRIMEM':
    case 'VERT_DATUM':
      obj[key] = {
        name: v[0].toLowerCase(),
        convert: v[1]
      };

      if (v.length === 3) {
        sExpr(v[2], obj[key]);
      }

      return;

    case 'SPHEROID':
    case 'ELLIPSOID':
      obj[key] = {
        name: v[0],
        a: v[1],
        rf: v[2]
      };

      if (v.length === 4) {
        sExpr(v[3], obj[key]);
      }

      return;

    case 'PROJECTEDCRS':
    case 'PROJCRS':
    case 'GEOGCS':
    case 'GEOCCS':
    case 'PROJCS':
    case 'LOCAL_CS':
    case 'GEODCRS':
    case 'GEODETICCRS':
    case 'GEODETICDATUM':
    case 'EDATUM':
    case 'ENGINEERINGDATUM':
    case 'VERT_CS':
    case 'VERTCRS':
    case 'VERTICALCRS':
    case 'COMPD_CS':
    case 'COMPOUNDCRS':
    case 'ENGINEERINGCRS':
    case 'ENGCRS':
    case 'FITTED_CS':
    case 'LOCAL_DATUM':
    case 'DATUM':
      v[0] = ['name', v[0]];
      mapit(obj, key, v);
      return;

    default:
      i = -1;

      while (++i < v.length) {
        if (!Array.isArray(v[i])) {
          return sExpr(v, obj[key]);
        }
      }

      return mapit(obj, key, v);
  }
}
// CONCATENATED MODULE: ./node_modules/wkt-parser/index.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var wkt_parser_D2R = 0.01745329251994329577;



function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];

  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];

    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}

function d2r(input) {
  return input * wkt_parser_D2R;
}

function cleanWKT(wkt) {
  if (wkt.type === 'GEOGCS') {
    wkt.projName = 'longlat';
  } else if (wkt.type === 'LOCAL_CS') {
    wkt.projName = 'identity';
    wkt.local = true;
  } else {
    if (_typeof(wkt.PROJECTION) === 'object') {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }

  if (wkt.AXIS) {
    var axisOrder = '';

    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
      var axis = wkt.AXIS[i];
      var descriptor = axis[0].toLowerCase();

      if (descriptor.indexOf('north') !== -1) {
        axisOrder += 'n';
      } else if (descriptor.indexOf('south') !== -1) {
        axisOrder += 's';
      } else if (descriptor.indexOf('east') !== -1) {
        axisOrder += 'e';
      } else if (descriptor.indexOf('west') !== -1) {
        axisOrder += 'w';
      }
    }

    if (axisOrder.length === 2) {
      axisOrder += 'u';
    }

    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }

  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();

    if (wkt.units === 'metre') {
      wkt.units = 'meter';
    }

    if (wkt.UNIT.convert) {
      if (wkt.type === 'GEOGCS') {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }

  var geogcs = wkt.GEOGCS;

  if (wkt.type === 'GEOGCS') {
    geogcs = wkt;
  }

  if (geogcs) {
    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
    //}
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }

    if (wkt.datumCode.slice(0, 2) === 'd_') {
      wkt.datumCode = wkt.datumCode.slice(2);
    }

    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
      wkt.datumCode = 'nzgd49';
    }

    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
        wkt.sphere = true;
      }

      wkt.datumCode = 'wgs84';
    }

    if (wkt.datumCode.slice(-6) === '_ferro') {
      wkt.datumCode = wkt.datumCode.slice(0, -6);
    }

    if (wkt.datumCode.slice(-8) === '_jakarta') {
      wkt.datumCode = wkt.datumCode.slice(0, -8);
    }

    if (~wkt.datumCode.indexOf('belge')) {
      wkt.datumCode = 'rnb72';
    }

    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');

      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
        wkt.ellps = 'intl';
      }

      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }

    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }

    if (~wkt.datumCode.indexOf('osgb_1936')) {
      wkt.datumCode = 'osgb36';
    }

    if (~wkt.datumCode.indexOf('osni_1952')) {
      wkt.datumCode = 'osni52';
    }

    if (~wkt.datumCode.indexOf('tm65') || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
      wkt.datumCode = 'ire65';
    }

    if (wkt.datumCode === 'ch1903+') {
      wkt.datumCode = 'ch1903';
    }

    if (~wkt.datumCode.indexOf('israel')) {
      wkt.datumCode = 'isr93';
    }
  }

  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }

  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }

  var renamer = function renamer(a) {
    return rename(wkt, a);
  };

  var list = [['standard_parallel_1', 'Standard_Parallel_1'], ['standard_parallel_2', 'Standard_Parallel_2'], ['false_easting', 'False_Easting'], ['false_northing', 'False_Northing'], ['central_meridian', 'Central_Meridian'], ['latitude_of_origin', 'Latitude_Of_Origin'], ['latitude_of_origin', 'Central_Parallel'], ['scale_factor', 'Scale_Factor'], ['k0', 'scale_factor'], ['latitude_of_center', 'Latitude_Of_Center'], ['latitude_of_center', 'Latitude_of_center'], ['lat0', 'latitude_of_center', d2r], ['longitude_of_center', 'Longitude_Of_Center'], ['longitude_of_center', 'Longitude_of_center'], ['longc', 'longitude_of_center', d2r], ['x0', 'false_easting', toMeter], ['y0', 'false_northing', toMeter], ['long0', 'central_meridian', d2r], ['lat0', 'latitude_of_origin', d2r], ['lat0', 'standard_parallel_1', d2r], ['lat1', 'standard_parallel_1', d2r], ['lat2', 'standard_parallel_2', d2r], ['azimuth', 'Azimuth'], ['alpha', 'azimuth', d2r], ['srsCode', 'name']];
  list.forEach(renamer);

  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
    wkt.long0 = wkt.longc;
  }

  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
  }
}

/* harmony default export */ var wkt_parser = (function (wkt) {
  var lisp = parser(wkt);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(['name', name]);
  lisp.unshift(['type', type]);
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/defs.js




function defs(name) {
  /*global console*/
  var that = this;

  if (arguments.length === 2) {
    var def = arguments[1];

    if (typeof def === 'string') {
      if (def.charAt(0) === '+') {
        defs[name] = projString(arguments[1]);
      } else {
        defs[name] = wkt_parser(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function (v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        } else {
          defs(v);
        }
      });
    } else if (typeof name === 'string') {
      if (name in defs) {
        return defs[name];
      }
    } else if ('EPSG' in name) {
      defs['EPSG:' + name.EPSG] = name;
    } else if ('ESRI' in name) {
      defs['ESRI:' + name.ESRI] = name;
    } else if ('IAU2000' in name) {
      defs['IAU2000:' + name.IAU2000] = name;
    } else {
      console.log(name);
    }

    return;
  }
}

global(defs);
/* harmony default export */ var lib_defs = (defs);
// CONCATENATED MODULE: ./node_modules/proj4/lib/parseCode.js





function testObj(code) {
  return typeof code === 'string';
}

function testDef(code) {
  return code in lib_defs;
}

var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS', 'GEOCCS', 'PROJCS', 'LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];

function testWKT(code) {
  return codeWords.some(function (word) {
    return code.indexOf(word) > -1;
  });
}

var codes = ['3857', '900913', '3785', '102113'];

function checkMercator(item) {
  var auth = match(item, 'authority');

  if (!auth) {
    return;
  }

  var code = match(auth, 'epsg');
  return code && codes.indexOf(code) > -1;
}

function checkProjStr(item) {
  var ext = match(item, 'extension');

  if (!ext) {
    return;
  }

  return match(ext, 'proj4');
}

function testProj(code) {
  return code[0] === '+';
}

function parse(code) {
  if (testObj(code)) {
    //check to see if this is a WKT string
    if (testDef(code)) {
      return lib_defs[code];
    }

    if (testWKT(code)) {
      var out = wkt_parser(code); // test of spetial case, due to this being a very common and often malformed

      if (checkMercator(out)) {
        return lib_defs['EPSG:3857'];
      }

      var maybeProjStr = checkProjStr(out);

      if (maybeProjStr) {
        return projString(maybeProjStr);
      }

      return out;
    }

    if (testProj(code)) {
      return projString(code);
    }
  } else {
    return code;
  }
}

/* harmony default export */ var parseCode = (parse);
// CONCATENATED MODULE: ./node_modules/proj4/lib/extend.js
/* harmony default export */ var extend = (function (destination, source) {
  destination = destination || {};
  var value, property;

  if (!source) {
    return destination;
  }

  for (property in source) {
    value = source[property];

    if (value !== undefined) {
      destination[property] = value;
    }
  }

  return destination;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/msfnz.js
/* harmony default export */ var msfnz = (function (eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/sign.js
/* harmony default export */ var sign = (function (x) {
  return x < 0 ? -1 : 1;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_lon.js


/* harmony default export */ var adjust_lon = (function (x) {
  return Math.abs(x) <= SPI ? x : x - sign(x) * TWO_PI;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/tsfnz.js

/* harmony default export */ var tsfnz = (function (eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (HALF_PI - phi)) / con;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/phi2z.js

/* harmony default export */ var phi2z = (function (eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);

  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;

    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  } //console.log("phi2z has NoConvergence");


  return -9999;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/merc.js





function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;

  if (!('x0' in this)) {
    this.x0 = 0;
  }

  if (!('y0' in this)) {
    this.y0 = 0;
  }

  this.e = Math.sqrt(this.es);

  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
/* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y; // convert to radians

  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }

  var x, y;

  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  } else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }

    p.x = x;
    p.y = y;
    return p;
  }
}
/* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/

function inverse(p) {
  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;

  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = phi2z(this.e, ts);

    if (lat === -9999) {
      return null;
    }
  }

  lon = adjust_lon(this.long0 + x / (this.a * this.k0));
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
/* harmony default export */ var merc = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/longlat.js
function longlat_init() {//no-op for longlat
}

function identity(pt) {
  return pt;
}



var longlat_names = ["longlat", "identity"];
/* harmony default export */ var longlat = ({
  init: longlat_init,
  forward: identity,
  inverse: identity,
  names: longlat_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections.js


var projs = [merc, longlat];
var projections_names = {};
var projStore = [];

function add(proj, i) {
  var len = projStore.length;

  if (!proj.names) {
    console.log(i);
    return true;
  }

  projStore[len] = proj;
  proj.names.forEach(function (n) {
    projections_names[n.toLowerCase()] = len;
  });
  return this;
}


function get(name) {
  if (!name) {
    return false;
  }

  var n = name.toLowerCase();

  if (typeof projections_names[n] !== 'undefined' && projStore[projections_names[n]]) {
    return projStore[projections_names[n]];
  }
}
function start() {
  projs.forEach(add);
}
/* harmony default export */ var projections = ({
  start: start,
  add: add,
  get: get
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/Ellipsoid.js
var Ellipsoid_exports = {};

Ellipsoid_exports.MERIT = {
  a: 6378137.0,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
Ellipsoid_exports.SGS85 = {
  a: 6378136.0,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
Ellipsoid_exports.GRS80 = {
  a: 6378137.0,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
Ellipsoid_exports.IAU76 = {
  a: 6378140.0,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
Ellipsoid_exports.airy = {
  a: 6377563.396,
  b: 6356256.910,
  ellipseName: "Airy 1830"
};
Ellipsoid_exports.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
Ellipsoid_exports.NWL9D = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
Ellipsoid_exports.mod_airy = {
  a: 6377340.189,
  b: 6356034.446,
  ellipseName: "Modified Airy"
};
Ellipsoid_exports.andrae = {
  a: 6377104.43,
  rf: 300.0,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
Ellipsoid_exports.aust_SA = {
  a: 6378160.0,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
Ellipsoid_exports.GRS67 = {
  a: 6378160.0,
  rf: 298.2471674270,
  ellipseName: "GRS 67(IUGG 1967)"
};
Ellipsoid_exports.bessel = {
  a: 6377397.155,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
Ellipsoid_exports.bess_nam = {
  a: 6377483.865,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
Ellipsoid_exports.clrk66 = {
  a: 6378206.4,
  b: 6356583.8,
  ellipseName: "Clarke 1866"
};
Ellipsoid_exports.clrk80 = {
  a: 6378249.145,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
Ellipsoid_exports.clrk58 = {
  a: 6378293.645208759,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
Ellipsoid_exports.CPM = {
  a: 6375738.7,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
Ellipsoid_exports.delmbr = {
  a: 6376428.0,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
Ellipsoid_exports.engelis = {
  a: 6378136.05,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
Ellipsoid_exports.evrst30 = {
  a: 6377276.345,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
Ellipsoid_exports.evrst48 = {
  a: 6377304.063,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
Ellipsoid_exports.evrst56 = {
  a: 6377301.243,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
Ellipsoid_exports.evrst69 = {
  a: 6377295.664,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
Ellipsoid_exports.evrstSS = {
  a: 6377298.556,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
Ellipsoid_exports.fschr60 = {
  a: 6378166.0,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
Ellipsoid_exports.fschr60m = {
  a: 6378155.0,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
Ellipsoid_exports.fschr68 = {
  a: 6378150.0,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
Ellipsoid_exports.helmert = {
  a: 6378200.0,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
Ellipsoid_exports.hough = {
  a: 6378270.0,
  rf: 297.0,
  ellipseName: "Hough"
};
Ellipsoid_exports.intl = {
  a: 6378388.0,
  rf: 297.0,
  ellipseName: "International 1909 (Hayford)"
};
Ellipsoid_exports.kaula = {
  a: 6378163.0,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
Ellipsoid_exports.lerch = {
  a: 6378139.0,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
Ellipsoid_exports.mprts = {
  a: 6397300.0,
  rf: 191.0,
  ellipseName: "Maupertius 1738"
};
Ellipsoid_exports.new_intl = {
  a: 6378157.5,
  b: 6356772.2,
  ellipseName: "New International 1967"
};
Ellipsoid_exports.plessis = {
  a: 6376523.0,
  rf: 6355863.0,
  ellipseName: "Plessis 1817 (France)"
};
Ellipsoid_exports.krass = {
  a: 6378245.0,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
Ellipsoid_exports.SEasia = {
  a: 6378155.0,
  b: 6356773.3205,
  ellipseName: "Southeast Asia"
};
Ellipsoid_exports.walbeck = {
  a: 6376896.0,
  b: 6355834.8467,
  ellipseName: "Walbeck"
};
Ellipsoid_exports.WGS60 = {
  a: 6378165.0,
  rf: 298.3,
  ellipseName: "WGS 60"
};
Ellipsoid_exports.WGS66 = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "WGS 66"
};
Ellipsoid_exports.WGS7 = {
  a: 6378135.0,
  rf: 298.26,
  ellipseName: "WGS 72"
};
var WGS84 = Ellipsoid_exports.WGS84 = {
  a: 6378137.0,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
Ellipsoid_exports.sphere = {
  a: 6370997.0,
  b: 6370997.0,
  ellipseName: "Normal Sphere (r=6370997)"
};
// CONCATENATED MODULE: ./node_modules/proj4/lib/deriveConstants.js



function eccentricity(a, b, rf, R_A) {
  var a2 = a * a; // used in geocentric

  var b2 = b * b; // used in geocentric

  var es = (a2 - b2) / a2; // e ^ 2

  var e = 0;

  if (R_A) {
    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es); // eccentricity
  }

  var ep2 = (a2 - b2) / b2; // used in geocentric

  return {
    es: es,
    e: e,
    ep2: ep2
  };
}
function deriveConstants_sphere(a, b, rf, ellps, sphere) {
  if (!a) {
    // do we have an ellipsoid?
    var ellipse = match(Ellipsoid_exports, ellps);

    if (!ellipse) {
      ellipse = WGS84;
    }

    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }

  if (rf && !b) {
    b = (1.0 - 1.0 / rf) * a;
  }

  if (rf === 0 || Math.abs(a - b) < EPSLN) {
    sphere = true;
    b = a;
  }

  return {
    a: a,
    b: b,
    rf: rf,
    sphere: sphere
  };
}
// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/Datum.js
var Datum_exports = {};

Datum_exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
Datum_exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
Datum_exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
Datum_exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
Datum_exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
Datum_exports.potsdam = {
  towgs84: "606.0,23.0,413.0",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
Datum_exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
Datum_exports.hermannskogel = {
  towgs84: "653.0,-212.0,449.0",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
Datum_exports.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};
Datum_exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
Datum_exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
Datum_exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
Datum_exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
Datum_exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: 'bessel',
  datumName: 'S-JTSK (Ferro)'
};
Datum_exports.beduaram = {
  towgs84: '-106,-87,188',
  ellipse: 'clrk80',
  datumName: 'Beduaram'
};
Datum_exports.gunung_segara = {
  towgs84: '-403,684,41',
  ellipse: 'bessel',
  datumName: 'Gunung Segara Jakarta'
};
Datum_exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};
// CONCATENATED MODULE: ./node_modules/proj4/lib/datum.js


function datum(datumCode, datum_params, a, b, es, ep2) {
  var out = {};

  if (datumCode === undefined || datumCode === 'none') {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }

  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);

    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }

    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = out.datum_params[6] / 1000000.0 + 1.0;
      }
    }
  }

  out.a = a; //datum object also uses these values

  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}

/* harmony default export */ var lib_datum = (datum);
// CONCATENATED MODULE: ./node_modules/proj4/lib/Proj.js
function Proj_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Proj_typeof = function _typeof(obj) { return typeof obj; }; } else { Proj_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Proj_typeof(obj); }









function Projection(srsCode, callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }

  callback = callback || function (error) {
    if (error) {
      throw error;
    }
  };

  var json = parseCode(srsCode);

  if (Proj_typeof(json) !== 'object') {
    callback(srsCode);
    return;
  }

  var ourProj = Projection.projections.get(json.projName);

  if (!ourProj) {
    callback(srsCode);
    return;
  }

  if (json.datumCode && json.datumCode !== 'none') {
    var datumDef = match(Datum_exports, json.datumCode);

    if (datumDef) {
      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }

  json.k0 = json.k0 || 1.0;
  json.axis = json.axis || 'enu';
  json.ellps = json.ellps || 'wgs84';
  var sphere_ = deriveConstants_sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var datumObj = json.datum || lib_datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);
  extend(this, json); // transfer everything over from the projection because we don't know what we'll need

  extend(this, ourProj); // transfer all the methods from the projection
  // copy the 4 things over we calulated in deriveConstants.sphere

  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere; // copy the 3 things we calculated in deriveConstants.eccentricity

  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2; // add in the datum object

  this.datum = datumObj; // init the projection

  this.init(); // legecy callback from back in the day when it went to spatialreference.org

  callback(null, this);
}

Projection.projections = projections;
Projection.projections.start();
/* harmony default export */ var Proj = (Projection);
// CONCATENATED MODULE: ./node_modules/proj4/lib/datumUtils.js



function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false; // false, datums are not equal
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
    // the tolerance for es is to ensure that GRS80 and WGS84
    // are considered identical
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
  } else if (source.datum_type === PJD_7PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
  } else {
    return true; // datums are equal
  }
} // cs_compare_datums()

/*
 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
 * according to the current ellipsoid parameters.
 *
 *    Latitude  : Geodetic latitude in radians                     (input)
 *    Longitude : Geodetic longitude in radians                    (input)
 *    Height    : Geodetic height, in meters                       (input)
 *    X         : Calculated Geocentric X coordinate, in meters    (output)
 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
 *
 */

function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0; //Z value not always supplied

  var Rn;
  /*  Earth radius at location  */

  var Sin_Lat;
  /*  Math.sin(Latitude)  */

  var Sin2_Lat;
  /*  Square of Math.sin(Latitude)  */

  var Cos_Lat;
  /*  Math.cos(Latitude)  */

  /*
   ** Don't blow up if Latitude is just a little out of the value
   ** range as it may just be a rounding issue.  Also removed longitude
   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
   */

  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    /* Latitude out of range */
    //..reportError('geocent:lat out of range:' + Latitude);
    return {
      x: -Infinity,
      y: -Infinity,
      z: p.z
    };
  } else if (Latitude > HALF_PI) {
    /* Latitude out of range */
    return {
      x: Infinity,
      y: Infinity,
      z: p.z
    };
  }

  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }

  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / Math.sqrt(1.0e0 - es * Sin2_Lat);
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn * (1 - es) + Height) * Sin_Lat
  };
} // cs_geodetic_to_geocentric()

function geocentricToGeodetic(p, es, a, b) {
  /* local defintions and variables */

  /* end-criterium of loop, accuracy of sin(Latitude) */
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P;
  /* distance between semi-minor axis and location */

  var RR;
  /* distance between center and location */

  var CT;
  /* sin of geocentric latitude */

  var ST;
  /* cos of geocentric latitude */

  var RX;
  var RK;
  var RN;
  /* Earth radius at location */

  var CPHI0;
  /* cos of start or old geodetic latitude in iterations */

  var SPHI0;
  /* sin of start or old geodetic latitude in iterations */

  var CPHI;
  /* cos of searched geodetic latitude */

  var SPHI;
  /* sin of searched geodetic latitude */

  var SDPHI;
  /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */

  var iter;
  /* # of continous iteration, max. 30 is always enough (s.a.) */

  var X = p.x;
  var Y = p.y;
  var Z = p.z ? p.z : 0.0; //Z value not always supplied

  var Longitude;
  var Latitude;
  var Height;
  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z * Z);
  /*      special cases for latitude and longitude */

  if (P / a < genau) {
    /*  special case, if P=0. (X=0., Y=0.) */
    Longitude = 0.0;
    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */

    if (RR / a < genau) {
      Latitude = HALF_PI;
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    /*  ellipsoidal (geodetic) longitude
     *  interval: -PI < Longitude <= +PI */
    Longitude = Math.atan2(Y, X);
  }
  /* --------------------------------------------------------------
   * Following iterative algorithm was developped by
   * "Institut for Erdmessung", University of Hannover, July 1988.
   * Internet: www.ife.uni-hannover.de
   * Iterative computation of CPHI,SPHI and Height.
   * Iteration of CPHI and SPHI to 10**-12 radian resp.
   * 2*10**-7 arcsec.
   * --------------------------------------------------------------
   */


  CT = Z / RR;
  ST = P / RR;
  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
  CPHI0 = ST * (1.0 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  /* loop to find sin(Latitude) resp. Latitude
   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */

  do {
    iter++;
    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);
    /*  ellipsoidal (geodetic) height */

    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
    CPHI = ST * (1.0 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  /*      ellipsoidal (geodetic) latitude */


  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
} // cs_geocentric_to_geodetic()

/****************************************************************/
// pj_geocentic_to_wgs84( p )
//  p = point to transform in geocentric coordinates (x,y,z)

/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/

function geocentricToWgs84(p, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6]; // if( x[io] === HUGE_VAL )
    //    continue;

    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
} // cs_geocentric_to_wgs84

/****************************************************************/
// pj_geocentic_from_wgs84()
//  coordinate system definition,
//  point to transform in geocentric coordinates (x,y,z)

function geocentricFromWgs84(p, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    //if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF; //if( x[io] === HUGE_VAL )
    //    continue;

    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  } //cs_geocentric_from_wgs84()

}
// CONCATENATED MODULE: ./node_modules/proj4/lib/datum_transform.js



function checkParams(type) {
  return type === PJD_3PARAM || type === PJD_7PARAM;
}

/* harmony default export */ var datum_transform = (function (source, dest, point) {
  // Short cut if the datums are identical.
  if (compareDatums(source, dest)) {
    return point; // in this case, zero is sucess,
    // whereas cs_compare_datums returns 1 to indicate TRUE
    // confusing, should fix this
  } // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest


  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  } // If this datum requires grid shifts, then apply it to geodetic coordinates.
  // Do we need to go through geocentric coordinates?


  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
    return point;
  } // Convert to geocentric coordinates.


  point = geodeticToGeocentric(point, source.es, source.a); // Convert between datums

  if (checkParams(source.datum_type)) {
    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
  }

  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }

  return geocentricToGeodetic(point, dest.es, dest.a, dest.b);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/adjust_axis.js
/* harmony default export */ var adjust_axis = (function (crs, denorm, point) {
  var xin = point.x,
      yin = point.y,
      zin = point.z || 0.0;
  var v, t, i;
  var out = {};

  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === undefined) {
      continue;
    }

    if (i === 0) {
      v = xin;

      if ("ew".indexOf(crs.axis[i]) !== -1) {
        t = 'x';
      } else {
        t = 'y';
      }
    } else if (i === 1) {
      v = yin;

      if ("ns".indexOf(crs.axis[i]) !== -1) {
        t = 'y';
      } else {
        t = 'x';
      }
    } else {
      v = zin;
      t = 'z';
    }

    switch (crs.axis[i]) {
      case 'e':
        out[t] = v;
        break;

      case 'w':
        out[t] = -v;
        break;

      case 'n':
        out[t] = v;
        break;

      case 's':
        out[t] = -v;
        break;

      case 'u':
        if (point[t] !== undefined) {
          out.z = v;
        }

        break;

      case 'd':
        if (point[t] !== undefined) {
          out.z = -v;
        }

        break;

      default:
        //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
        return null;
    }
  }

  return out;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/toPoint.js
/* harmony default export */ var toPoint = (function (array) {
  var out = {
    x: array[0],
    y: array[1]
  };

  if (array.length > 2) {
    out.z = array[2];
  }

  if (array.length > 3) {
    out.m = array[3];
  }

  return out;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/checkSanity.js
/* harmony default export */ var checkSanity = (function (point) {
  checkCoord(point.x);
  checkCoord(point.y);
});

function checkCoord(num) {
  if (typeof Number.isFinite === 'function') {
    if (Number.isFinite(num)) {
      return;
    }

    throw new TypeError('coordinates must be finite numbers');
  }

  if (typeof num !== 'number' || num !== num || !isFinite(num)) {
    throw new TypeError('coordinates must be finite numbers');
  }
}
// CONCATENATED MODULE: ./node_modules/proj4/lib/transform.js







function checkNotWGS(source, dest) {
  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84' || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84';
}

function transform(source, dest, point) {
  var wgs84;

  if (Array.isArray(point)) {
    point = toPoint(point);
  }

  checkSanity(point); // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84

  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs84 = new Proj('WGS84');
    point = transform(source, wgs84, point);
    source = wgs84;
  } // DGR, 2010/11/12


  if (source.axis !== 'enu') {
    point = adjust_axis(source, false, point);
  } // Transform source points to long/lat, if they aren't already.


  if (source.projName === 'longlat') {
    point = {
      x: point.x * D2R,
      y: point.y * D2R,
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }

    point = source.inverse(point); // Convert Cartesian to longlat

    if (!point) {
      return;
    }
  } // Adjust for the prime meridian if necessary


  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  } // Convert datums if needed, and if possible.


  point = datum_transform(source.datum, dest.datum, point); // Adjust for the prime meridian if necessary

  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }

  if (dest.projName === 'longlat') {
    // convert radians to decimal degrees
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else {
    // else project
    point = dest.forward(point);

    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  } // DGR, 2010/11/12


  if (dest.axis !== 'enu') {
    return adjust_axis(dest, true, point);
  }

  return point;
}
// CONCATENATED MODULE: ./node_modules/proj4/lib/core.js


var core_wgs84 = Proj('WGS84');

function transformer(from, to, coords) {
  var transformedArray, out, keys;

  if (Array.isArray(coords)) {
    transformedArray = transform(from, to, coords) || {
      x: NaN,
      y: NaN
    };

    if (coords.length > 2) {
      if (typeof from.name !== 'undefined' && from.name === 'geocent' || typeof to.name !== 'undefined' && to.name === 'geocent') {
        if (typeof transformedArray.z === 'number') {
          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
        } else {
          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
        }
      } else {
        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
      }
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = transform(from, to, coords);
    keys = Object.keys(coords);

    if (keys.length === 2) {
      return out;
    }

    keys.forEach(function (key) {
      if (typeof from.name !== 'undefined' && from.name === 'geocent' || typeof to.name !== 'undefined' && to.name === 'geocent') {
        if (key === 'x' || key === 'y' || key === 'z') {
          return;
        }
      } else {
        if (key === 'x' || key === 'y') {
          return;
        }
      }

      out[key] = coords[key];
    });
    return out;
  }
}

function checkProj(item) {
  if (item instanceof Proj) {
    return item;
  }

  if (item.oProj) {
    return item.oProj;
  }

  return Proj(item);
}

function core_proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;

  if (typeof toProj === 'undefined') {
    toProj = fromProj;
    fromProj = core_wgs84;
    single = true;
  } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = core_wgs84;
    single = true;
  }

  toProj = checkProj(toProj);

  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      forward: function forward(coords) {
        return transformer(fromProj, toProj, coords);
      },
      inverse: function inverse(coords) {
        return transformer(toProj, fromProj, coords);
      }
    };

    if (single) {
      obj.oProj = toProj;
    }

    return obj;
  }
}

/* harmony default export */ var core = (core_proj4);
// CONCATENATED MODULE: ./node_modules/mgrs/mgrs.js
/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */
var NUM_100K_SETS = 6;
/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */

var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';
/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */

var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';
var mgrs_A = 65; // A

var I = 73; // I

var O = 79; // O

var mgrs_V = 86; // V

var mgrs_Z = 90; // Z

/* harmony default export */ var mgrs = ({
  forward: mgrs_forward,
  inverse: mgrs_inverse,
  toPoint: mgrs_toPoint
});
/**
 * Conversion of lat/lon to MGRS.
 *
 * @param {object} ll Object literal with lat and lon properties on a
 *     WGS84 ellipsoid.
 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
 * @return {string} the MGRS string for the given location and accuracy.
 */

function mgrs_forward(ll, accuracy) {
  accuracy = accuracy || 5; // default accuracy 1m

  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
}
;
/**
 * Conversion of MGRS to lat/lon.
 *
 * @param {string} mgrs MGRS string.
 * @return {array} An array with left (longitude), bottom (latitude), right
 *     (longitude) and top (latitude) values in WGS84, representing the
 *     bounding box for the provided MGRS reference.
 */

function mgrs_inverse(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));

  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }

  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
}
;
function mgrs_toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));

  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }

  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
}
;
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */

function degToRad(deg) {
  return deg * (Math.PI / 180.0);
}
/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */


function radToDeg(rad) {
  return 180.0 * (rad / Math.PI);
}
/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */


function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137.0; //ellip.radius;

  var eccSquared = 0.00669438; //ellip.eccsq;

  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber; // (int)

  ZoneNumber = Math.floor((Long + 180) / 6) + 1; //Make sure the longitude 180.00 is in Zone 60

  if (Long === 180) {
    ZoneNumber = 60;
  } // Special zone for Norway


  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
    ZoneNumber = 32;
  } // Special zones for Svalbard


  if (Lat >= 72.0 && Lat < 84.0) {
    if (Long >= 0.0 && Long < 9.0) {
      ZoneNumber = 31;
    } else if (Long >= 9.0 && Long < 21.0) {
      ZoneNumber = 33;
    } else if (Long >= 21.0 && Long < 33.0) {
      ZoneNumber = 35;
    } else if (Long >= 33.0 && Long < 42.0) {
      ZoneNumber = 37;
    }
  }

  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
  // in middle of
  // zone

  LongOriginRad = degToRad(LongOrigin);
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A = Math.cos(LatRad) * (LongRad - LongOriginRad);
  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
  var UTMEasting = k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0;
  var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0));

  if (Lat < 0.0) {
    UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
  }

  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}
/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */


function UTMtoLL(utm) {
  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber; // check the ZoneNummber is valid

  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }

  var k0 = 0.9996;
  var a = 6378137.0; //ellip.radius;

  var eccSquared = 0.00669438; //ellip.eccsq;

  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C1, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad; // remove 500,000 meter offset for longitude

  var x = UTMEasting - 500000.0;
  var y = UTMNorthing; // We must know somehow if we are in the Northern or Southern
  // hemisphere, this is the only time we use the letter So even
  // if the Zone letter isn't exactly correct it should indicate
  // the hemisphere correctly

  if (zoneLetter < 'N') {
    y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
  } // There are 60 zones with zone 1 being at West -180 to -174


  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
  // in middle of
  // zone

  eccPrimeSquared = eccSquared / (1 - eccSquared);
  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu); // double phi1 = ProjMath.radToDeg(phi1Rad);

  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);
  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);
  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);
  var result;

  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result = {
      lat: lat,
      lon: lon
    };
  }

  return result;
}
/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */


function getLetterDesignator(lat) {
  //This is here as an error flag to show that the Latitude is
  //outside MGRS limits
  var LetterDesignator = 'Z';

  if (84 >= lat && lat >= 72) {
    LetterDesignator = 'X';
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = 'W';
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = 'V';
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = 'U';
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = 'T';
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = 'S';
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = 'R';
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = 'Q';
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = 'P';
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = 'N';
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = 'M';
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = 'L';
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = 'K';
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = 'J';
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = 'H';
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = 'G';
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = 'F';
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = 'E';
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = 'D';
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = 'C';
  }

  return LetterDesignator;
}
/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */


function encode(utm, accuracy) {
  // prepend with leading zeroes
  var seasting = "00000" + utm.easting,
      snorthing = "00000" + utm.northing;
  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */


function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 100000);
  var setRow = Math.floor(northing / 100000) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}
/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */


function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;

  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }

  return setParm;
}
/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */


function getLetter100kID(column, row, parm) {
  // colOrigin and rowOrigin are the letters at the origin of the set
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index); // colInt and rowInt are the letters to build to return

  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;

  if (colInt > mgrs_Z) {
    colInt = colInt - mgrs_Z + mgrs_A - 1;
    rollover = true;
  }

  if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
    colInt++;
  }

  if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
    colInt++;

    if (colInt === I) {
      colInt++;
    }
  }

  if (colInt > mgrs_Z) {
    colInt = colInt - mgrs_Z + mgrs_A - 1;
  }

  if (rowInt > mgrs_V) {
    rowInt = rowInt - mgrs_V + mgrs_A - 1;
    rollover = true;
  } else {
    rollover = false;
  }

  if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
    rowInt++;
  }

  if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
    rowInt++;

    if (rowInt === I) {
      rowInt++;
    }
  }

  if (rowInt > mgrs_V) {
    rowInt = rowInt - mgrs_V + mgrs_A - 1;
  }

  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}
/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */


function decode(mgrsString) {
  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }

  var length = mgrsString.length;
  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0; // get Zone number

  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }

    sb += testChar;
    i++;
  }

  var zoneNumber = parseInt(sb, 10);

  if (i === 0 || i + 3 > length) {
    // A good MGRS string has to be 4-5 digits long,
    // ##AAA/#AAA at least.
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }

  var zoneLetter = mgrsString.charAt(i++); // Should we check the zone letter here? Why not.

  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }

  hunK = mgrsString.substring(i, i += 2);
  var set = get100kSetForZone(zoneNumber);
  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set); // We have a bug where the northing may be 2000000 too low.
  // How
  // do we know when to roll over?

  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2000000;
  } // calculate the char index for easting/northing separator


  var remainder = length - i;

  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }

  var sep = remainder / 2;
  var sepEasting = 0.0;
  var sepNorthing = 0.0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;

  if (sep > 0) {
    accuracyBonus = 100000.0 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }

  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;
  return {
    easting: easting,
    northing: northing,
    zoneLetter: zoneLetter,
    zoneNumber: zoneNumber,
    accuracy: accuracyBonus
  };
}
/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100´k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */


function getEastingFromChar(e, set) {
  // colOrigin is the letter at the origin of the set for the
  // column
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 100000.0;
  var rewindMarker = false;

  while (curCol !== e.charCodeAt(0)) {
    curCol++;

    if (curCol === I) {
      curCol++;
    }

    if (curCol === O) {
      curCol++;
    }

    if (curCol > mgrs_Z) {
      if (rewindMarker) {
        throw "Bad character: " + e;
      }

      curCol = mgrs_A;
      rewindMarker = true;
    }

    eastingValue += 100000.0;
  }

  return eastingValue;
}
/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */


function getNorthingFromChar(n, set) {
  if (n > 'V') {
    throw "MGRSPoint given invalid Northing " + n;
  } // rowOrigin is the letter at the origin of the set for the
  // column


  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0.0;
  var rewindMarker = false;

  while (curRow !== n.charCodeAt(0)) {
    curRow++;

    if (curRow === I) {
      curRow++;
    }

    if (curRow === O) {
      curRow++;
    } // fixing a bug making whole application hang in this loop
    // when 'n' is a wrong character


    if (curRow > mgrs_V) {
      if (rewindMarker) {
        // making sure that this loop ends
        throw "Bad character: " + n;
      }

      curRow = mgrs_A;
      rewindMarker = true;
    }

    northingValue += 100000.0;
  }

  return northingValue;
}
/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */


function getMinNorthing(zoneLetter) {
  var northing;

  switch (zoneLetter) {
    case 'C':
      northing = 1100000.0;
      break;

    case 'D':
      northing = 2000000.0;
      break;

    case 'E':
      northing = 2800000.0;
      break;

    case 'F':
      northing = 3700000.0;
      break;

    case 'G':
      northing = 4600000.0;
      break;

    case 'H':
      northing = 5500000.0;
      break;

    case 'J':
      northing = 6400000.0;
      break;

    case 'K':
      northing = 7300000.0;
      break;

    case 'L':
      northing = 8200000.0;
      break;

    case 'M':
      northing = 9100000.0;
      break;

    case 'N':
      northing = 0.0;
      break;

    case 'P':
      northing = 800000.0;
      break;

    case 'Q':
      northing = 1700000.0;
      break;

    case 'R':
      northing = 2600000.0;
      break;

    case 'S':
      northing = 3500000.0;
      break;

    case 'T':
      northing = 4400000.0;
      break;

    case 'U':
      northing = 5300000.0;
      break;

    case 'V':
      northing = 6200000.0;
      break;

    case 'W':
      northing = 7000000.0;
      break;

    case 'X':
      northing = 7900000.0;
      break;

    default:
      northing = -1.0;
  }

  if (northing >= 0.0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}
// CONCATENATED MODULE: ./node_modules/proj4/lib/Point.js
function Point_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Point_typeof = function _typeof(obj) { return typeof obj; }; } else { Point_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Point_typeof(obj); }



function Point(x, y, z) {
  if (!(this instanceof Point)) {
    return new Point(x, y, z);
  }

  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0.0;
  } else if (Point_typeof(x) === 'object') {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0.0;
  } else if (typeof x === 'string' && typeof y === 'undefined') {
    var coords = x.split(',');
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0.0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0.0;
  }

  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
}

Point.fromMGRS = function (mgrsStr) {
  return new Point(mgrs_toPoint(mgrsStr));
};

Point.prototype.toMGRS = function (accuracy) {
  return mgrs_forward([this.x, this.y], accuracy);
};

/* harmony default export */ var lib_Point = (Point);
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_enfn.js
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.01302083333333333333;
var C48 = 0.00712076822916666666;
var C66 = 0.36458333333333333333;
var C68 = 0.00569661458333333333;
var C88 = 0.3076171875;
/* harmony default export */ var pj_enfn = (function (es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_mlfn.js
/* harmony default export */ var pj_mlfn = (function (phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_inv_mlfn.js


var MAX_ITER = 20;
/* harmony default export */ var pj_inv_mlfn = (function (arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;

  for (var i = MAX_ITER; i; --i) {
    /* rarely goes over 2 iterations */
    var s = Math.sin(phi);
    var t = 1 - es * s * s; //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
    //phi -= t * (t * Math.sqrt(t)) * k;

    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;

    if (Math.abs(t) < EPSLN) {
      return phi;
    }
  } //..reportError("cass:pj_inv_mlfn: Convergence error");


  return phi;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/tmerc.js
// Heavily based on this tmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js






function tmerc_init() {
  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  if (this.es) {
    this.en = pj_enfn(this.es);
    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}
/**
    Transverse Mercator Forward  - long/lat to x/y
    long/lat in radians
  */

function tmerc_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);

  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);

    if (Math.abs(Math.abs(b) - 1) < EPSLN) {
      return 93;
    } else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);

      if (b >= 1) {
        if (b - 1 > EPSLN) {
          return 93;
        } else {
          y = 0;
        }
      } else {
        y = Math.acos(y);
      }

      if (lat < 0) {
        y = -y;
      }

      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);
    x = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
    y = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
  }

  p.x = x;
  p.y = y;
  return p;
}
/**
    Transverse Mercator Inverse  -  x/y to long/lat
  */

function tmerc_inverse(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);

  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);

    if (y < 0) {
      lat = -lat;
    }

    if (g === 0 && h === 0) {
      lon = 0;
    } else {
      lon = adjust_lon(Math.atan2(g, h) + this.long0);
    }
  } else {
    // ellipsoidal form
    con = this.ml0 + y / this.k0;
    phi = pj_inv_mlfn(con, this.es, this.en);

    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
      lon = adjust_lon(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
    } else {
      lat = HALF_PI * sign(y);
      lon = 0;
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var tmerc_names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];
/* harmony default export */ var tmerc = ({
  init: tmerc_init,
  forward: tmerc_forward,
  inverse: tmerc_inverse,
  names: tmerc_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/sinh.js
/* harmony default export */ var sinh = (function (x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/hypot.js
/* harmony default export */ var hypot = (function (x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);
  return a * Math.sqrt(1 + Math.pow(b, 2));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/log1py.js
/* harmony default export */ var log1py = (function (x) {
  var y = 1 + x;
  var z = y - 1;
  return z === 0 ? x : x * Math.log(y) / z;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/asinhy.js


/* harmony default export */ var asinhy = (function (x) {
  var y = Math.abs(x);
  y = log1py(y * (1 + y / (hypot(1, y) + 1)));
  return x < 0 ? -y : y;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/gatg.js
/* harmony default export */ var gatg = (function (pp, B) {
  var cos_2B = 2 * Math.cos(2 * B);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;

  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }

  return B + h * Math.sin(2 * B);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/clens.js
/* harmony default export */ var clens = (function (pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;

  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }

  return Math.sin(arg_r) * hr;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/cosh.js
/* harmony default export */ var cosh = (function (x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/clens_cmplx.js


/* harmony default export */ var clens_cmplx = (function (pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh(arg_i);
  var cosh_arg_i = cosh(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;

  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }

  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;
  return [r * hr - i * hi, r * hi + i * hr];
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/etmerc.js
// Heavily based on this etmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js







function etmerc_init() {
  if (this.es === undefined || this.es <= 0) {
    throw new Error('incorrect elliptical usage');
  }

  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;
  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
  this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z = gatg(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
}
function etmerc_forward(p) {
  var Ce = adjust_lon(p.x - this.long0);
  var Cn = p.y;
  Cn = gatg(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);
  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
  Ce = asinhy(Math.tan(Ce));
  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];
  var x;
  var y;

  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  } else {
    x = Infinity;
    y = Infinity;
  }

  p.x = x;
  p.y = y;
  return p;
}
function etmerc_inverse(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);
  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;
  var lon;
  var lat;

  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(sinh(Ce));
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);
    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = adjust_lon(Ce + this.long0);
    lat = gatg(this.cgb, Cn);
  } else {
    lon = Infinity;
    lat = Infinity;
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var etmerc_names = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc"];
/* harmony default export */ var etmerc = ({
  init: etmerc_init,
  forward: etmerc_forward,
  inverse: etmerc_inverse,
  names: etmerc_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_zone.js

/* harmony default export */ var adjust_zone = (function (zone, lon) {
  if (zone === undefined) {
    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }

  return zone;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/utm.js


var dependsOn = 'etmerc';

function utm_init() {
  var zone = adjust_zone(this.zone, this.long0);

  if (zone === undefined) {
    throw new Error('unknown utm zone');
  }

  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * D2R;
  this.x0 = 500000;
  this.y0 = this.utmSouth ? 10000000 : 0;
  this.k0 = 0.9996;
  etmerc.init.apply(this);
  this.forward = etmerc.forward;
  this.inverse = etmerc.inverse;
}
var utm_names = ["Universal Transverse Mercator System", "utm"];
/* harmony default export */ var utm = ({
  init: utm_init,
  names: utm_names,
  dependsOn: dependsOn
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/srat.js
/* harmony default export */ var srat = (function (esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/gauss.js

var gauss_MAX_ITER = 20;

function gauss_init() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
}
function gauss_forward(p) {
  var lon = p.x;
  var lat = p.y;
  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p.x = this.C * lon;
  return p;
}
function gauss_inverse(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);

  for (var i = gauss_MAX_ITER; i > 0; --i) {
    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;

    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }

    p.y = lat;
  }
  /* convergence failed */


  if (!i) {
    return null;
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var gauss_names = ["gauss"];
/* harmony default export */ var gauss = ({
  init: gauss_init,
  forward: gauss_forward,
  inverse: gauss_inverse,
  names: gauss_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/sterea.js


function sterea_init() {
  gauss.init.apply(this);

  if (!this.rc) {
    return;
  }

  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;

  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}
function sterea_forward(p) {
  var sinc, cosc, cosl, k;
  p.x = adjust_lon(p.x - this.long0);
  gauss.forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}
function sterea_inverse(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;

  if (rho = Math.sqrt(p.x * p.x + p.y * p.y)) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  gauss.inverse.apply(this, [p]);
  p.x = adjust_lon(p.x + this.long0);
  return p;
}
var sterea_names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
/* harmony default export */ var sterea = ({
  init: sterea_init,
  forward: sterea_forward,
  inverse: sterea_inverse,
  names: sterea_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/stere.js






function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}
function stere_init() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);

  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        //North pole
        //trace('stere:north pole');
        this.con = 1;
      } else {
        //South pole
        //trace('stere:south pole');
        this.con = -1;
      }
    }

    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));

    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }

    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
} // Stereographic forward equations--mapping lat,long to x,y

function stere_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A, X, sinX, cosX, ts, rh;
  var dlon = adjust_lon(lon - this.long0);

  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    //case of the origine point
    //trace('stere:this is the origin point');
    p.x = NaN;
    p.y = NaN;
    return p;
  }

  if (this.sphere) {
    //trace('stere:sphere case');
    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  } else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X);
    sinX = Math.sin(X);

    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0); //trace(p.toString());

      return p;
    } else if (Math.abs(this.sinlat0) < EPSLN) {
      //Eq
      //trace('stere:equateur');
      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A * sinX;
    } else {
      //other case
      //trace('stere:normal case');
      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }

    p.x = A * cosX * Math.sin(dlon) + this.x0;
  } //trace(p.toString());


  return p;
} //* Stereographic inverse equations--mapping x,y to lat/long

function stere_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);

  if (this.sphere) {
    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;

    if (rh <= EPSLN) {
      p.x = lon;
      p.y = lat;
      return p;
    }

    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);

    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
      } else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      }
    } else {
      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }

    p.x = lon;
    p.y = lat;
    return p;
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat; //trace(p.toString());

        return p;
      }

      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z(this.e, ts);
      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
    } else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;

      if (rh <= EPSLN) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }

      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }

  p.x = lon;
  p.y = lat; //trace(p.toString());

  return p;
}
var stere_names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
/* harmony default export */ var stere = ({
  init: stere_init,
  forward: stere_forward,
  inverse: stere_inverse,
  names: stere_names,
  ssfn_: ssfn_
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/somerc.js
/*
  references:
    Formules et constantes pour le Calcul pour la
    projection cylindrique conforme à axe oblique et pour la transformation entre
    des systèmes de référence.
    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
  */
function somerc_init() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}
function somerc_forward(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K; // spheric latitude

  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4); // spheric longitude

  var I = this.alpha * (p.x - this.lambda0); // psoeudo equatorial rotation

  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));
  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}
function somerc_inverse(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;
  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I / this.alpha;
  var S = 0;
  var phy = b;
  var prevPhy = -1000;
  var iteration = 0;

  while (Math.abs(phy - prevPhy) > 0.0000001) {
    if (++iteration > 20) {
      //...reportError("omercFwdInfinity");
      return;
    } //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));


    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }

  p.x = lambda;
  p.y = phy;
  return p;
}
var somerc_names = ["somerc"];
/* harmony default export */ var somerc = ({
  init: somerc_init,
  forward: somerc_forward,
  inverse: somerc_inverse,
  names: somerc_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/omerc.js




/* Initialize the Oblique Mercator  projection
    ------------------------------------------*/

function omerc_init() {
  this.no_off = this.no_off || false;
  this.no_rot = this.no_rot || false;

  if (isNaN(this.k0)) {
    this.k0 = 1;
  }

  var sinlat = Math.sin(this.lat0);
  var coslat = Math.cos(this.lat0);
  var con = this.e * sinlat;
  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
  var t0 = tsfnz(this.e, this.lat0, sinlat);
  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));

  if (dl * dl < 1) {
    dl = 1;
  }

  var fl;
  var gl;

  if (!isNaN(this.longc)) {
    //Central point and azimuth method
    if (this.lat0 >= 0) {
      fl = dl + Math.sqrt(dl * dl - 1);
    } else {
      fl = dl - Math.sqrt(dl * dl - 1);
    }

    this.el = fl * Math.pow(t0, this.bl);
    gl = 0.5 * (fl - 1 / fl);
    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;
  } else {
    //2 points method
    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));

    if (this.lat0 >= 0) {
      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    } else {
      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }

    var hl = Math.pow(t1, this.bl);
    var ll = Math.pow(t2, this.bl);
    fl = this.el / hl;
    gl = 0.5 * (fl - 1 / fl);
    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
    var pl = (ll - hl) / (ll + hl);
    var dlon12 = adjust_lon(this.long1 - this.long2);
    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * dlon12) / pl) / this.bl;
    this.long0 = adjust_lon(this.long0);
    var dlon10 = adjust_lon(this.long1 - this.long0);
    this.gamma0 = Math.atan(Math.sin(this.bl * dlon10) / gl);
    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
  }

  if (this.no_off) {
    this.uc = 0;
  } else {
    if (this.lat0 >= 0) {
      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    } else {
      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
  }
}
/* Oblique Mercator forward equations--mapping lat,long to x,y
    ----------------------------------------------------------*/

function omerc_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon(lon - this.long0);
  var us, vs;
  var con;

  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    if (lat > 0) {
      con = -1;
    } else {
      con = 1;
    }

    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
    us = -1 * con * HALF_PI * this.al / this.bl;
  } else {
    var t = tsfnz(this.e, lat, Math.sin(lat));
    var ql = this.el / Math.pow(t, this.bl);
    var sl = 0.5 * (ql - 1 / ql);
    var tl = 0.5 * (ql + 1 / ql);
    var vl = Math.sin(this.bl * dlon);
    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;

    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
      vs = Number.POSITIVE_INFINITY;
    } else {
      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
    }

    if (Math.abs(Math.cos(this.bl * dlon)) <= EPSLN) {
      us = this.al * this.bl * dlon;
    } else {
      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
    }
  }

  if (this.no_rot) {
    p.x = this.x0 + us;
    p.y = this.y0 + vs;
  } else {
    us -= this.uc;
    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
  }

  return p;
}
function omerc_inverse(p) {
  var us, vs;

  if (this.no_rot) {
    vs = p.y - this.y0;
    us = p.x - this.x0;
  } else {
    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
    us += this.uc;
  }

  var qp = Math.exp(-1 * this.bl * vs / this.al);
  var sp = 0.5 * (qp - 1 / qp);
  var tp = 0.5 * (qp + 1 / qp);
  var vp = Math.sin(this.bl * us / this.al);
  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);

  if (Math.abs(up - 1) < EPSLN) {
    p.x = this.long0;
    p.y = HALF_PI;
  } else if (Math.abs(up + 1) < EPSLN) {
    p.x = this.long0;
    p.y = -1 * HALF_PI;
  } else {
    p.y = phi2z(this.e, ts);
    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
  }

  return p;
}
var omerc_names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
/* harmony default export */ var omerc = ({
  init: omerc_init,
  forward: omerc_forward,
  inverse: omerc_inverse,
  names: omerc_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/lcc.js






function lcc_init() {
  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
  //double c_lat;                   /* center latitude                      */
  //double c_lon;                   /* center longitude                     */
  //double lat1;                    /* first standard parallel              */
  //double lat2;                    /* second standard parallel             */
  //double r_maj;                   /* major axis                           */
  //double r_min;                   /* minor axis                           */
  //double false_east;              /* x offset in meters                   */
  //double false_north;             /* y offset in meters                   */
  if (!this.lat2) {
    this.lat2 = this.lat1;
  } //if lat2 is not defined


  if (!this.k0) {
    this.k0 = 1;
  }

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0; // Standard Parallels cannot be equal and on opposite sides of the equator

  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }

  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz(this.e, sin1, cos1);
  var ts1 = tsfnz(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz(this.e, sin2, cos2);
  var ts2 = tsfnz(this.e, this.lat2, sin2);
  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }

  if (isNaN(this.ns)) {
    this.ns = sin1;
  }

  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);

  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
} // Lambert Conformal conic forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------

function lcc_forward(p) {
  var lon = p.x;
  var lat = p.y; // singular cases :

  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
  }

  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;

  if (con > EPSLN) {
    ts = tsfnz(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  } else {
    con = lat * this.ns;

    if (con <= 0) {
      return null;
    }

    rh1 = 0;
  }

  var theta = this.ns * adjust_lon(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p;
} // Lambert Conformal Conic inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------

function lcc_inverse(p) {
  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = this.rh - (p.y - this.y0) / this.k0;

  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }

  var theta = 0;

  if (rh1 !== 0) {
    theta = Math.atan2(con * x, con * y);
  }

  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts = Math.pow(rh1 / (this.a * this.f0), con);
    lat = phi2z(this.e, ts);

    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -HALF_PI;
  }

  lon = adjust_lon(theta / this.ns + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
var lcc_names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];
/* harmony default export */ var lcc = ({
  init: lcc_init,
  forward: lcc_forward,
  inverse: lcc_inverse,
  names: lcc_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/krovak.js

function krovak_init() {
  this.a = 6377397.155;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);

  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }

  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  /* if scale not set default to 0.9999 */


  if (!this.k0) {
    this.k0 = 0.9999;
  }

  this.s45 = 0.785398163397448;
  /* 45 */

  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}
/* ellipsoid */

/* calculate xy from lat/lon */

/* Constants, identical to inverse transform function */

function krovak_forward(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  /* Transformation */

  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }

  return p;
}
/* calculate lat/lon from xy */

function krovak_inverse(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;
  /* Transformation */

  /* revert y, x*/

  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }

  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;

  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);

    if (Math.abs(fi1 - p.y) < 0.0000000001) {
      ok = 1;
    }

    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);

  if (iter >= 15) {
    return null;
  }

  return p;
}
var krovak_names = ["Krovak", "krovak"];
/* harmony default export */ var krovak = ({
  init: krovak_init,
  forward: krovak_forward,
  inverse: krovak_inverse,
  names: krovak_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/mlfn.js
/* harmony default export */ var mlfn = (function (e0, e1, e2, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e0fn.js
/* harmony default export */ var e0fn = (function (x) {
  return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e1fn.js
/* harmony default export */ var e1fn = (function (x) {
  return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e2fn.js
/* harmony default export */ var e2fn = (function (x) {
  return 0.05859375 * x * x * (1 + 0.75 * x);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e3fn.js
/* harmony default export */ var e3fn = (function (x) {
  return x * x * x * (35 / 3072);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/gN.js
/* harmony default export */ var gN = (function (a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_lat.js


/* harmony default export */ var adjust_lat = (function (x) {
  return Math.abs(x) < HALF_PI ? x : x - sign(x) * Math.PI;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/imlfn.js
/* harmony default export */ var imlfn = (function (ml, e0, e1, e2, e3) {
  var phi;
  var dphi;
  phi = ml / e0;

  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;

    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  } //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");


  return NaN;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/cass.js










function cass_init() {
  if (!this.sphere) {
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}
/* Cassini forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/

function cass_forward(p) {
  /* Forward equations
      -----------------*/
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon(lam - this.long0);

  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    //ellipsoid
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
/* Inverse equations
  -----------------*/

function cass_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;

  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  } else {
    /* ellipsoid */
    var ml1 = this.ml0 / this.a + y;
    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);

    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p.x = this.long0;
      p.y = HALF_PI;

      if (y < 0) {
        p.y *= -1;
      }

      return p;
    }

    var nl1 = gN(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }

  p.x = adjust_lon(lam + this.long0);
  p.y = adjust_lat(phi);
  return p;
}
var cass_names = ["Cassini", "Cassini_Soldner", "cass"];
/* harmony default export */ var cass = ({
  init: cass_init,
  forward: cass_forward,
  inverse: cass_inverse,
  names: cass_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/qsfnz.js
/* harmony default export */ var qsfnz = (function (eccent, sinphi) {
  var con;

  if (eccent > 1.0e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/laea.js



/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

var S_POLE = 1;
var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;
/* Initialize the Lambert Azimuthal Equal Area projection
  ------------------------------------------------------*/

function laea_init() {
  var t = Math.abs(this.lat0);

  if (Math.abs(t - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  } else if (Math.abs(t) < EPSLN) {
    this.mode = this.EQUIT;
  } else {
    this.mode = this.OBLIQ;
  }

  if (this.es > 0) {
    var sinphi;
    this.qp = qsfnz(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);

    switch (this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;

      case this.S_POLE:
        this.dd = 1;
        break;

      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;

      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}
/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/

function laea_forward(p) {
  /* Forward equations
      -----------------*/
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon(lam - this.long0);

  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);

    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;

      if (y <= EPSLN) {
        return null;
      }

      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }

      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }

      y = FORTPI - phi * 0.5;
      y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = qsfnz(this.e, sinphi);

    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }

    switch (this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;

      case this.EQUIT:
        b = 1 + cosb * coslam;
        break;

      case this.N_POLE:
        b = HALF_PI + phi;
        q = this.qp - q;
        break;

      case this.S_POLE:
        b = phi - HALF_PI;
        q = this.qp + q;
        break;
    }

    if (Math.abs(b) < EPSLN) {
      return null;
    }

    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b);

        if (this.mode === this.OBLIQ) {
          y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }

        x = this.xmf * b * cosb * sinlam;
        break;

      case this.N_POLE:
      case this.S_POLE:
        if (q >= 0) {
          x = (b = Math.sqrt(q)) * sinlam;
          y = coslam * (this.mode === this.S_POLE ? b : -b);
        } else {
          x = y = 0;
        }

        break;
    }
  }

  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}
/* Inverse equations
  -----------------*/

function laea_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;

  if (this.sphere) {
    var cosz = 0,
        rh,
        sinz = 0;
    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;

    if (phi > 1) {
      return null;
    }

    phi = 2 * Math.asin(phi);

    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }

    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);
        x *= sinz;
        y = cosz * rh;
        break;

      case this.OBLIQ:
        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
        x *= sinz * this.cosph0;
        y = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;

      case this.N_POLE:
        y = -y;
        phi = HALF_PI - phi;
        break;

      case this.S_POLE:
        phi -= HALF_PI;
        break;
    }

    lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
  } else {
    ab = 0;

    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);

      if (rho < EPSLN) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }

      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= sCe = Math.sin(sCe);

      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      } else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }

      q = x * x + y * y;

      if (!q) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }

      ab = 1 - q / this.qp;

      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }

    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab), this.apa);
  }

  p.x = adjust_lon(this.long0 + lam);
  p.y = phi;
  return p;
}
/* determine latitude from authalic latitude */

var P00 = 0.33333333333333333333;
var P01 = 0.17222222222222222222;
var P02 = 0.10257936507936507936;
var P10 = 0.06388888888888888888;
var P11 = 0.06640211640211640211;
var P20 = 0.01641501294219154443;

function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}

function authlat(beta, APA) {
  var t = beta + beta;
  return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
}

var laea_names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
/* harmony default export */ var laea = ({
  init: laea_init,
  forward: laea_forward,
  inverse: laea_inverse,
  names: laea_names,
  S_POLE: S_POLE,
  N_POLE: N_POLE,
  EQUIT: EQUIT,
  OBLIQ: OBLIQ
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/asinz.js
/* harmony default export */ var asinz = (function (x) {
  if (Math.abs(x) > 1) {
    x = x > 1 ? 1 : -1;
  }

  return Math.asin(x);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/aea.js





function aea_init() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }

  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }

  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}
/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
  -------------------------------------------------------------------*/

function aea_forward(p) {
  var lon = p.x;
  var lat = p.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function aea_inverse(p) {
  var rh1, qs, con, theta, lon, lat;
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;

  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }

  theta = 0;

  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  con = rh1 * this.ns0 / this.a;

  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }

  lon = adjust_lon(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
/* Function to compute phi1, the latitude for the inverse of the
   Albers Conical Equal-Area projection.
-------------------------------------------*/

function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz(0.5 * qs);

  if (eccent < EPSLN) {
    return phi;
  }

  var eccnts = eccent * eccent;

  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;

    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }

  return null;
}
var aea_names = ["Albers_Conic_Equal_Area", "Albers", "aea"];
/* harmony default export */ var aea = ({
  init: aea_init,
  forward: aea_forward,
  inverse: aea_inverse,
  names: aea_names,
  phi1z: phi1z
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/gnom.js



/*
  reference:
    Wolfram Mathworld "Gnomonic Projection"
    http://mathworld.wolfram.com/GnomonicProjection.html
    Accessed: 12th November 2009
  */

function gnom_init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0); // Approximation for projecting points to the horizon (infinity)

  this.infinity_dist = 1000 * this.a;
  this.rc = 1;
}
/* Gnomonic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/

function gnom_forward(p) {
  var sinphi, cosphi;
  /* sin and cos value        */

  var dlon;
  /* delta longitude value      */

  var coslon;
  /* cos of longitude        */

  var ksp;
  /* scale factor          */

  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/

  dlon = adjust_lon(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;

  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  } else {
    // Point is in the opposing hemisphere and is unprojectable
    // We still need to return a reasonable point, so we project
    // to infinity, on a bearing
    // equivalent to the northern hemisphere equivalent
    // This is a reasonable approximation for short shapes and lines that
    // straddle the horizon.
    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }

  p.x = x;
  p.y = y;
  return p;
}
function gnom_inverse(p) {
  var rh;
  /* Rho */

  var sinc, cosc;
  var c;
  var lon, lat;
  /* Inverse equations
      -----------------*/

  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;

  if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = asinz(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = adjust_lon(this.long0 + lon);
  } else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var gnom_names = ["gnom"];
/* harmony default export */ var gnom = ({
  init: gnom_init,
  forward: gnom_forward,
  inverse: gnom_inverse,
  names: gnom_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/common/iqsfnz.js

/* harmony default export */ var iqsfnz = (function (eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));

  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
    if (q < 0) {
      return -1 * HALF_PI;
    } else {
      return HALF_PI;
    }
  } //var phi = 0.5* q/(1-eccent*eccent);


  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;

  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;

    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  } //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");


  return NaN;
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/cea.js




/*
  reference:
    "Cartographic Projection Procedures for the UNIX Environment-
    A User's Manual" by Gerald I. Evenden,
    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
*/

function cea_init() {
  //no-op
  if (!this.sphere) {
    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}
/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/

function cea_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  /* Forward equations
      -----------------*/

  var dlon = adjust_lon(lon - this.long0);

  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = qsfnz(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }

  p.x = x;
  p.y = y;
  return p;
}
/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/

function cea_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;

  if (this.sphere) {
    lon = adjust_lon(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
    lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var cea_names = ["cea"];
/* harmony default export */ var cea = ({
  init: cea_init,
  forward: cea_forward,
  inverse: cea_inverse,
  names: cea_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/eqc.js


function eqc_init() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
  this.rc = Math.cos(this.lat_ts);
} // forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------

function eqc_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon(lon - this.long0);
  var dlat = adjust_lat(lat - this.lat0);
  p.x = this.x0 + this.a * dlon * this.rc;
  p.y = this.y0 + this.a * dlat;
  return p;
} // inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------

function eqc_inverse(p) {
  var x = p.x;
  var y = p.y;
  p.x = adjust_lon(this.long0 + (x - this.x0) / (this.a * this.rc));
  p.y = adjust_lat(this.lat0 + (y - this.y0) / this.a);
  return p;
}
var eqc_names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
/* harmony default export */ var eqc = ({
  init: eqc_init,
  forward: eqc_forward,
  inverse: eqc_inverse,
  names: eqc_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/poly.js









var poly_MAX_ITER = 20;
function poly_init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles

  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
}
/* Polyconic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/

function poly_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = adjust_lon(lon - this.long0);
  el = dlon * Math.sin(lat);

  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    } else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    } else {
      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
/* Inverse equations
  -----------------*/

function poly_inverse(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;

  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon(x / this.a + this.long0);
      lat = 0;
    } else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;

      for (i = poly_MAX_ITER; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;

        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }

      lon = adjust_lon(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
    }
  } else {
    if (Math.abs(y + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon(this.long0 + x / this.a);
    } else {
      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;

      for (i = poly_MAX_ITER; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;

        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      } //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);


      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var poly_names = ["Polyconic", "poly"];
/* harmony default export */ var poly = ({
  init: poly_init,
  forward: poly_forward,
  inverse: poly_inverse,
  names: poly_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/nzmg.js

/*
  reference
    Department of Land and Survey Technical Circular 1973/32
      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
    OSG Technical Report 4.1
      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
  */

/**
 * iterations: Number of iterations to refine inverse transform.
 *     0 -> km accuracy
 *     1 -> m accuracy -- suitable for most mapping applications
 *     2 -> mm accuracy
 */

var iterations = 1;
function nzmg_init() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -0.0055161;
  this.A[7] = 0.0026906;
  this.A[8] = -0.001333;
  this.A[9] = 0.00067;
  this.A[10] = -0.00034;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 0.003371507;
  this.B_re[3] = -0.001541739;
  this.B_im[3] = 0.041058560;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -0.007809598;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 0.007317;
  this.D[7] = 0.01220;
  this.D[8] = 0.00394;
  this.D[9] = -0.0013;
}
/**
    New Zealand Map Grid Forward  - long/lat to x/y
    long/lat in radians
  */

function nzmg_forward(p) {
  var n;
  var lon = p.x;
  var lat = p.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0; // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.

  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1; // d_phi^0

  var d_psi = 0;

  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  } // 2. Calculate theta


  var th_re = d_psi;
  var th_im = d_lambda; // 3. Calculate z

  var th_n_re = 1;
  var th_n_im = 0; // theta^0

  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;

  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  } // 4. Calculate easting and northing


  p.x = z_im * this.a + this.x0;
  p.y = z_re * this.a + this.y0;
  return p;
}
/**
    New Zealand Map Grid Inverse  -  x/y to long/lat
  */

function nzmg_inverse(p) {
  var n;
  var x = p.x;
  var y = p.y;
  var delta_x = x - this.x0;
  var delta_y = y - this.y0; // 1. Calculate z

  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a; // 2a. Calculate theta - first approximation gives km accuracy

  var z_n_re = 1;
  var z_n_im = 0; // z^0

  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;

  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  } // 2b. Iterate to refine the accuracy of the calculation
  //        0 iterations gives km accuracy
  //        1 iteration gives m accuracy -- good enough for most mapping applications
  //        2 iterations bives mm accuracy


  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;

    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];

    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    } // Complex division


    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  } // 3. Calculate d_phi              ...                                    // and d_lambda


  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1; // d_psi^0

  var d_phi = 0;

  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  } // 4. Calculate latitude and longitude
  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.


  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1E5;
  var lon = this.long0 + d_lambda;
  p.x = lon;
  p.y = lat;
  return p;
}
var nzmg_names = ["New_Zealand_Map_Grid", "nzmg"];
/* harmony default export */ var nzmg = ({
  init: nzmg_init,
  forward: nzmg_forward,
  inverse: nzmg_inverse,
  names: nzmg_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/mill.js

/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

/* Initialize the Miller Cylindrical projection
  -------------------------------------------*/

function mill_init() {//no-op
}
/* Miller Cylindrical forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/

function mill_forward(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/

  var dlon = adjust_lon(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p.x = x;
  p.y = y;
  return p;
}
/* Miller Cylindrical inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/

function mill_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon = adjust_lon(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
  p.x = lon;
  p.y = lat;
  return p;
}
var mill_names = ["Miller_Cylindrical", "mill"];
/* harmony default export */ var mill = ({
  init: mill_init,
  forward: mill_forward,
  inverse: mill_inverse,
  names: mill_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/sinu.js



var sinu_MAX_ITER = 20;




function sinu_init() {
  /* Place parameters in static storage for common use
    -------------------------------------------------*/
  if (!this.sphere) {
    this.en = pj_enfn(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}
/* Sinusoidal forward equations--mapping lat,long to x,y
  -----------------------------------------------------*/

function sinu_forward(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/

  lon = adjust_lon(lon - this.long0);

  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k = this.n * Math.sin(lat);

      for (var i = sinu_MAX_ITER; i; --i) {
        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V;

        if (Math.abs(V) < EPSLN) {
          break;
        }
      }
    }

    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;
  } else {
    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * pj_mlfn(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }

  p.x = x;
  p.y = y;
  return p;
}
function sinu_inverse(p) {
  var lat, temp, lon, s;
  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;

  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));

    if (this.m) {
      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = asinz(Math.sin(lat) / this.n);
    }

    lon = adjust_lon(lon + this.long0);
    lat = adjust_lat(lat);
  } else {
    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);

    if (s < HALF_PI) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat)); //temp = this.long0 + p.x / (this.a * Math.cos(lat));

      lon = adjust_lon(temp);
    } else if (s - EPSLN < HALF_PI) {
      lon = this.long0;
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var sinu_names = ["Sinusoidal", "sinu"];
/* harmony default export */ var sinu = ({
  init: sinu_init,
  forward: sinu_forward,
  inverse: sinu_inverse,
  names: sinu_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/moll.js

function moll_init() {}

/* Mollweide forward equations--mapping lat,long to x,y
    ----------------------------------------------------*/

function moll_forward(p) {
  /* Forward equations
      -----------------*/
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);
  /* Iterate using the Newton-Raphson method to find theta
      -----------------------------------------------------*/

  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;

    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }

  theta /= 2;
  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
       this is done here because of precision problems with "cos(theta)"
       --------------------------------------------------------------------------*/

  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }

  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function moll_inverse(p) {
  var theta;
  var arg;
  /* Inverse equations
      -----------------*/

  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);
  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
       a number very close to one is used instead.
       -------------------------------------------------------------------*/

  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }

  theta = Math.asin(arg);
  var lon = adjust_lon(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));

  if (lon < -Math.PI) {
    lon = -Math.PI;
  }

  if (lon > Math.PI) {
    lon = Math.PI;
  }

  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;

  if (Math.abs(arg) > 1) {
    arg = 1;
  }

  var lat = Math.asin(arg);
  p.x = lon;
  p.y = lat;
  return p;
}
var moll_names = ["Mollweide", "moll"];
/* harmony default export */ var moll = ({
  init: moll_init,
  forward: moll_forward,
  inverse: moll_inverse,
  names: moll_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/eqdc.js










function eqdc_init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }

  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);
  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  } else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }

  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}
/* Equidistant Conic forward equations--mapping lat,long to x,y
  -----------------------------------------------------------*/

function eqdc_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;
  /* Forward equations
      -----------------*/

  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }

  var theta = this.ns * adjust_lon(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}
/* Inverse equations
  -----------------*/

function eqdc_inverse(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;

  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }

  var theta = 0;

  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  if (this.sphere) {
    lon = adjust_lon(this.long0 + theta / this.ns);
    lat = adjust_lat(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }
}
var eqdc_names = ["Equidistant_Conic", "eqdc"];
/* harmony default export */ var eqdc = ({
  init: eqdc_init,
  forward: eqdc_forward,
  inverse: eqdc_inverse,
  names: eqdc_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/vandg.js



/* Initialize the Van Der Grinten projection
  ----------------------------------------*/

function vandg_init() {
  //this.R = 6370997; //Radius of earth
  this.R = this.a;
}
function vandg_forward(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/

  var dlon = adjust_lon(lon - this.long0);
  var x, y;

  if (Math.abs(lat) <= EPSLN) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }

  var theta = asinz(2 * Math.abs(lat / Math.PI));

  if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    x = this.x0;

    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    } //  return(OK);

  }

  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);

  if (dlon < 0) {
    con = -con;
  }

  x = this.x0 + con; //con = Math.abs(con / (Math.PI * this.R));

  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);

  if (lat >= 0) {
    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 + con;
  } else {
    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 - con;
  }

  p.x = x;
  p.y = y;
  return p;
}
/* Van Der Grinten inverse equations--mapping x,y to lat/long
  ---------------------------------------------------------*/

function vandg_inverse(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;
  /* inverse equations
    -----------------*/

  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = 3 * d / a1 / m1;

  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }

  th1 = Math.acos(con) / 3;

  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }

  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  } else {
    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }

  p.x = lon;
  p.y = lat;
  return p;
}
var vandg_names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
/* harmony default export */ var vandg = ({
  init: vandg_init,
  forward: vandg_forward,
  inverse: vandg_inverse,
  names: vandg_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/aeqd.js










function aeqd_init() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}
function aeqd_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = adjust_lon(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;

  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p;
    } else {
      //default case
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c ? c / Math.sin(c) : 1;
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  } else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);

    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    } else {
      //Default case
      tanphi = sinphi / cosphi;
      Nl1 = gN(this.a, this.e, this.sin_p12);
      Nl = gN(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));

      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }

      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }
}
function aeqd_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;

  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);

    if (rh > 2 * HALF_PI * this.a) {
      return;
    }

    z = rh / this.a;
    sinz = Math.sin(z);
    cosz = Math.cos(z);
    lon = this.long0;

    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    } else {
      lat = asinz(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - HALF_PI;

      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
        } else {
          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
        }
      } else {
        /*con = cosz - this.sin_p12 * Math.sin(lat);
        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
          //no-op, just keep the lon value as is
        } else {
          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
        }*/
        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  } else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);

    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      //default case
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = gN(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      sinpsi = Math.sin(psi);
      lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }
}
var aeqd_names = ["Azimuthal_Equidistant", "aeqd"];
/* harmony default export */ var aeqd = ({
  init: aeqd_init,
  forward: aeqd_forward,
  inverse: aeqd_inverse,
  names: aeqd_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/ortho.js



function ortho_init() {
  //double temp;      /* temporary variable    */

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}
/* Orthographic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/

function ortho_forward(p) {
  var sinphi, cosphi;
  /* sin and cos value        */

  var dlon;
  /* delta longitude value      */

  var coslon;
  /* cos of longitude        */

  var ksp;
  /* scale factor          */

  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/

  dlon = adjust_lon(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;

  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }

  p.x = x;
  p.y = y;
  return p;
}
function ortho_inverse(p) {
  var rh;
  /* height above ellipsoid      */

  var z;
  /* angle          */

  var sinz, cosz;
  /* sin of z and cos of z      */

  var con;
  var lon, lat;
  /* Inverse equations
      -----------------*/

  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = asinz(rh / this.a);
  sinz = Math.sin(z);
  cosz = Math.cos(z);
  lon = this.long0;

  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }

  lat = asinz(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - HALF_PI;

  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon(this.long0 + Math.atan2(p.x, -p.y));
    } else {
      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
  p.x = lon;
  p.y = lat;
  return p;
}
var ortho_names = ["ortho"];
/* harmony default export */ var ortho = ({
  init: ortho_init,
  forward: ortho_forward,
  inverse: ortho_inverse,
  names: ortho_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/qsc.js
// QSC projection rewritten from the original PROJ4
// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c

/* constants */

var FACE_ENUM = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
};
var AREA_ENUM = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function qsc_init() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";
  /* Determine the cube face from the center of projection. */

  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }
  /* Fill in useful values for the ellipsoid <-> sphere shift
   * described in [LK12]. */


  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
} // QSC forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------

function qsc_forward(p) {
  var xy = {
    x: 0,
    y: 0
  };
  var lat, lon;
  var theta, phi;
  var t, mu;
  /* nu; */

  var area = {
    value: 0
  }; // move lon according to projection's lon

  p.x -= this.long0;
  /* Convert the geodetic latitude to a geocentric latitude.
   * This corresponds to the shift from the ellipsoid to the sphere
   * described in [LK12]. */

  if (this.es !== 0) {
    //if (P->es != 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }
  /* Convert the input lat, lon into theta, phi as used by QSC.
   * This depends on the cube face and the area on it.
   * For the top and bottom face, we can compute theta and phi
   * directly from phi, lam. For the other faces, we must use
   * unit sphere cartesian coordinates as an intermediate step. */


  lon = p.x; //lon = lp.lam;

  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;

    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_1;
      theta = lon > 0.0 ? lon - SPI : lon + SPI;
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;

    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon > 0.0 ? -lon + SPI : -lon - SPI;
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;

    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }

    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;

    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
    } else {
      /* Impossible */
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }
  /* Compute mu and nu for the area of definition.
   * For mu, see Eq. (3-21) in [OL76], but note the typos:
   * compare with Eq. (3-14). For nu, see Eq. (3-38). */


  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
  /* Apply the result to the real area. */

  if (area.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }
  /* Now compute x, y from mu and nu */


  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p.x = xy.x;
  p.y = xy.y;
  return p;
} // QSC inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------

function qsc_inverse(p) {
  var lp = {
    lam: 0,
    phi: 0
  };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = {
    value: 0
  };
  /* de-offset */

  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  /* Convert the input x, y to the mu and nu angles as used by QSC.
   * This depends on the area of the cube face. */

  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);

  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = mu < 0.0 ? mu + SPI : mu - SPI;
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }
  /* Compute phi and theta for the area of definition.
   * The inverse projection is not described in the original paper, but some
   * good hints can be found here (as of 2011-12-14):
   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */


  t = SPI / 12 * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));

  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > +1) {
    cosphi = +1;
  }
  /* Apply the result to the real area on the cube face.
   * For the top and bottom face, we can compute phi and lam directly.
   * For the other faces, we must use unit sphere cartesian coordinates
   * as an intermediate step. */


  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;

    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0.0 ? theta + SPI : theta - SPI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else
      /* area.value == AREA_ENUM.AREA_3 */
      {
        lp.lam = theta;
      }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;

    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else
      /* area.value == AREA_ENUM.AREA_3 */
      {
        lp.lam = theta < 0.0 ? -theta - SPI : -theta + SPI;
      }
  } else {
    /* Compute phi and lam via cartesian unit sphere coordinates. */
    var q, r, s;
    q = cosphi;
    t = q * q;

    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }

    t += s * s;

    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    /* Rotate q,r,s into the correct area. */


    if (area.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    /* Rotate q,r,s into the correct cube face. */


    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    /* Now compute phi and lam from the unit sphere coordinates. */


    lp.phi = Math.acos(-s) - HALF_PI;
    lp.lam = Math.atan2(r, q);

    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }
  /* Apply the shift from the sphere to the ellipsoid as described
   * in [LK12]. */


  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));

    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }

  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}
/* Helper function for forward projection: compute the theta angle
 * and determine the area number. */

function qsc_fwd_equat_face_theta(phi, y, x, area) {
  var theta;

  if (phi < EPSLN) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0.0;
  } else {
    theta = Math.atan2(y, x);

    if (Math.abs(theta) <= FORTPI) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = theta >= 0.0 ? theta - SPI : theta + SPI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }

  return theta;
}
/* Helper function: shift the longitude. */


function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;

  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }

  return slon;
}

var qsc_names = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
/* harmony default export */ var qsc = ({
  init: qsc_init,
  forward: qsc_forward,
  inverse: qsc_inverse,
  names: qsc_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/robin.js
// Robinson projection
// Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c
// Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039


var COEFS_X = [[1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06], [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06], [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07], [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06], [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06], [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08], [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06], [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06], [0.9216, -0.00467746, -0.00010457, 4.81243e-06], [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06], [0.8679, -0.00609363, -0.000113898, 3.32484e-06], [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07], [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07], [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06], [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06], [0.6732, -0.00986209, -0.000199569, 1.91974e-05], [0.6213, -0.010418, 8.83923e-05, 6.24051e-06], [0.5722, -0.00906601, 0.000182, 6.24051e-06], [0.5322, -0.00677797, 0.000275608, 6.24051e-06]];
var COEFS_Y = [[-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11], [0.0620, 0.0124, -1.26793e-09, 4.22642e-10], [0.1240, 0.0124, 5.07171e-09, -1.60604e-09], [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09], [0.2480, 0.0124002, 7.10039e-08, -2.24e-08], [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08], [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07], [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07], [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07], [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07], [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07], [0.6769, 0.011713, -3.20223e-05, -5.16405e-07], [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07], [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06], [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09], [0.8936, 0.00969686, -6.4636e-05, -8.547e-06], [0.9394, 0.00840947, -0.000192841, -4.2106e-06], [0.9761, 0.00616527, -0.000256, -4.2106e-06], [1.0000, 0.00328947, -0.000319159, -4.2106e-06]];
var FXC = 0.8487;
var FYC = 1.3523;
var C1 = R2D / 5; // rad to 5-degree interval

var RC1 = 1 / C1;
var NODES = 18;

var poly3_val = function poly3_val(coefs, x) {
  return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
};

var poly3_der = function poly3_der(coefs, x) {
  return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
};

function newton_rapshon(f_df, start, max_err, iters) {
  var x = start;

  for (; iters; --iters) {
    var upd = f_df(x);
    x -= upd;

    if (Math.abs(upd) < max_err) {
      break;
    }
  }

  return x;
}

function robin_init() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || "Robinson";
}
function robin_forward(ll) {
  var lon = adjust_lon(ll.x - this.long0);
  var dphi = Math.abs(ll.y);
  var i = Math.floor(dphi * C1);

  if (i < 0) {
    i = 0;
  } else if (i >= NODES) {
    i = NODES - 1;
  }

  dphi = R2D * (dphi - RC1 * i);
  var xy = {
    x: poly3_val(COEFS_X[i], dphi) * lon,
    y: poly3_val(COEFS_Y[i], dphi)
  };

  if (ll.y < 0) {
    xy.y = -xy.y;
  }

  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function robin_inverse(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };

  if (ll.y >= 1) {
    // pathologic case
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
  } else {
    // find table interval
    var i = Math.floor(ll.y * NODES);

    if (i < 0) {
      i = 0;
    } else if (i >= NODES) {
      i = NODES - 1;
    }

    for (;;) {
      if (COEFS_Y[i][0] > ll.y) {
        --i;
      } else if (COEFS_Y[i + 1][0] <= ll.y) {
        ++i;
      } else {
        break;
      }
    } // linear interpolation in 5 degree interval


    var coefs = COEFS_Y[i];
    var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]); // find t so that poly3_val(coefs, t) = ll.y

    t = newton_rapshon(function (x) {
      return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
    }, t, EPSLN, 100);
    ll.x /= poly3_val(COEFS_X[i], t);
    ll.y = (5 * i + t) * D2R;

    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }

  ll.x = adjust_lon(ll.x + this.long0);
  return ll;
}
var robin_names = ["Robinson", "robin"];
/* harmony default export */ var robin = ({
  init: robin_init,
  forward: robin_forward,
  inverse: robin_inverse,
  names: robin_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/geocent.js

function geocent_init() {
  this.name = 'geocent';
}
function geocent_forward(p) {
  var point = geodeticToGeocentric(p, this.es, this.a);
  return point;
}
function geocent_inverse(p) {
  var point = geocentricToGeodetic(p, this.es, this.a, this.b);
  return point;
}
var geocent_names = ["Geocentric", 'geocentric', "geocent", "Geocent"];
/* harmony default export */ var geocent = ({
  init: geocent_init,
  forward: geocent_forward,
  inverse: geocent_inverse,
  names: geocent_names
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/tpers.js
var mode = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
};


var tpers_params = {
  h: {
    def: 100000,
    num: true
  },
  // default is Karman line, no default in PROJ.7
  azi: {
    def: 0,
    num: true,
    degrees: true
  },
  // default is North
  tilt: {
    def: 0,
    num: true,
    degrees: true
  },
  // default is Nadir
  long0: {
    def: 0,
    num: true
  },
  // default is Greenwich, conversion to rad is automatic
  lat0: {
    def: 0,
    num: true
  } // default is Equator, conversion to rad is automatic

};
function tpers_init() {
  Object.keys(tpers_params).forEach(function (p) {
    if (typeof this[p] === "undefined") {
      this[p] = tpers_params[p].def;
    } else if (tpers_params[p].num && isNaN(this[p])) {
      throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
    } else if (tpers_params[p].num) {
      this[p] = parseFloat(this[p]);
    }

    if (tpers_params[p].degrees) {
      this[p] = this[p] * D2R;
    }
  }.bind(this));

  if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }

  this.pn1 = this.h / this.a; // Normalize relative to the Earth's radius

  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }

  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;
  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}
function tpers_forward(p) {
  p.x -= this.long0;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var coslam = Math.cos(p.x);
  var x, y;

  switch (this.mode) {
    case mode.OBLIQ:
      y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;

    case mode.EQUIT:
      y = cosphi * coslam;
      break;

    case mode.S_POLE:
      y = -sinphi;
      break;

    case mode.N_POLE:
      y = sinphi;
      break;
  }

  y = this.pn1 / (this.p - y);
  x = y * cosphi * Math.sin(p.x);

  switch (this.mode) {
    case mode.OBLIQ:
      y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;

    case mode.EQUIT:
      y *= sinphi;
      break;

    case mode.N_POLE:
      y *= -(cosphi * coslam);
      break;

    case mode.S_POLE:
      y *= cosphi * coslam;
      break;
  } // Tilt 


  var yt, ba;
  yt = y * this.cg + x * this.sg;
  ba = 1 / (yt * this.sw * this.h1 + this.cw);
  x = (x * this.cg - y * this.sg) * this.cw * ba;
  y = yt * ba;
  p.x = x * this.a;
  p.y = y * this.a;
  return p;
}
function tpers_inverse(p) {
  p.x /= this.a;
  p.y /= this.a;
  var r = {
    x: p.x,
    y: p.y
  }; // Un-Tilt

  var bm, bq, yt;
  yt = 1 / (this.pn1 - p.y * this.sw);
  bm = this.pn1 * p.x * yt;
  bq = this.pn1 * p.y * this.cw * yt;
  p.x = bm * this.cg + bq * this.sg;
  p.y = bq * this.cg - bm * this.sg;
  var rh = hypot(p.x, p.y);

  if (Math.abs(rh) < EPSLN) {
    r.x = 0;
    r.y = p.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);

    switch (this.mode) {
      case mode.OBLIQ:
        r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
        p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
        p.x *= sinz * this.cosph0;
        break;

      case mode.EQUIT:
        r.y = Math.asin(p.y * sinz / rh);
        p.y = cosz * rh;
        p.x *= sinz;
        break;

      case mode.N_POLE:
        r.y = Math.asin(cosz);
        p.y = -p.y;
        break;

      case mode.S_POLE:
        r.y = -Math.asin(cosz);
        break;
    }

    r.x = Math.atan2(p.x, p.y);
  }

  p.x = r.x + this.long0;
  p.y = r.y;
  return p;
}
var tpers_names = ["Tilted_Perspective", "tpers"];
/* harmony default export */ var tpers = ({
  init: tpers_init,
  forward: tpers_forward,
  inverse: tpers_inverse,
  names: tpers_names
});
// CONCATENATED MODULE: ./node_modules/proj4/projs.js




























/* harmony default export */ var proj4_projs = (function (proj4) {
  proj4.Proj.projections.add(tmerc);
  proj4.Proj.projections.add(etmerc);
  proj4.Proj.projections.add(utm);
  proj4.Proj.projections.add(sterea);
  proj4.Proj.projections.add(stere);
  proj4.Proj.projections.add(somerc);
  proj4.Proj.projections.add(omerc);
  proj4.Proj.projections.add(lcc);
  proj4.Proj.projections.add(krovak);
  proj4.Proj.projections.add(cass);
  proj4.Proj.projections.add(laea);
  proj4.Proj.projections.add(aea);
  proj4.Proj.projections.add(gnom);
  proj4.Proj.projections.add(cea);
  proj4.Proj.projections.add(eqc);
  proj4.Proj.projections.add(poly);
  proj4.Proj.projections.add(nzmg);
  proj4.Proj.projections.add(mill);
  proj4.Proj.projections.add(sinu);
  proj4.Proj.projections.add(moll);
  proj4.Proj.projections.add(eqdc);
  proj4.Proj.projections.add(vandg);
  proj4.Proj.projections.add(aeqd);
  proj4.Proj.projections.add(ortho);
  proj4.Proj.projections.add(qsc);
  proj4.Proj.projections.add(robin);
  proj4.Proj.projections.add(geocent);
  proj4.Proj.projections.add(tpers);
});
// CONCATENATED MODULE: ./node_modules/proj4/lib/index.js








core.defaultDatum = 'WGS84'; //default datum

core.Proj = Proj;
core.WGS84 = new core.Proj('WGS84');
core.Point = lib_Point;
core.toPoint = toPoint;
core.defs = lib_defs;
core.transform = transform;
core.mgrs = mgrs;
core.version = '__VERSION__';
proj4_projs(core);
/* harmony default export */ var lib = (core);
// CONCATENATED MODULE: ./src/core/Proj4Leaflet.js


window.proj4 = lib;
external_L_default.a.Proj = {};

external_L_default.a.Proj._isProj4Obj = function (a) {
  return typeof a.inverse !== 'undefined' && typeof a.forward !== 'undefined';
};

external_L_default.a.Proj.Projection = external_L_default.a.Class.extend({
  initialize: function initialize(code, def, bounds) {
    var isP4 = external_L_default.a.Proj._isProj4Obj(code);

    this._proj = isP4 ? code : this._projFromCodeDef(code, def);
    var boundsOption = bounds;

    if (external_L_default.a.Util.isArray(bounds)) {
      boundsOption = external_L_default.a.bounds(bounds);
    }

    this.bounds = isP4 ? def : boundsOption;
  },
  project: function project(latlng) {
    var point = this._proj.forward([latlng.lng, latlng.lat]);

    return new external_L_default.a.Point(point[0], point[1]);
  },
  unproject: function unproject(point, unbounded) {
    if (this.bounds) {
      point.x = point.x < this.bounds.min.x ? this.bounds.min.x : point.x > this.bounds.max.x ? this.bounds.max.x : point.x;
      point.y = point.y < this.bounds.min.y ? this.bounds.min.y : point.y > this.bounds.max.y ? this.bounds.max.y : point.y;
    }

    var point2 = this._proj.inverse([point.x, point.y]);

    return new external_L_default.a.LatLng(point2[1], point2[0], unbounded);
  },
  _projFromCodeDef: function _projFromCodeDef(code, def) {
    if (def) {
      lib.defs(code, def);
    } else if (lib.defs[code] === undefined) {
      var urn = code.split(':');

      if (urn.length > 3) {
        code = urn[urn.length - 3] + ':' + urn[urn.length - 1];
      }

      if (lib.defs[code] === undefined) {
        throw 'No projection definition for code ' + code;
      }
    }

    return lib(code);
  },
  getUnits: function getUnits() {
    return this._proj.oProj.units || 'degrees';
  }
});
var CRS = external_L_default.a.Class.extend({
  includes: external_L_default.a.CRS,
  options: {
    transformation: new external_L_default.a.Transformation(1, 0, -1, 0)
  },
  initialize: function initialize(srsCode, options) {
    var code, proj, def;

    if (external_L_default.a.Proj._isProj4Obj(srsCode)) {
      proj = srsCode;
      code = proj.srsCode;
      options = options || {};
      this.projection = new external_L_default.a.Proj.Projection(proj, options.bounds);
    } else {
      code = srsCode;
      options = options || {};
      def = options.def || '';
      this.projection = new external_L_default.a.Proj.Projection(code, def, options.bounds);
    }

    external_L_default.a.Util.setOptions(this, options);
    this.code = code;
    this.transformation = this.options.transformation;
    this.options.dpi = this.options.dpi || 96;

    if (this.options.bounds) {
      this.options.bounds = external_L_default.a.bounds(this.options.bounds);
    }

    if (!this.options.origin && this.options.bounds) {
      this.options.origin = [this.options.bounds.min.x, this.options.bounds.max.y];
    }

    if (this.options.origin) {
      if (this.options.origin instanceof external_L_default.a.Point) {
        this.options.origin = [this.options.origin.x, this.options.origin.y];
      }

      this.transformation = new external_L_default.a.Transformation(1, -this.options.origin[0], -1, this.options.origin[1]);
    }

    if (this.options.scales && this.options.scales.length > 0) {
      this.scales = this.options.scales;
      this._scales = this._toProj4Scales(this.options.scales, this.options.dpi);
    } else if (this.options.scaleDenominators && this.options.scaleDenominators.length > 0) {
      this.scales = [];

      for (var i = 0; i < this.options.scaleDenominators.length; i++) {
        this.scales[i] = 1 / this.options.scaleDenominators[i];
      }

      this._scales = this._toProj4Scales(this.scales, this.options.dpi);
    } else if (this.options.resolutions && this.options.resolutions.length > 0) {
      this._scales = [];

      for (var _i = this.options.resolutions.length - 1; _i >= 0; _i--) {
        if (this.options.resolutions[_i]) {
          this._scales[_i] = 1 / this.options.resolutions[_i];
        }
      }
    } else if (this.options.bounds) {
      this._scales = this._getDefaultProj4ScalesByBounds(this.options.bounds);
    }

    this._rectify();

    this.infinite = !this.options.bounds;
  },
  _rectify: function _rectify() {
    if (this._scales) {
      if (!this.resolutions) {
        this.resolutions = [];
        this.resolutions = this._proj4ScalesToResolutions(this._scales);
      }

      if (!this.scales) {
        this.scales = [];

        for (var i = 0; i < this.resolutions.length; i++) {
          var scaleD = this.resolutions[i] * this.options.dpi * (1 / 0.0254) * this._getMeterPerMapUnit(this.projection.getUnits());

          this.scales[i] = 1.0 / scaleD;
        }
      }
    }
  },

  /**
   * @function L.Proj.CRS.prototype.scale
   * @description 通过缩放级别获取比例尺值。
   * @param {number} zoom - 缩放级别。
   * @returns 比例尺值。
   */
  scale: function scale(zoom) {
    var iZoom = Math.floor(zoom),
        baseScale,
        nextScale,
        scaleDiff,
        zDiff;

    if (zoom === iZoom) {
      return this._scales[zoom];
    } else {
      // Non-integer zoom, interpolate
      baseScale = this._scales[iZoom];
      nextScale = this._scales[iZoom + 1];
      scaleDiff = nextScale - baseScale;
      zDiff = zoom - iZoom;
      return baseScale + scaleDiff * zDiff;
    }
  },

  /**
   * @function L.Proj.CRS.prototype.zoom
   * @description 根据比例尺返回缩放级别。
   * @param {number} scale - 比例尺。
   * @returns {number} 缩放级别。
   */
  zoom: function zoom(scale) {
    // Find closest number in this._scales, down
    var downScale = this._closestElement(this._scales, scale),
        downZoom = this._scales.indexOf(downScale),
        nextScale,
        nextZoom,
        scaleDiff; // Check if scale is downScale => return array index


    if (!downScale) {
      return 0;
    }

    if (scale === downScale) {
      return downZoom;
    } // Interpolate


    nextZoom = downZoom + 1;
    nextScale = this._scales[nextZoom];

    if (nextScale === undefined) {
      return downZoom;
    }

    scaleDiff = nextScale - downScale;
    return (scale - downScale) / scaleDiff + downZoom;
  },
  distance: external_L_default.a.CRS.Earth.distance,
  R: external_L_default.a.CRS.Earth.R,

  /* Get the closest lowest element in an array */
  _closestElement: function _closestElement(array, element) {
    var low;

    for (var i = array.length; i--;) {
      if (array[i] <= element && (low === undefined || low < array[i])) {
        low = array[i];
      }
    }

    return low;
  },
  _proj4ScalesToResolutions: function _proj4ScalesToResolutions(_scales) {
    var resolutions = [];

    if (!_scales) {
      return resolutions;
    }

    for (var i = 0; i < _scales.length; i++) {
      resolutions[i] = 1.0 / _scales[i];
    }

    return resolutions;
  },
  _toProj4Scales: function _toProj4Scales(scales, dpi) {
    var proj4Scales = [];

    if (!scales) {
      return proj4Scales;
    }

    for (var i = 0; i < scales.length; i++) {
      var a = this.projection ? this._getMeterPerMapUnit(this.projection.getUnits()) : 1;
      proj4Scales[i] = 1 / (0.0254 / ((dpi || 96) * scales[i]) / a);
    }

    return proj4Scales;
  },
  _getMeterPerMapUnit: function _getMeterPerMapUnit(mapUnit) {
    var earchRadiusInMeters = 6378137;
    var meterPerMapUnit = 1;

    if (mapUnit === 'meter') {
      meterPerMapUnit = 1;
    } else if (mapUnit === 'degrees') {
      // 每度表示多少米。
      meterPerMapUnit = Math.PI * 2 * earchRadiusInMeters / 360;
    } else if (mapUnit === 'kilometer') {
      meterPerMapUnit = 1.0e-3;
    } else if (mapUnit === 'inch') {
      meterPerMapUnit = 1 / 2.5399999918e-2;
    } else if (mapUnit === 'feet') {
      meterPerMapUnit = 0.3048;
    }

    return meterPerMapUnit;
  },
  _getDefaultProj4ScalesByBounds: function _getDefaultProj4ScalesByBounds(bounds) {
    if (!bounds) {
      return [];
    }

    var boundsSize = bounds.getSize();
    var extendsSize = Math.max(boundsSize.x, boundsSize.y);
    var resolution = extendsSize / 256;
    var scales = [];
    var maxZoom = 23;

    for (var i = 0; i < maxZoom; i++) {
      scales[i] = Math.pow(2, i) / resolution;
    }

    return scales;
  }
});
var crs = function crs(srsCode, options) {
  return new CRS(srsCode, options);
};
external_L_default.a.Proj.CRS = crs;

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ FeatureManager; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ TipPopup["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ Geolocation; });

// UNUSED EXPORTS: featureManager, geolocation, WMTSUtil

// EXTERNAL MODULE: external "L"
var external_L_ = __webpack_require__(0);
var external_L_default = /*#__PURE__*/__webpack_require__.n(external_L_);

// EXTERNAL MODULE: ./src/core/Base.js
var Base = __webpack_require__(1);

// CONCATENATED MODULE: ./src/util/FeatureManager.js


var FeatureManager = external_L_default.a.Class.extend({
  options: {
    map: null,
    featureGroup: null,
    classifyList: null
  },
  initialize: function initialize(options) {
    this.options = external_L_default.a.setOptions(this, options);
    this.options.classifyList = {};
    this.options.featureGroup = options.featureGroup || external_L_default.a.featureGroup();
    this.options.map.addLayer(this.options.featureGroup);

    this._initEvents();
  },
  _initEvents: function _initEvents() {
    var map = this.options.map;
    this.options.featureGroup.on("click", function (e) {
      this.resetFeatureIcon();

      if (e.layer.onFeatureClick) {
        e.layer.onFeatureClick(e.layer);
      }

      if (e.layer.options && e.layer.options.hightIcon) {
        e.layer.setIcon(e.layer.options.hightIcon);
      }
    }, this);
    this.options.featureGroup.on("mouseover", function (e) {
      if (e.layer.options && e.layer.options.hightIcon) {
        e.layer.setIcon(e.layer.options.hightIcon);
      }

      if (e.layer.onFeatureOver) {
        e.layer.onFeatureOver(e.layer);
      }
    });
    this.options.featureGroup.on("mouseout", function (e) {
      var popup = e.layer.getPopup();
      var _popup = map._popup;

      if (!(popup && _popup && popup == _popup)) {
        if (e.layer.options && e.layer.options.unhightIcon) {
          e.layer.setIcon(e.layer.options.unhightIcon);
        }
      }

      if (e.layer.onFeatureOut) {
        e.layer.onFeatureOut(e.layer);
      }
    });
    this.options.featureGroup.on("popupclose", function (e) {
      if (e.layer.options && e.layer.options.unhightIcon) {
        e.layer.setIcon(e.layer.options.unhightIcon);
      }
    }, this);
  },

  /**
   * 创建要素分类
   * @method L.FeatureManager#createFeatureSort
   * @param {String} sort 			- 要素分类
   * @param {Object} options 		- 要素事件回调函数
   * @property {object}  options   - 回调函数定义
   * @property {Function}  options.onFeatureClick   - click事件
   * @property {Function}  options.onFeatureOver    - mouseover事件
   * @property {Function}  options.onFeatureOut     - mouseout事件
   *
   */
  createFeatureSort: function createFeatureSort(sort, options) {
    options = options || {};
    var onFeatureClick = options.onFeatureClick;
    var onFeatureOver = options.onFeatureOver;
    var onFeatureOut = options.onFeatureOut;
    var params = {
      features: [],
      onFeatureClick: onFeatureClick,
      onFeatureOver: onFeatureOver,
      onFeatureOut: onFeatureOut
    };
    this.options.classifyList[sort] = params;
  },

  /**
   * 向类别中添加要素，要素添加到类别后将在要素的外部属性中加上类型标识
   * @method L.FeatureManager#addFeatures
   * @param {L.Marker[]} features - 添加的要素数组 L.Marker 集合。
   * @param {String} sort - 要素类别
   * @param {Boolean} isAppend - 是否追加要素
   */
  addFeatures: function addFeatures(features, sort, isAppend) {
    if (!sort || typeof sort != "string") {
      return;
    }

    if (!(features instanceof Array)) {
      features = [features];
    }

    var classifyList = this.options.classifyList;

    if (classifyList[sort]) {
      features = this._processFeatures(features, sort);

      if (!isAppend) {
        classifyList[sort].features = features;
      } else {
        classifyList[sort].features = classifyList[sort].features.concat(features);
      }
    }
  },
  _processFeatures: function _processFeatures(features, sort) {
    var mapping = this.options.classifyList[sort];

    for (var i = 0; i < features.length; i++) {
      var feature = features[i];
      feature.sort = sort;
      feature.onFeatureClick = mapping.onFeatureClick;
      feature.onFeatureOver = mapping.onFeatureOver;
      feature.onFeatureOut = mapping.onFeatureOut;
    }

    return features;
  },

  /**
   * 将要素绘制到地图
   * @method L.FeatureManager#drawFeaturesToMap
   * @param {(L.Marker[]|String)} content - 添加的要素数组 L.Marker 集合或者要素分类。
   */
  drawFeaturesToMap: function drawFeaturesToMap(content) {
    var features;

    if (typeof content == "string") {
      var sort = content || "default";

      if (this.options.classifyList[sort]) {
        features = this.getFeatures(sort);
      }
    }

    if (content instanceof Array) {
      features = content;
    }

    if (!features) {
      return false;
    }

    for (var i = 0; i < features.length; i++) {
      if (features[i].options && features[i].options.unhightIcon) {
        features[i].setIcon(features[i].options.unhightIcon);
      }

      this.options.featureGroup.addLayer(features[i]);
    }
  },

  /**
   * 根据分类删除该分类的要素
   * @method L.FeatureManager#clearFeaturesFromMap
   * @param {String} sort - 要素类别
   */
  clearFeaturesFromMap: function clearFeaturesFromMap(sort) {
    if (!sort || typeof sort != "string") {
      return;
    }

    var features;
    var mapping = this.options.classifyList[sort];

    if (sort == "allType") {
      features = this.options.featureGroup.getLayers();
    } else {
      features = mapping ? mapping.features : [];
    }

    if (features) {
      for (var i = 0; i < features.length; i++) {
        this.options.featureGroup.removeLayer(features[i]);
      }

      this.options.classifyList[sort].features = [];
    }
  },

  /**
   * 根据分类获取分类的要素
   * @method L.FeatureManager#getFeatures
   * @param {String} sort - 要素类别
   * @return {L.Marker[]} features - 添加的要素数组
   */
  getFeatures: function getFeatures(sort) {
    if (!sort || typeof sort != "string") {
      return null;
    }

    if (this.options.classifyList[sort]) {
      return this.options.classifyList[sort].features;
    } else {
      return null;
    }
  },

  /**
   * 要素重置为默认样式
   * @method L.FeatureManager#resetFeatureIcon
   */
  resetFeatureIcon: function resetFeatureIcon() {
    this.options.featureGroup.eachLayer(function (layer) {
      if (layer.options && layer.options.unhightIcon) {
        layer.setIcon(layer.options.unhightIcon);
      }
    });
  }
});
var featureManager = function featureManager(options) {
  return new FeatureManager(options);
};
external_L_default.a.geoway.featureManager = featureManager;
external_L_default.a.geoway.FeatureManager = FeatureManager;
external_L_default.a.FeatureManager = FeatureManager;
external_L_default.a.featureManager = featureManager;
// EXTERNAL MODULE: ./src/util/TipPopup.js
var TipPopup = __webpack_require__(15);

// CONCATENATED MODULE: ./src/util/Geolocation.js


var Geolocation = external_L_default.a.Class.extend({
  options: {
    enableHighAccuracy: false,
    timeout: 5000,
    maximumAge: 3000
  },
  initialize: function initialize(options) {
    external_L_default.a.setOptions(this, options);
  },

  /**
   * 获取当前位置信息
   * @method L.Geolocation#getCurrentPosition
   * @param {Function} callback - 回调函数
   * @param {L.Geolocation.options} options - 位置定位参数
   */
  getCurrentPosition: function getCurrentPosition(callback, options) {
    external_L_default.a.setOptions(this, options);

    if (navigator.geolocation) {
      var locationSuccess = function locationSuccess(position) {
        var coords = position.coords;
        var latlng = new external_L_default.a.LatLng(coords.latitude, coords.longitude);
        var result = {
          latlng: latlng,
          status: "ok"
        };
        callback(result);
      };

      var locationError = function locationError(error) {
        var errorMsg = "";

        switch (error.code) {
          case error.PERMISSION_DENIED:
            errorMsg = "User denied the request for Geolocation.";
            break;

          case error.POSITION_UNAVAILABLE:
            errorMsg = "Location information is unavailable.";
            break;

          case error.TIMEOUT:
            errorMsg = "The request to get user location timed out.";
            break;

          case error.UNKNOWN_ERROR:
            errorMsg = "An unknown error occurred.";
            break;
        }

        var result = {
          latlng: null,
          status: "error",
          errorMsg: errorMsg
        };
        callback(result);
      };

      navigator.geolocation.getCurrentPosition(locationSuccess, locationError, this.options);
    } else {
      var errorMsg = "Your browser does not support Geolocation!";
      var result = {
        latlng: null,
        status: "error",
        errorMsg: errorMsg
      };
      callback(result);
    }
  }
});
var geolocation = function geolocation(options) {
  return new Geolocation(options);
};
external_L_default.a.geoway.geolocation = geolocation;
external_L_default.a.geoway.Geolocation = Geolocation;
external_L_default.a.Geolocation = Geolocation;
// EXTERNAL MODULE: ./src/util/FetchRequest.js
var FetchRequest = __webpack_require__(3);

// EXTERNAL MODULE: ./src/format/index.js + 9 modules
var src_format = __webpack_require__(13);

// CONCATENATED MODULE: ./src/util/WMTSUtil.js



var WMTSUtil = {
  getCapabilities: function getCapabilities(url, fnSuccess, fnFaisule) {
    var param = {
      SERVICE: "WMTS",
      VERSION: "1.0.0",
      REQUEST: "GetCapabilities"
    };
    FetchRequest["a" /* default */].get(url, param).then(function (result) {
      try {
        var doc = result.bodyText;
        var format = new src_format["d" /* WMTSCapabilities */]();
        var capabilities = format.read(doc);

        if (fnSuccess) {
          fnSuccess(capabilities);
        }
      } catch (e) {
        if (fnFaisule) {
          fnFaisule(e);
        }
      }
    })["catch"](function (e) {
      fnFaisule(e);
    });
  }
};
external_L_default.a.geoway.WMTSUtil = WMTSUtil;
external_L_default.a.WMTSUtil = WMTSUtil;
// CONCATENATED MODULE: ./src/util/index.js









/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TRouteResultFormat; });
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _Format_XML__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);



var TRouteResultFormat = _Format_XML__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].extend({
  /**
   * @class 驾车查询结果解析类
   * @description 本类供内部调用，用户一般无需使用。
   * @constructor
   * @param {Object} data
   * @ignore
   */
  initialize: function initialize(options) {
    _Format_XML__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.initialize.apply(this, [options]);
  },

  /**
   * 读入服务端响应的XML内容并解析为JSON对象返回
   * @method L.Format.TRouteResultFormat#read
   * @param {String} data 服务端响应的XML
   * @return {Object} obj
   */
  read: function read(data) {
    var result = null;

    if (typeof data == "string") {
      data = _Format_XML__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.read.apply(this, [data]);
    }

    if (data && data.nodeType == 9) {
      result = {};
      var nodes = data.getElementsByTagName("result")[0].childNodes;

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var nodeName = node.nodeName;

        if (this._resultPaser[nodeName]) {
          this._resultPaser[nodeName](node, result);
        }
      }
    }

    return result;
  },
  _resultPaser: {
    "parameters": function parameters(node, obj) {
      var nodes = node.childNodes;
      obj.parameters = {};

      for (var i = 0; i < nodes.length; i++) {
        var _node = nodes[i];

        if (_node.nodeName == "#text") {
          continue;
        }

        obj.parameters[_node.nodeName] = _node.text || _node.textContent;
      }
    },
    "routes": function routes(node, obj) {
      var attributes = node.attributes;
      var nodes = node.childNodes;
      obj.routes = {};

      for (var i = 0; i < attributes.length; i++) {
        var attribute = attributes[i];

        if (attribute.nodeName == "#text") {
          continue;
        }

        obj.routes[attribute.nodeName] = attribute.text || attribute.textContent;
      }

      for (var j = 0; j < nodes.length; j++) {
        if (!obj.routes.items) {
          obj.routes.items = [];
        }

        var _node = nodes[j];

        if (_node.nodeName == "#text") {
          continue;
        }

        var item = {};
        pase_item_label(_node, item);
        obj.routes.items.push(item);
      }

      function pase_item_label(node, obj) {
        var nodes = node.childNodes;

        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].nodeName == "#text") {
            continue;
          }

          obj[nodes[i].nodeName] = nodes[i].text || nodes[i].textContent;
        }
      }
    },
    "simple": function simple(node, obj) {
      obj.simple = {};
      var nodes = node.childNodes;

      for (var i = 0; i < nodes.length; i++) {
        if (!obj.simple.items) {
          obj.simple.items = [];
        }

        var _node = nodes[i];

        if (_node.nodeName == "#text") {
          continue;
        }

        var item = {};
        pase_item_label(_node, item);
        obj.simple.items.push(item);
      }

      function pase_item_label(node, obj) {
        var nodes = node.childNodes;

        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].nodeName == "#text") {
            continue;
          }

          obj[nodes[i].nodeName] = nodes[i].text || nodes[i].textContent;
        }
      }
    },
    "distance": function distance(node, obj) {
      obj.distance = node.text || node.textContent;
    },
    "duration": function duration(node, obj) {
      obj.duration = node.text || node.textContent;
    },
    "routelatlon": function routelatlon(node, obj) {
      obj.routelatlon = node.text || node.textContent;
    },
    "mapinfo": function mapinfo(node, obj) {
      obj.mapinfo = {};
      var nodes = node.childNodes;

      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].nodeName == "#text") {
          continue;
        }

        obj.mapinfo[nodes[i].nodeName] = nodes[i].text || nodes[i].textContent;
      }
    }
  }
});
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.geoway.format.TRouteResultFormat = TRouteResultFormat;
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Format = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Format ? leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Format : {};
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Format.TRouteResultFormat = TRouteResultFormat;

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TRouteResult; });
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _core_Base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _util_Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);



var TRouteResult = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Class.extend({
  data: null,
  //--parameters: null,
  orig: null,
  dest: null,
  startFeature: null,
  endFeature: null,
  routes: null,
  segmentFeatures: null,
  distance: null,
  duration: null,
  routelatlon: null,
  initialize: function initialize(data) {
    if (data) {
      this.data = data;

      for (var item in data) {
        if (this._resultPaser[item]) {
          var fn = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Util.bind(this._resultPaser[item], this);
          fn(data[item]);
        }
      }
    }
  },
  lineStringToGeometry: function lineStringToGeometry(str) {
    var points = [];
    var lineArr = str.split(";");

    for (var i = 0; i < lineArr.length; i++) {
      if (lineArr[i] == "") {
        continue;
      }

      var lonlatArr = lineArr[i].split(",");
      var point = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.LatLng(lonlatArr[1], lonlatArr[0]);
      points.push(point);
    }

    var lineString = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Polyline(points);
    return lineString;
  },
  _resultPaser: {
    "parameters": function parameters(data) {
      var origs = data.orig.split(",");
      var dests = data.dest.split(",");
      this.start = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.LatLng(origs[1], origs[0]);
      this.end = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.LatLng(dests[1], dests[0]);
      var p1 = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.LatLng(this.start.lat, this.start.lng);
      this.startFeature = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Marker(p1);
      var p2 = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.LatLng(this.end.lat, this.end.lng);
      this.endFeature = new leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Marker(p2);
    },
    "routes": function routes(data) {
      this.routes = data;
    },
    "simple": function simple(data) {
      this.simple = data;

      if (!data.items) {
        return;
      }

      var items = data.items;
      var features = [];

      for (var i = 0; i < items.length; i++) {
        var linestring = this.lineStringToGeometry(items[i].streetLatLon);
        leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.setOptions(linestring, items[i]);
        features.push(linestring);
      }

      this.simple.segmentFeatures = features;
    },
    "distance": function distance(data) {
      this.distance = data;
    },
    "duration": function duration(data) {
      this.duration = data;
    },
    "routelatlon": function routelatlon(data) {
      this.routelatlon = data;
    },
    "mapinfo": function mapinfo(data) {
      this.mapinfo = data;
    }
  }
});
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.geoway.format.TRouteResult = TRouteResult;
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Format = leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Format ? leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Format : {};
leaflet__WEBPACK_IMPORTED_MODULE_0___default.a.Format.TRouteResult = TRouteResult;

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./src/util/gistools/GridFilter.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var GridFilter = /*#__PURE__*/function () {
  /**
   *
   * @param tilesize 瓦片大小
   * @param cellsize 小正方形网格的宽
   * @param buffer  外扩多少像素
   * @param maxPerCell  小正方形中允许放多小个注记
   */
  function GridFilter(tilesize, cellsize, buffer, maxPerCell) {
    _classCallCheck(this, GridFilter);

    var n = tilesize / cellsize;
    var padding = buffer / cellsize;
    this.maxPerCell = maxPerCell == null ? 1 : maxPerCell;
    this.cells = {};
    this.d = n + 2 * padding;
    this.n = n;
    this.padding = padding;
    this.scale = n / tilesize;
    var p = padding / n * tilesize;
    this.min = -p;
    this.max = tilesize + p;
  }
  /**
   *  是否能放下指定的点
   * @param x
   * @param y
   * @returns {boolean}
   */


  _createClass(GridFilter, [{
    key: "filter",
    value: function filter(x, y) {
      if (x < this.min || x > this.max || y < this.min || y > this.max) {
        return false;
      }

      var cx = this.convertToCellCoord(x);
      var cy = this.convertToCellCoord(y);
      var cellIndex = this.d * cy + cx; //console.log('格网号：'+cellIndex);

      if (this.cells[cellIndex] >= this.maxPerCell) {
        return false;
      } else {
        var i = this.cells[cellIndex];

        if (i == null) {
          this.cells[cellIndex] = 1;
        } else {
          this.cells[cellIndex] = i++;
        }

        return true;
      }
    }
    /**
     *  是否能放下指定的box
     * @param box
     * @returns {boolean}
     */

  }, {
    key: "filterByBox",
    value: function filterByBox(box) {
      var startX = this.convertToCellCoord(box[0]);
      var endX = this.convertToCellCoord(box[2]);
      var startY = this.convertToCellCoord(box[1]);
      var endY = this.convertToCellCoord(box[3]);

      for (var i = startX; i <= endX; i++) {
        for (var j = startY; j <= endY; j++) {
          var cellIndex = this.d * j + i; //如果任意一个小格网被占用，则本box不能放下

          if (this.cells[cellIndex]) {
            return false;
          }
        }
      } //标识小格网被占用


      for (var _i = startX; _i <= endX; _i++) {
        for (var _j = startY; _j <= endY; _j++) {
          var _cellIndex = this.d * _j + _i;

          this.cells[_cellIndex] = 1;
        }
      }

      return true;
    }
  }, {
    key: "clean",
    value: function clean() {
      this.cells = {};
      this.saveCount = 0;
    }
  }, {
    key: "convertToCellCoord",
    value: function convertToCellCoord(x) {
      return Math.max(0, Math.min(this.d - 1, Math.floor(x * this.scale) + this.padding));
    }
  }]);

  return GridFilter;
}();

/* harmony default export */ var gistools_GridFilter = (GridFilter);
// EXTERNAL MODULE: ./src/layer/label/avoid/Util.js
var Util = __webpack_require__(7);

// EXTERNAL MODULE: ./src/util/gistools/GisTools.js
var GisTools = __webpack_require__(8);

// CONCATENATED MODULE: ./src/layer/label/avoid/GridFilterLabel.js
function GridFilterLabel_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GridFilterLabel_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function GridFilterLabel_createClass(Constructor, protoProps, staticProps) { if (protoProps) GridFilterLabel_defineProperties(Constructor.prototype, protoProps); if (staticProps) GridFilterLabel_defineProperties(Constructor, staticProps); return Constructor; }





var GridFilterLabel_GridFilterLabel = /*#__PURE__*/function () {
  function GridFilterLabel() {
    GridFilterLabel_classCallCheck(this, GridFilterLabel);
  }

  GridFilterLabel_createClass(GridFilterLabel, null, [{
    key: "fristFilter",

    /**
     *  第一次初步过滤
     * @param pointFeatures 点注记集合
     * @param lineFeatures 线注记集合
     * @param styleMap 样式map
     * @param ableWeight 全局是否权重避让
     * @param needSort 第一次过滤是否需要排序
     * @param tilesize 瓦片大小
     * @param cellsize 每个小网格宽度
     * @param buffer 外扩多大像素
     * @param maxPerCell 每个网格内最多放多少个点
     * @returns {{pointFeatures: Array, lineFeatures: Array, importantFeatures: Array}}
     */
    value: function fristFilter(pointFeatures, lineFeatures, styleMap, ableWeight, needSort, tilesize, cellsize, buffer, maxPerCell) {
      if (ableWeight && needSort) {
        Util["a" /* default */].sort(pointFeatures);
        Util["a" /* default */].sort(lineFeatures);
      } //第一次过滤


      pointFeatures = GridFilterLabel.fristFilterStart(pointFeatures, tilesize, cellsize, buffer, maxPerCell);
      lineFeatures = GridFilterLabel.fristFilterStart(lineFeatures, tilesize, cellsize, buffer, maxPerCell);
      return {
        pointFeatures: pointFeatures,
        lineFeatures: lineFeatures
      };
    }
    /**
     *  第二次初步过滤
     * @param pointFeatures 点注记集合
     * @param lineFeatures 线注记集合
     * @param styleMap 样式map
     * @param ableWeight 全局是否权重避让
     * @param needSort 第二次过滤是否需要排序
     * @param tilesize 全局画布最大宽
     * @param cellsize 每个小网格宽度
     * @param buffer 外扩多大像素
     * @param maxPerCell 每个网格内最多放多少个点
     * @returns {{pointFeatures: Array, lineFeatures: Array, importantFeatures: Array}}
     */

  }, {
    key: "scendFilter",
    value: function scendFilter(pointFeatures, lineFeatures, styleMap, ableWeight, needSort, tilesize, cellsize, buffer, maxPerCell) {
      if (ableWeight && needSort) {
        Util["a" /* default */].sort(pointFeatures);
        Util["a" /* default */].sort(lineFeatures);
      } //第二次过滤


      pointFeatures = GridFilterLabel.scendFilterStart(pointFeatures, tilesize, 16, buffer);
      lineFeatures = GridFilterLabel.scendFilterStart(lineFeatures, tilesize, 16, buffer);
      var returnFeatures = [];
      returnFeatures = returnFeatures.concat(pointFeatures);
      returnFeatures = returnFeatures.concat(lineFeatures);
      return returnFeatures;
    } // /**
    //  * 将注记分类为点注记，线注记和重要的注记
    //  * @param labelFeatures
    //  * @param styleMap
    //  * @returns {{pointFeatures: Array, lineFeatures: Array, importantFeatures: Array}}
    //  */
    // static getPointLineFeatures(labelFeatures,styleMap){
    //     let pointFeatures = [];
    //     let lineFeatures = [];
    //     //所有需要保留不参与第二次过滤的注记
    //     let importantFeatures = [];
    //     //分离出点注记和线注记
    //     for(let i = 0;i<labelFeatures.length;i++){
    //         let feature = labelFeatures[i];
    //         let style = styleMap[feature.styleId];
    //         //如果不是重要的必须显示要素
    //         if(style.isImportant){
    //             importantFeatures.push(feature);
    //         }else{
    //             let radius = 0;
    //             let p = [0,0];
    //             if(feature.type == 1){
    //                 if(style.pointBoxDisance){
    //                     radius = style.pointBoxDisance*0.5;
    //                     p = feature.datas[0];
    //                     feature.filterBox = [p[0]-radius,p[1]-radius,p[0]+radius,p[1]+radius];
    //                     pointFeatures.push(feature);
    //                 }
    //             }
    //
    //             if(feature.type == 2){
    //                 if(feature.lineType == 'text'){
    //                     //线文字注记默认外扩距离设置为100
    //                     radius = 50;
    //                     let centerIndex = Math.floor(feature.datas.length / 2);
    //                     p = feature.datas[centerIndex][0];
    //                     // if(style.lineTextBoxDisance){
    //                     //     radius = style.lineTextBoxDisance*0.5;
    //                     // }
    //                 }
    //                 if(feature.lineType == 'code'){
    //                     p = feature.datas[0][0];
    //                     if(style.lineCodeBoxDisance){
    //                         radius = style.lineCodeBoxDisance*0.5;
    //                     }
    //                 }
    //             }
    //
    //             //设置外扩距离的注记才进行第二次过滤
    //             if(radius > 0){
    //                 feature.filterBox = [p[0]-radius,p[1]-radius,p[0]+radius,p[1]+radius];
    //                 lineFeatures.push(feature);
    //             }else{
    //                 importantFeatures.push(feature);
    //             }
    //         }
    //     }
    //
    //     return {pointFeatures:pointFeatures,lineFeatures:lineFeatures,importantFeatures:importantFeatures};
    // }

    /**
     *  移除瓦片外的点注记
     * @param features
     * @param tilesize
     */

  }, {
    key: "removeTileOutPointFeatures",
    value: function removeTileOutPointFeatures(features, tileSize) {
      var newFeatures = [];

      for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        var pt = feature.centerPoint;

        if (pt[0] >= 0 && pt[0] <= tileSize && pt[1] >= 0 && pt[1] <= tileSize) {
          newFeatures.push(feature);
        }
      }

      return newFeatures;
    }
    /**
     *  移除瓦片外的线注记
     * @param features
     * @param tilesize
     */

  }, {
    key: "removeTileOutLineFeatures",
    value: function removeTileOutLineFeatures(features, tileSize) {
      var newFeatures = [];

      for (var i = 0; i < features.length; i++) {
        var feature = features[i];

        for (var j = 0; j < feature.datas.length; j++) {
          var pt = feature.datas[j][0];

          if (pt[0] >= 0 && pt[0] <= tileSize && pt[1] >= 0 && pt[1] <= tileSize) {
            newFeatures.push(feature);
            break;
          }
        }
      }

      return newFeatures;
    }
    /**
     *  注记第一次初步格网过滤
     * @param features
     * @param tilesize 瓦片大小
     * @param cellsize 小正方形网格的宽
     * @param buffer  外扩多少像素
     * @param maxPerCell  小正方形中允许放多小个注记
     * @returns {Array}
     */

  }, {
    key: "fristFilterStart",
    value: function fristFilterStart(features, tilesize, cellsize, buffer, maxPerCell) {
      var gridFilter = new gistools_GridFilter(tilesize, cellsize, buffer, maxPerCell);
      var returnFeatures = [];

      for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        var bool = gridFilter.filter(feature.centerPoint[0], feature.centerPoint[1]);

        if (bool) {
          returnFeatures.push(feature);
        }
      }

      return returnFeatures;
    }
    /**
     *  注记第二次box格网过滤
     * @param features
     * @param tilesize 瓦片大小
     * @param cellsize 小正方形网格的宽
     * @param buffer  外扩多少像素
     * @param maxPerCell  小正方形中允许放多小个注记
     * @returns {Array}
     */

  }, {
    key: "scendFilterStart",
    value: function scendFilterStart(features, tilesize, cellsize, buffer) {
      var gridFilter = new gistools_GridFilter(tilesize, cellsize, buffer, 1);
      var returnFeatures = [];

      for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        var bool = gridFilter.filterByBox(feature.filterBox);

        if (bool) {
          returnFeatures.push(feature);
        }
      }

      return returnFeatures;
    }
    /**
     *  第三次过滤，注记去重
     * @param features
     * @param tileSize
     * @returns {Array}
     */

  }, {
    key: "threeFilter",
    value: function threeFilter(features, styleMap, tileSize) {
      var fs = GridFilterLabel.getImportantOtherFeatures(features, styleMap);
      var labelMap = Util["a" /* default */].groupByLabel(fs.otherFeatures);
      var returnFeatures = [];
      var box2 = [0, 0, tileSize, tileSize];

      for (var label in labelMap) {
        var labelArr = labelMap[label];

        if (labelArr.length == 1) {
          returnFeatures.push(labelArr[0]);
        } else {
          var inBoxFeatures = [];

          for (var i = 0; i < labelArr.length; i++) {
            var feature = labelArr[i];

            if (feature.type == 1) {
              if (GisTools["a" /* default */].isInBox(feature.box, box2)) {
                inBoxFeatures.push(feature);
              } else {
                returnFeatures.push(feature);
              }
            }

            if (feature.type == 2) {
              var isInBox = true;

              for (var j = 0; j < feature.boxs.length; j++) {
                var box = feature.boxs[j];

                if (!GisTools["a" /* default */].isInBox(box, box2)) {
                  isInBox = false;
                  break;
                }
              }

              if (isInBox) {
                inBoxFeatures.push(feature);
              } else {
                returnFeatures.push(feature);
              }
            }
          }

          if (inBoxFeatures.length > 0) {
            //按照权重排序
            inBoxFeatures = Util["a" /* default */].sortPrimaryId(inBoxFeatures); //保留第一个
            // returnFeatures.push(inBoxFeatures[0]);

            returnFeatures = returnFeatures.concat(GridFilterLabel.distinctFeatures(inBoxFeatures, styleMap));
          }
        }
      }

      returnFeatures = returnFeatures.concat(fs.importantFeatures);
      return returnFeatures;
    }
  }, {
    key: "distinctFeatures",
    value: function distinctFeatures(features, styleMap) {
      var feature = features[0];
      var field = '';

      if (feature.type == 1) {
        field = 'distance';
      }

      if (feature.type == 2) {
        if (feature.lineType == 'text') {
          field = 'lineTextDistance';
        }

        if (feature.lineType == 'code') {
          field = 'lineCodeDistance';
        }
      }

      var fs = [];
      fs.push(features[0]);

      for (var i = 0; i < features.length - 1; i++) {
        var _feature = features[i];

        if (_feature.hidden == true) {
          continue;
        }

        var nextFeature = features[i + 1]; //求两个点注记之间的距离

        var distance = GridFilterLabel.getDistance(_feature.centerPoint, nextFeature.centerPoint);
        var style = styleMap[_feature.styleId];
        var d = style[field] ? style[field] : 0;

        if (distance < d) {
          nextFeature.hidden = true;
        } else {
          fs.push(nextFeature);
        }
      }

      return fs;
    }
    /**
     * 求两点之间的距离
     */

  }, {
    key: "getDistance",
    value: function getDistance(p1, p2) {
      var calX = p2[0] - p1[0];
      var calY = p2[1] - p1[1];
      return Math.pow(calX * calX + calY * calY, 0.5);
    }
    /**
     *  将注记分为重要注记和非重要注记
     * @param features
     * @param styleMap
     */

  }, {
    key: "getImportantOtherFeatures",
    value: function getImportantOtherFeatures(features, styleMap) {
      var importantFeatures = [];
      var otherFeatures = [];

      for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        var style = styleMap[feature.styleId];

        if (style.isImportant) {
          importantFeatures.push(feature);
        } else {
          otherFeatures.push(feature);
        }
      }

      return {
        otherFeatures: otherFeatures,
        importantFeatures: importantFeatures
      };
    }
  }]);

  return GridFilterLabel;
}();

/* harmony default export */ var avoid_GridFilterLabel = __webpack_exports__["a"] = (GridFilterLabel_GridFilterLabel);

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Proj4Leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _Proj4Leaflet__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _Proj4Leaflet__WEBPACK_IMPORTED_MODULE_0__["b"]; });




/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__(44);

var ieee754 = __webpack_require__(45);

var isArray = __webpack_require__(46);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function foo() {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18)))

/***/ }),
/* 27 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by kongjian on 2017/5/1.
 */
var LabelDrawer = /*#__PURE__*/function () {
  function LabelDrawer(layerDataMap, styleMap, level) {
    _classCallCheck(this, LabelDrawer);

    this.layerDataMap = layerDataMap;
    this.level = level;
    this.styleMap = styleMap;
    this.propertyGetterMap = {};
  }

  _createClass(LabelDrawer, [{
    key: "getLayer",
    value: function getLayer(layername) {
      this.layerDatas = {};
      var data = this.layerDataMap[layername];

      if (data == null || data.features == null) {
        return this;
      }

      this.propertyGetterMap[layername] = this.getProperty(data.fieldsConfig);
      this.layerDatas[layername] = data;
      return this;
    }
  }, {
    key: "getAllLayer",
    value: function getAllLayer() {
      this.layerDatas = this.layerDataMap;

      for (var layername in this.layerDataMap) {
        this.propertyGetterMap[layername] = this.getProperty(this.layerDataMap[layername].fieldsConfig);
      }

      return this;
    }
  }, {
    key: "getGroupLayer",
    value: function getGroupLayer(layername, value) {
      this.layerDatas = {};
      var valueArr = value.split(',');
      var length = valueArr.length;

      if (length == 0) {
        return this;
      }

      var data = this.layerDataMap[layername];

      if (data == null || data.features == null) {
        return this;
      }

      this.propertyGetterMap[layername] = this.getProperty(data.fieldsConfig);
      this.layerDatas[layername] = data;
      return this;
    }
  }, {
    key: "getProperty",
    value: function getProperty(fieldsConfig) {
      var propertyConfig = {};
      var idIndex = 0;

      for (var i = 0; i < fieldsConfig.length; i++) {
        if (fieldsConfig[i].id == 'true' || fieldsConfig[i].id == true) {
          idIndex = fieldsConfig[i].index;
        }

        propertyConfig[fieldsConfig[i].name] = parseInt(fieldsConfig[i].index);
      }

      return {
        propertyConfig: propertyConfig,
        idIndex: idIndex
      };
    }
  }, {
    key: "setStyle",
    value: function setStyle(fn) {
      var _this = this;

      var _loop = function _loop(layername) {
        var layerData = _this.layerDatas[layername];
        var propertyGetter = _this.propertyGetterMap[layername];

        var _loop2 = function _loop2(i) {
          var feature = layerData.features[i];

          var get = function get(key) {
            return feature[1][propertyGetter.propertyConfig[key]];
          };

          var style = fn.call({}, _this.level, get);

          if (style && style.show == true) {
            if (!_this.styleMap[style._id]) {
              _this.styleMap[style._id] = style;
            }

            feature.avoidWeight = _this.getWeight(style, feature, propertyGetter, 'avoidWeight', 'avoidField');

            if (feature[0] != 'POINT') {
              if (style.hasOwnProperty('codeAvoidWeight') && style.hasOwnProperty('codeAvoidField')) {
                feature.codeAvoidWeight = _this.getWeight(style, feature, propertyGetter, 'codeAvoidWeight', 'codeAvoidField');
                feature.codeAvoidWeight = feature.codeAvoidWeight == feature.avoidWeight ? feature.avoidWeight + 1 : feature.codeAvoidWeight;
              } else {
                feature.codeAvoidWeight = feature.avoidWeight + 1;
              }

              if (style.hasOwnProperty('arrowAvoidWeight') && style.hasOwnProperty('arrowAvoidField')) {
                feature.arrowAvoidWeight = _this.getWeight(style, feature, propertyGetter, 'arrowAvoidWeight', 'arrowAvoidField');
                feature.arrowAvoidWeight = feature.arrowAvoidWeight == feature.avoidWeight ? feature.avoidWeight - 1 : feature.arrowAvoidWeight;
                feature.arrowAvoidWeight = feature.arrowAvoidWeight == feature.codeAvoidWeight ? feature.codeAvoidWeight - 1 : feature.arrowAvoidWeight;
              } else {
                feature.arrowAvoidWeight = feature.avoidWeight - 1;
              }
            }

            feature.styleId = style._id;
          }
        };

        for (var i = 0; i < layerData.features.length; i++) {
          _loop2(i);
        }
      };

      for (var layername in this.layerDatas) {
        _loop(layername);
      }
    }
  }, {
    key: "setGlobalStyle",
    value: function setGlobalStyle(fn) {
      this.globalStyle = fn.call({});
    }
  }, {
    key: "getWeight",
    value: function getWeight(style, feature, propertyGetter, weightValueStyle, weightField) {
      var weight = feature[1][propertyGetter.propertyConfig[style[weightField]]];

      if (weight) {
        weight = parseInt(weight);

        if (isNaN(weight)) {
          weight = 0;
        }
      } else {
        weight = 0;
      }

      if (weight == 0) {
        if (style[weightValueStyle]) {
          return style[weightValueStyle];
        }
      }

      return weight;
    }
  }, {
    key: "draw",
    value: function draw() {}
  }]);

  return LabelDrawer;
}();

module.exports = LabelDrawer;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, Buffer) {// The MIT License (MIT)
//
// Copyright (c) 2016 Zhipeng Jia
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNode() {
  if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object') {
    if (_typeof(process.versions) === 'object') {
      if (typeof process.versions.node !== 'undefined') {
        return true;
      }
    }
  }

  return false;
}

function isUint8Array(object) {
  return object instanceof Uint8Array && (!isNode() || !Buffer.isBuffer(object));
}

function isArrayBuffer(object) {
  return object instanceof ArrayBuffer;
}

function isBuffer(object) {
  if (!isNode()) {
    return false;
  }

  return Buffer.isBuffer(object);
}

var SnappyDecompressor = __webpack_require__(47).SnappyDecompressor;

var SnappyCompressor = __webpack_require__(48).SnappyCompressor;

var TYPE_ERROR_MSG = 'Argument compressed must be type of ArrayBuffer, Buffer, or Uint8Array';

function uncompress(compressed) {
  if (!isUint8Array(compressed) && !isArrayBuffer(compressed) && !isBuffer(compressed)) {
    throw new TypeError(TYPE_ERROR_MSG);
  }

  var uint8Mode = false;
  var arrayBufferMode = false;

  if (isUint8Array(compressed)) {
    uint8Mode = true;
  } else if (isArrayBuffer(compressed)) {
    arrayBufferMode = true;
    compressed = new Uint8Array(compressed);
  }

  var decompressor = new SnappyDecompressor(compressed);
  var length = decompressor.readUncompressedLength();

  if (length === -1) {
    throw new Error('Invalid Snappy bitstream');
  }

  var uncompressed, uncompressedView;

  if (uint8Mode) {
    uncompressed = new Uint8Array(length);

    if (!decompressor.uncompressToBuffer(uncompressed)) {
      throw new Error('Invalid Snappy bitstream');
    }
  } else if (arrayBufferMode) {
    uncompressed = new ArrayBuffer(length);
    uncompressedView = new Uint8Array(uncompressed);

    if (!decompressor.uncompressToBuffer(uncompressedView)) {
      throw new Error('Invalid Snappy bitstream');
    }
  } else {
    uncompressed = Buffer.alloc(length);

    if (!decompressor.uncompressToBuffer(uncompressed)) {
      throw new Error('Invalid Snappy bitstream');
    }
  }

  return uncompressed;
}

function compress(uncompressed) {
  if (!isUint8Array(uncompressed) && !isArrayBuffer(uncompressed) && !isBuffer(uncompressed)) {
    throw new TypeError(TYPE_ERROR_MSG);
  }

  var uint8Mode = false;
  var arrayBufferMode = false;

  if (isUint8Array(uncompressed)) {
    uint8Mode = true;
  } else if (isArrayBuffer(uncompressed)) {
    arrayBufferMode = true;
    uncompressed = new Uint8Array(uncompressed);
  }

  var compressor = new SnappyCompressor(uncompressed);
  var maxLength = compressor.maxCompressedLength();
  var compressed, compressedView;
  var length;

  if (uint8Mode) {
    compressed = new Uint8Array(maxLength);
    length = compressor.compressToBuffer(compressed);
  } else if (arrayBufferMode) {
    compressed = new ArrayBuffer(maxLength);
    compressedView = new Uint8Array(compressed);
    length = compressor.compressToBuffer(compressedView);
  } else {
    compressed = Buffer.alloc(maxLength);
    length = compressor.compressToBuffer(compressed);
  }

  return compressed.slice(0, length);
}

exports.uncompress = uncompress;
exports.compress = compress;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(31), __webpack_require__(26).Buffer))

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _Filter__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony import */ var _FilterLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _FilterLayer__WEBPACK_IMPORTED_MODULE_1__["a"]; });





/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./src/layer/label/avoid/GGridIndex.js
var NUM_PARAMS = 3;

function GGridIndex(extent, n, padding) {
  var cells = this.cells = [];

  if (extent instanceof ArrayBuffer) {
    this.arrayBuffer = extent;
    var array = new Int32Array(this.arrayBuffer);
    extent = array[0];
    n = array[1];
    padding = array[2];
    this.d = n + 2 * padding;

    for (var k = 0; k < this.d * this.d; k++) {
      var start = array[NUM_PARAMS + k];
      var end = array[NUM_PARAMS + k + 1];
      cells.push(start === end ? null : array.subarray(start, end));
    }

    var keysOffset = array[NUM_PARAMS + cells.length];
    var bboxesOffset = array[NUM_PARAMS + cells.length + 1];
    this.keys = array.subarray(keysOffset, bboxesOffset);
    this.bboxes = array.subarray(bboxesOffset);
    this.insert = this._insertReadonly;
  } else {
    this.d = n + 2 * padding;

    for (var i = 0; i < this.d * this.d; i++) {
      cells.push([]);
    }

    this.keys = [];
    this.bboxes = [];
  }

  this.n = n;
  this.extent = extent;
  this.padding = padding;
  this.scale = n / extent;
  this.uid = 0;
  var p = padding / n * extent;
  this.min = -p;
  this.max = extent + p;
}

GGridIndex.prototype.insert = function (key, x1, y1, x2, y2) {
  this._forEachCell(x1, y1, x2, y2, this._insertCell, this.uid++);

  this.keys.push(key);
  this.bboxes.push(x1);
  this.bboxes.push(y1);
  this.bboxes.push(x2);
  this.bboxes.push(y2);
};

GGridIndex.prototype._insertReadonly = function () {
  throw 'Cannot insert into a GridIndex created from an ArrayBuffer.';
};

GGridIndex.prototype._insertCell = function (x1, y1, x2, y2, cellIndex, uid) {
  this.cells[cellIndex].push(uid);
};

GGridIndex.prototype.query = function (x1, y1, x2, y2) {
  var min = this.min;
  var max = this.max;

  if (x1 <= min && y1 <= min && max <= x2 && max <= y2) {
    // We use `Array#slice` because `this.keys` may be a `Int32Array` and
    // some browsers (Safari and IE) do not support `TypedArray#slice`
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice#Browser_compatibility
    return Array.prototype.slice.call(this.keys);
  } else {
    var result = [];
    var seenUids = {};

    this._forEachCell(x1, y1, x2, y2, this._queryCell, result, seenUids);

    return result;
  }
};

GGridIndex.prototype._queryCell = function (x1, y1, x2, y2, cellIndex, result, seenUids) {
  var cell = this.cells[cellIndex];

  if (cell !== null) {
    var keys = this.keys;
    var bboxes = this.bboxes;

    for (var u = 0; u < cell.length; u++) {
      var uid = cell[u];

      if (seenUids[uid] === undefined) {
        var offset = uid * 4;

        if (x1 <= bboxes[offset + 2] && y1 <= bboxes[offset + 3] && x2 >= bboxes[offset + 0] && y2 >= bboxes[offset + 1]) {
          seenUids[uid] = true;
          result.push(keys[uid]);
        } else {
          seenUids[uid] = false;
        }
      }
    }
  }
};

GGridIndex.prototype._forEachCell = function (x1, y1, x2, y2, fn, arg1, arg2) {
  var cx1 = this._convertToCellCoord(x1);

  var cy1 = this._convertToCellCoord(y1);

  var cx2 = this._convertToCellCoord(x2);

  var cy2 = this._convertToCellCoord(y2);

  for (var x = cx1; x <= cx2; x++) {
    for (var y = cy1; y <= cy2; y++) {
      var cellIndex = this.d * y + x;
      if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2)) return;
    }
  }
};

GGridIndex.prototype._convertToCellCoord = function (x) {
  return Math.max(0, Math.min(this.d - 1, Math.floor(x * this.scale) + this.padding));
};

GGridIndex.prototype.toArrayBuffer = function () {
  if (this.arrayBuffer) return this.arrayBuffer;
  var cells = this.cells;
  var metadataLength = NUM_PARAMS + this.cells.length + 1 + 1;
  var totalCellLength = 0;

  for (var i = 0; i < this.cells.length; i++) {
    totalCellLength += this.cells[i].length;
  }

  var array = new Int32Array(metadataLength + totalCellLength + this.keys.length + this.bboxes.length);
  array[0] = this.extent;
  array[1] = this.n;
  array[2] = this.padding;
  var offset = metadataLength;

  for (var k = 0; k < cells.length; k++) {
    var cell = cells[k];
    array[NUM_PARAMS + k] = offset;
    array.set(cell, offset);
    offset += cell.length;
  }

  array[NUM_PARAMS + cells.length] = offset;
  array.set(this.keys, offset);
  offset += this.keys.length;
  array[NUM_PARAMS + cells.length + 1] = offset;
  array.set(this.bboxes, offset);
  offset += this.bboxes.length;
  return array.buffer;
};

/* harmony default export */ var avoid_GGridIndex = (GGridIndex);
// EXTERNAL MODULE: ./src/layer/label/avoid/AvoidUtil.js
var AvoidUtil = __webpack_require__(6);

// EXTERNAL MODULE: ./src/layer/label/avoid/Util.js
var Util = __webpack_require__(7);

// CONCATENATED MODULE: ./src/layer/label/avoid/GLabelBox.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Class: GLabelBox
 *  计算注记避让box类
 *
 * Inherits:
 *  - <Object>
 */



var GLabelBox_GLabelBox = /*#__PURE__*/function () {
  function GLabelBox(ctx, formatFont) {
    _classCallCheck(this, GLabelBox);

    this.boxDistance = 0;
    this.ctx = ctx;
    this.formatFont = formatFont;
  }

  _createClass(GLabelBox, [{
    key: "setBox",
    value: function setBox(features, styleMap, isClient) {
      features.forEach(function (f, index) {
        f.hidden = false;
        var style = styleMap[f.styleId]; //如果要素不显示,没字就不画

        if (style.show == false) {
          f.hidden = true;
          return;
        }

        if (f.type == 1) {
          //构造点盒子
          if (isClient) {
            this.setPointBox(f, f.datas, this.ctx, style);
          } else {
            this.setPointBox(f, f.sourceAngleData, this.ctx, style);
          }
        }

        if (f.type == 2) {
          //如果是线文本注记
          if (f.lineType == 'text') {
            if (isClient) {
              this.setTextLineBox(f, f.datas, this.ctx, style);
            } else {
              this.setTextLineBox(f, f.sourceAngleData, this.ctx, style);
            }
          } //如果是线编码注记


          if (f.lineType == 'code') {
            if (isClient) {
              this.setCodeLineBox(f, f.datas, this.ctx, style);
            } else {
              this.setCodeLineBox(f, f.sourceAngleData, this.ctx, style);
            }
          } //如果是线箭头注记


          if (f.lineType == 'arrow') {
            if (isClient) {
              this.setArrowLineBox(f, f.datas, style);
            } else {
              this.setArrowLineBox(f, f.sourceAngleData, style);
            }
          }
        }
      }.bind(this));
      return this.filterFeature(features);
    } //构造点注记的boxs,上下左右四个方向

  }, {
    key: "setPointBox",
    value: function setPointBox(feature, datas, ctx, style) {
      //对要显示的点注记内容按照用户的转换函数进行转换
      if (style.labelFunction) {
        var labelFunction = new Function("label", style.labelFunction);

        try {
          feature.label = labelFunction.call({}, feature.attributes[style.labelfield]);
        } catch (e) {
          console.warn(feature.label + ': 调用labelFunction失败!');
        }
      }

      var labelIsNotNull = AvoidUtil["a" /* default */].isNotNull(feature.label); //如既没有文字，又没有图标,则不显示

      if (!labelIsNotNull && !feature.iconImg) {
        feature.hidden = true;
        return;
      }

      var param = this.getFontWidthHeight(ctx, feature, style, labelIsNotNull);
      var graphicWidth = param.graphicWidth;
      var graphicHeight = param.graphicHeight;
      var fontWidth = param.fontWidth;
      var fontHeight = param.fontHeight;
      var maxFontheight = param.maxFontheight;
      var pointOffsetX = style.pointOffsetX;
      var pointOffsetY = style.pointOffsetY;

      if (!pointOffsetX) {
        pointOffsetX = 0;
      }

      if (!pointOffsetY) {
        pointOffsetY = 0;
      }

      var pt = [datas[0][0][0], datas[0][0][1]];
      pt[0] = pt[0] + pointOffsetX;
      pt[1] = pt[1] + pointOffsetY;
      var pointBackgroundGap = style.pointBackgroundGap;

      if (style.pointHashBackground != true) {
        pointBackgroundGap = 0;
      }

      var graphicDistance = style.graphicDistance;

      if (graphicHeight == 0 || graphicWidth == 0) {
        graphicDistance = 0;
      }

      if (!style.hasOwnProperty('direction')) {
        style.direction = 0;
      }

      var boxs = [];
      var fourPoints = []; //如果有图标

      if (style.texture) {
        //如果有文字
        if (feature.label) {
          boxs = this.getPointAvoidBox(pt, style, graphicDistance, pointBackgroundGap, graphicWidth, graphicHeight, fontWidth, maxFontheight);
          fourPoints = this.getPointDrawPosition(pt, style, graphicDistance, pointBackgroundGap, graphicWidth, graphicHeight, fontWidth, fontHeight, maxFontheight);
        } else {
          //只有图标，没有文字
          var middleBox = [pt[0] - graphicWidth * 0.5, pt[1] - fontHeight * 0.5, pt[0] + graphicWidth * 0.5, pt[1] + fontHeight * 0.5];
          middleBox = this.boxScale(middleBox, style.pointBoxDisance);
          boxs = [middleBox];
          fourPoints = [[pt[0], pt[1]]];
        }
      } else {
        var _middleBox = [pt[0] - fontWidth * 0.5 - pointBackgroundGap, pt[1] - pointBackgroundGap - maxFontheight * 0.5, pt[0] + fontWidth * 0.5 + pointBackgroundGap, pt[1] + pointBackgroundGap + maxFontheight * 0.5];
        _middleBox = this.boxScale(_middleBox, style.pointBoxDisance);
        boxs = [_middleBox];
        var mPoint = [pt[0] - fontWidth * 0.5, pt[1] - fontHeight * 0.5 + style.pointHeight * 0.5];
        fourPoints = [mPoint];
      }

      feature.boxs = boxs;
      feature.box = boxs[0]; // feature.direction = 0;

      feature.fourPoints = fourPoints;
      feature.textPoint = fourPoints[0];
    }
    /**
     *  获取点注记的图标宽高，和注记的宽高和注记的最大高度
     * @param ctx
     * @param feature
     * @param style
     * @param labelIsNotNull
     * @returns {{}}
     */

  }, {
    key: "getFontWidthHeight",
    value: function getFontWidthHeight(ctx, feature, style, labelIsNotNull) {
      var currPara = {};
      var graphicWidth = style.graphicWidth;
      var graphicHeight = style.graphicHeight;
      var img = feature.iconImg;

      if (img) {
        //如果没有
        if (!graphicWidth || !graphicHeight) {
          graphicWidth = img.width;
          graphicHeight = img.height;
        }
      } else {
        graphicWidth = 0;
        graphicHeight = 0;
      }

      currPara.graphicWidth = graphicWidth;
      currPara.graphicHeight = graphicHeight;
      currPara.fontWidth = graphicWidth;
      currPara.fontHeight = graphicHeight;

      if (labelIsNotNull) {
        //转换为字符串
        feature.label = feature.label + '';
        var tmpLabels = feature.label.split(' ');
        var tmpLabelWidth = 0;
        ctx.save();
        ctx.font = AvoidUtil["a" /* default */].formatFont(style.pointStrokeFont, 1, this.formatFont);

        for (var i = 0; i < tmpLabels.length; i++) {
          var oneRowLabelWidth = Util["a" /* default */].measureText(tmpLabels[i].replace(/&nbsp;/g, " "), ctx.font, ctx);
          tmpLabelWidth = oneRowLabelWidth > tmpLabelWidth ? oneRowLabelWidth : tmpLabelWidth;
        }

        ctx.restore(); //各行的最宽宽度

        currPara.fontWidth = tmpLabelWidth; //文字的高度 * 文字的行数+  行间距

        currPara.fontHeight = style.pointHeight * tmpLabels.length + 2 * (tmpLabels.length - 1); // 如果点符号高度（用点符号宽度代替）高于文字高度 则用点符号高度替换文字高度

        currPara.maxFontheight = currPara.fontHeight > graphicHeight ? currPara.fontHeight : graphicHeight;
      }

      return currPara;
    }
    /**
     *  获取点注记有图标也有文字时的避让boxs
     * @param pt
     * @param style
     * @param graphicDistance
     * @param pointBackgroundGap
     * @param graphicWidth
     * @param graphicHeight
     * @param fontWidth
     * @param maxFontheight
     * @returns {[*,*,*,*]}
     */

  }, {
    key: "getPointAvoidBox",
    value: function getPointAvoidBox(pt, style, pointBackgroundGap, graphicDistance, graphicWidth, graphicHeight, fontWidth, maxFontheight) {
      var rightBox = [pt[0] - graphicWidth * 0.5, pt[1] - pointBackgroundGap - maxFontheight * 0.5, pt[0] + graphicWidth * 0.5 + graphicDistance + fontWidth + pointBackgroundGap * 2, pt[1] + maxFontheight * 0.5 + pointBackgroundGap];
      var leftBox = [pt[0] - graphicWidth * 0.5 - graphicDistance - fontWidth - pointBackgroundGap * 2, rightBox[1], pt[0] + graphicWidth * 0.5, rightBox[3]];
      var bottomBox = [pt[0] - fontWidth * 0.5 - pointBackgroundGap, pt[1] - graphicHeight * 0.5, pt[0] + fontWidth * 0.5 + pointBackgroundGap, pt[1] + graphicHeight * 0.5 + graphicDistance + pointBackgroundGap * 2 + maxFontheight];
      var topBox = [bottomBox[0], pt[1] - graphicDistance - pointBackgroundGap * 2 - maxFontheight - graphicHeight * 0.5, bottomBox[2], pt[1] + graphicHeight * 0.5];
      rightBox = this.boxScale(rightBox, style.pointBoxDisance);
      leftBox = this.boxScale(leftBox, style.pointBoxDisance);
      bottomBox = this.boxScale(bottomBox, style.pointBoxDisance);
      topBox = this.boxScale(topBox, style.pointBoxDisance);
      var boxs = [rightBox, leftBox, bottomBox, topBox];

      if (!style.isFourDirections && !style.isEightDirections) {
        return [boxs[style.direction]];
      }

      if (style.isFourDirections) {
        if (style.direction > 0) {
          var item = boxs.splice(style.direction, 1);
          boxs.unshift(item[0]);
        }

        return boxs;
      }

      var rightTopBox = [rightBox[0], topBox[1], rightBox[2], pt[1] + graphicHeight * 0.5];
      var rightBottomBox = [rightBox[0], pt[1] - graphicHeight * 0.5, rightBox[2], bottomBox[3]];
      var leftTopBox = [leftBox[0], topBox[1], leftBox[2], pt[1] + graphicHeight * 0.5];
      var leftBottomBox = [leftBox[0], pt[1] - graphicHeight * 0.5, leftBox[2], bottomBox[3]];
      boxs = [rightBox, leftBox, bottomBox, topBox, rightTopBox, rightBottomBox, leftTopBox, leftBottomBox];

      if (style.direction > 0) {
        var _item = boxs.splice(style.direction, 1);

        boxs.unshift(_item[0]);
      }

      return boxs;
    }
  }, {
    key: "getPointDrawPosition",
    value: function getPointDrawPosition(pt, style, graphicDistance, pointBackgroundGap, graphicWidth, graphicHeight, fontWidth, fontHeight, maxFontheight) {
      //单行最大高度
      var pointHeight = style.pointHeight;

      if (graphicHeight > pointHeight) {
        pointHeight = graphicHeight;
      } //不包括点图标,用于文字绘制的起点坐标


      var rPoint = [pt[0] + graphicWidth * 0.5 + graphicDistance + pointBackgroundGap, pt[1] - fontHeight * 0.5 + pointHeight * 0.5];
      var lPoint = [pt[0] - graphicWidth * 0.5 - graphicDistance - pointBackgroundGap - fontWidth, pt[1] - fontHeight * 0.5 + pointHeight * 0.5];
      var bPoint = [pt[0] - fontWidth * 0.5, pt[1] + graphicDistance + pointBackgroundGap + pointHeight * 0.5 + graphicHeight * 0.5];
      var tPoint = [bPoint[0], pt[1] - graphicDistance - pointBackgroundGap - fontHeight + pointHeight * 0.5 - graphicHeight * 0.5];
      var drawPositions = [rPoint, lPoint, bPoint, tPoint];

      if (!style.isFourDirections && !style.isEightDirections) {
        return [drawPositions[style.direction]];
      }

      if (style.isFourDirections) {
        if (style.direction > 0) {
          var item = drawPositions.splice(style.direction, 1);
          drawPositions.unshift(item[0]);
        }

        return drawPositions;
      }

      var rtPoint = [rPoint[0], tPoint[1]];
      var rbPoint = [rPoint[0], bPoint[1]];
      var ltPoint = [lPoint[0], tPoint[1]];
      var lbPoint = [lPoint[0], bPoint[1]];
      drawPositions = [rPoint, lPoint, bPoint, tPoint, rtPoint, rbPoint, ltPoint, lbPoint];

      if (style.direction > 0) {
        var _item2 = drawPositions.splice(style.direction, 1);

        drawPositions.unshift(_item2[0]);
      }

      return drawPositions;
    }
    /**
     * 设置线文字的box
     *  Parameters :
     *  feature - 单个线注记要素
     */

  }, {
    key: "setTextLineBox",
    value: function setTextLineBox(feature, datas, ctx, style) {
      var label = feature.label;
      var textPoints = datas;

      if (textPoints.length == 0) {
        feature.hidden = true;
        return;
      } //将分段的点数据和角度数据保留，留给后面绘制


      feature.textPoints = textPoints; //线的boxs

      var lineBoxs = []; //如果线注记带底色

      if (style.lineHashBackground == true || textPoints.length == 1) {
        var p = textPoints[0][0];

        if (textPoints.length > 1) {
          //获取线段的中间点
          var index = Math.floor(label.length / 2);
          p = textPoints[index][0];
        }

        ctx.save();

        if (this.formatFont) {
          ctx.font = Util["a" /* default */].formatFont(style.lineFillFont, 1, true);
        } else {
          ctx.font = style.lineFillFont;
        }

        var w = Util["a" /* default */].measureText(feature.label, ctx.font, ctx);
        ctx.restore();

        if (!style.lineBackgroundGap) {
          style.lineBackgroundGap = 0;
        }

        var minX = p[0] - w / 2 - style.lineBackgroundGap;
        var maxX = p[0] + w / 2 + style.lineBackgroundGap;
        var minY = p[1] - style.lineHeight * 0.5 - style.lineBackgroundGap;
        var maxY = p[1] + style.lineHeight * 0.5 + style.lineBackgroundGap;
        var box = [minX, minY, maxX, maxY];
        this.boxScale(box, style.lineTextBoxDisance);
        lineBoxs.push(box);
      } else {
        //如果文字需要旋转
        if (style.lineTextRotate || style.lineTextRotate == 0) {
          for (var m = 0; m < textPoints.length; m++) {
            textPoints[m][1] = style.lineTextRotate;
          }
        } else {
          //如果文字注记旋转角度方向不一致(有的字向左，有的字向右旋转)，则调整为一致
          this.textToSameBearing(feature.angle, textPoints);

          if (!style.isImportant) {
            //判断线文字之间的最大夹角是否大于指定的阈值
            if (this.isMessy(feature, textPoints, style, label)) {
              feature.hidden = true;
              return;
            }
          }
        } //获取每个字的box,判断每个字之前是否有压盖


        var boxs = this.getLineBoxs(label, textPoints, style);

        if (boxs) {
          lineBoxs = lineBoxs.concat(boxs);
        } else {
          feature.hidden = true;
          return;
        }
      }

      feature.boxs = lineBoxs;
    }
    /**
     * 设置线编码的box
     *  Parameters :
     *  feature - 单个线注记要素
     */

  }, {
    key: "setCodeLineBox",
    value: function setCodeLineBox(feature, datas, ctx, style) {
      var codePoints = datas;

      if (codePoints.length == 0) {
        feature.hidden = true;
        return;
      } //如果要显示道路编号


      var p = codePoints[0][0];
      ctx.save();

      if (this.formatFont) {
        ctx.font = Util["a" /* default */].formatFont(style.codeLineFillFont, 1, true);
      } else {
        ctx.font = style.codeLineFillFont;
      }

      var w = Util["a" /* default */].measureText(feature.label, ctx.font, ctx);
      ctx.restore();
      var minX = p[0] - w / 2 - style.codeLineBackgroundGap;
      var maxX = p[0] + w / 2 + style.codeLineBackgroundGap;
      var minY = p[1] - style.codeLineHeight * 0.5 - style.codeLineBackgroundGap;
      var maxY = p[1] + style.codeLineHeight * 0.5 + style.codeLineBackgroundGap;
      var box = [minX, minY, maxX, maxY];
      this.boxScale(box, style.lineCodeBoxDisance);
      feature.boxs = [box];
      feature.codePoint = p;
    }
    /**
     * 设置线箭头的box
     *  Parameters :
     *  feature - 单个线注记要素
     */

  }, {
    key: "setArrowLineBox",
    value: function setArrowLineBox(feature, datas, style) {
      var arrowPoints = datas;

      if (arrowPoints.length != 3) {
        feature.hiden = true;
        return;
      }

      var p = arrowPoints[0][0];
      var p1 = arrowPoints[2][0];
      var minX = p[0] < p1[0] ? p[0] : p1[0];
      var maxX = p[0] > p1[0] ? p[0] : p1[0];
      var minY = p[1] < p1[1] ? p[1] : p1[1];
      var maxY = p[1] > p1[1] ? p[1] : p1[1];
      var box = [minX, minY, maxX, maxY];
      this.boxScale(box, style.lineArrowBoxDisance);
      feature.boxs = [box];
      feature.arrowPoint = arrowPoints;
    } // 获取过滤后的要素.

  }, {
    key: "filterFeature",
    value: function filterFeature(features) {
      var returnFeatures = []; //剔除需避让的要素

      for (var i = 0; i < features.length; i++) {
        if (!features[i].hidden) {
          returnFeatures.push(features[i]);
        }
      }

      return returnFeatures;
    }
    /**
     * 判断线文字之间的最大夹角是否大于指定的阈值
     *  Parameters :
     * textPoints - 文本注记的线段数组
     *  style -要素的样式
     */

  }, {
    key: "isMessy",
    value: function isMessy(feature, textPoints, style, label) {
      var firstPoint = textPoints[0][0];
      var minX = firstPoint[0];
      var minY = firstPoint[1];
      var maxX = firstPoint[0];
      var maxY = firstPoint[1];
      var minAngle = textPoints[0][1];
      var maxAngle = textPoints[0][1];

      for (var i = 0; i < label.length; i++) {
        var currPoint = textPoints[i][0];
        var currAngle = textPoints[i][1];
        if (currPoint[0] > maxX) // 判断最大值
          maxX = currPoint[0];
        if (currPoint[0] < minX) // 判断最小值
          minX = currPoint[0];
        if (currPoint[1] > maxY) // 判断最大值
          maxY = currPoint[1];
        if (currPoint[1] < minY) // 判断最小值
          minY = currPoint[1];
        if (currAngle > maxAngle) // 判断最大值
          maxAngle = currAngle;
        if (currAngle < minAngle) // 判断最小值
          minAngle = currAngle;
      } //如果文字之间，相差的最大角度大于配置的角度度则不画


      if (maxAngle - minAngle > style.angle) {
        if (style.angleSwitch == false && style.angleColor) {
          feature.lineFillStyle = style.angleColor;
        } else {
          return true;
        }
      }

      return false;
    }
    /**
     * 检测线文字之间是否有自压盖
     *  Parameters :
     * boxs -
     *  style -要素的样式
     */

  }, {
    key: "getLineBoxs",
    value: function getLineBoxs(label, textPoints, style) {
      //和其它注记避让的boxs
      var boxs = []; //自相交避让的boxs

      var owmCrashBoxs = [];

      for (var i = 0; i < label.length; i++) {
        var pt = textPoints[i][0]; //解决旋转后的注记和不旋转的注记样式不一致的问题

        if (textPoints[i][1] == 0) {
          textPoints[i][1] = 0.5;
        } //考虑到线文字注记有角度偏转，box统一增加1.2倍


        var labelBox = [pt[0] - style.lineHeight * 1.2 * 0.5, pt[1] - style.lineHeight * 1.2 * 0.5, pt[0] + style.lineHeight * 1.2 * 0.5, pt[1] + style.lineHeight * 1.2 * 0.5];
        this.boxScale(labelBox, style.lineTextBoxDisance);
        var owmCrashBox = [pt[0] - style.lineHeight * 0.5, pt[1] - style.lineHeight * 1.2 * 0.5, pt[0] + style.lineHeight * 0.5, pt[1] + style.lineHeight * 0.5];
        owmCrashBoxs.push(owmCrashBox);
        boxs.push(labelBox);
      }

      if (!style.isImportant) {
        for (var j = 0; j < owmCrashBoxs.length - 1; j++) {
          var box1 = owmCrashBoxs[j];

          for (var k = j + 1; k < owmCrashBoxs.length; k++) {
            var box2 = owmCrashBoxs[k];

            if (this.crashBox(box1, box2)) {
              return null;
            }
          }
        }
      }

      return boxs;
    }
  }, {
    key: "boxScale",
    value: function boxScale(box, pointBoxDisance) {
      if (!pointBoxDisance && pointBoxDisance != 0) {
        pointBoxDisance = this.boxDistance;
      }

      box[0] = box[0] - pointBoxDisance * 0.5;
      box[1] = box[1] - pointBoxDisance * 0.5;
      box[2] = box[2] + pointBoxDisance * 0.5;
      box[3] = box[3] + pointBoxDisance * 0.5;
      return box;
    } // 两个盒子是否相交.

  }, {
    key: "crashBox",
    value: function crashBox(ibox, jbox) {
      return ibox[0] <= jbox[2] && ibox[2] >= jbox[0] && ibox[1] <= jbox[3] && ibox[3] >= jbox[1];
    }
    /**
     * 如果文字注记旋转角度方向不一致(有的字向左，有的字向右旋转)，则调整为一致
     * @param textPoints
     */

  }, {
    key: "textToSameBearing",
    value: function textToSameBearing(angle, textPoints) {
      //保证竖方向的字是正的
      if (angle >= 45) {
        angle = angle - 90;
      } else {
        if (angle <= -45) {
          angle = angle + 90;
        }
      }

      for (var i = 0; i < textPoints.length; i++) {
        var p = textPoints[i][1];
        var offsetAngle = angle - p;

        if (offsetAngle > 45) {
          textPoints[i][1] = p + 90;
        }

        if (offsetAngle < -45) {
          textPoints[i][1] = p - 90;
        }
      }
    }
  }]);

  return GLabelBox;
}();

/* harmony default export */ var avoid_GLabelBox = (GLabelBox_GLabelBox);
// CONCATENATED MODULE: ./src/layer/label/avoid/GAnnoAvoid.js
function GAnnoAvoid_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GAnnoAvoid_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function GAnnoAvoid_createClass(Constructor, protoProps, staticProps) { if (protoProps) GAnnoAvoid_defineProperties(Constructor.prototype, protoProps); if (staticProps) GAnnoAvoid_defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Class: GAnnoAvoid
 * 避让策略类
 *
 * Inherits:
 *  - <Object>
 */




var GAnnoAvoid_GAnnoAvoid = /*#__PURE__*/function () {
  function GAnnoAvoid(ctx, formatFont, debug) {
    GAnnoAvoid_classCallCheck(this, GAnnoAvoid);

    this.grid = null;
    this.GLabelBox = new avoid_GLabelBox(ctx, formatFont);
    this.debug = debug;
  } //注记和线图元进行避让


  GAnnoAvoid_createClass(GAnnoAvoid, [{
    key: "avoid",
    value: function avoid(labelFeatures, styleMap, avoidLineFeatures) {
      for (var i = 0; i < labelFeatures.length; i++) {
        var labelFeature = labelFeatures[i];
        var style = styleMap[labelFeature.styleId];

        if (labelFeature.type == 1) {
          this.avoidPointLine(labelFeature, avoidLineFeatures, style);
        }

        if (labelFeature.type == 2) {
          labelFeature.isCollision = this.avoidLineLine(labelFeature, avoidLineFeatures);
        }
      }

      return labelFeatures;
    } //点注记和线图元避让

  }, {
    key: "avoidPointLine",
    value: function avoidPointLine(feature, avoidLineFeatures, style) {
      var weight = feature.weight; //获取需要与注记避让的线图元

      avoidLineFeatures = this.getAvoidLineFeatures(weight, avoidLineFeatures);
      var boxCount = feature.boxs.length;
      feature.boxIndexs = {};

      for (var k = 0; k < boxCount; k++) {
        feature.boxIndexs[k] = true;
      } //删除的方向个数


      var delDirectionCount = 0;

      for (var i = 0; i < avoidLineFeatures.length; i++) {
        var avoidLineFeature = avoidLineFeatures[i];

        for (var j = 0; j < boxCount; j++) {
          var box = feature.boxs[j];
          var b = this.crashBoxLine(box, avoidLineFeature.sourceDatas, false);

          if (b) {
            if (feature.boxIndexs[j]) {
              delete feature.boxIndexs[j];
              delDirectionCount++; //如果所有方向都压盖，则压盖

              if (delDirectionCount == boxCount) {
                return true;
              }
            }
          }
        }
      }

      return false;
    } //线注记和线图元避让

  }, {
    key: "avoidLineLine",
    value: function avoidLineLine(feature, avoidLineFeatures) {
      var weight = feature.weight; //获取需要与注记避让的线图元

      avoidLineFeatures = this.getAvoidLineFeatures(weight, avoidLineFeatures);

      for (var j = 0; j < avoidLineFeatures.length; j++) {
        var avoidLineFeature = avoidLineFeatures[j];
        var isleftCollision = false;
        var isRightCollision = false;

        for (var i = 0; i < feature.boxs.length; i++) {
          var box = feature.boxs[i],
              boxArr = [];
          boxArr.push([box[0], box[1], box[2], box[3]]);
          boxArr.push([box[2], box[1], box[0], box[3]]);
          isleftCollision = this.crashPartLineLine(boxArr[0], avoidLineFeature.sourceDatas);
          isRightCollision = this.crashPartLineLine(boxArr[1], avoidLineFeature.sourceDatas);

          if (isleftCollision || isRightCollision) {
            return true;
          }
        }
      }

      return false;
    } //获取权重比点注记高的先图元要素

  }, {
    key: "getAvoidLineFeatures",
    value: function getAvoidLineFeatures(weight, avoidLineFeatures) {
      var alFeatures = [];

      for (var i = 0; i < avoidLineFeatures.length; i++) {
        var avoidLineFeature = avoidLineFeatures[i];
        var lineWeight = avoidLineFeature.weight;

        if (lineWeight > weight) {
          alFeatures.push(avoidLineFeature);
        }
      }

      return alFeatures;
    } // box和line是否相交

  }, {
    key: "crashBoxLine",
    value: function crashBoxLine(box, line, isFour) {
      var boxLines = [];

      if (isFour) {
        boxLines.push([box[0], box[1], box[2], box[1]]);
        boxLines.push([box[2], box[1], box[2], box[3]]);
        boxLines.push([box[2], box[3], box[0], box[3]]);
        boxLines.push([box[0], box[3], box[0], box[1]]);
      } else {
        boxLines.push([box[0], box[1], box[2], box[3]]);
        boxLines.push([box[2], box[1], box[0], box[3]]);
      }

      for (var i = 0; i < boxLines.length; i++) {
        var boxLine = boxLines[i];

        for (var j = 0; j < line.length / 2 - 1; j++) {
          var partLine = [line[2 * j], line[2 * j + 1], line[2 * (j + 1)], line[2 * (j + 1) + 1]];

          if (this.crashPartLinePartLine(boxLine, partLine)) {
            return true;
          }
        }
      }

      return false;
    } // 两条线是否相交

  }, {
    key: "crashLineLine",
    value: function crashLineLine(line1, line2) {
      for (var i = 0; i < line1.length / 2 - 1; i++) {
        var partLine1 = [line1[2 * i], line1[2 * i + 1], line1[2 * (i + 1)], line1[2 * (i + 1) + 1]];

        for (var j = 0; j < line2.length / 2 - 1; j++) {
          var partLine2 = [line2[2 * j], line2[2 * j + 1], line2[2 * (j + 1)], line2[2 * (j + 1) + 1]];

          if (this.crashPartLinePartLine(partLine1, partLine2)) {
            return true;
          }
        }
      }

      return false;
    } // 两条线是否相交

  }, {
    key: "crashPartLineLine",
    value: function crashPartLineLine(partLine, line2) {
      for (var j = 0; j < line2.length / 2 - 1; j++) {
        var partLine2 = [line2[2 * j], line2[2 * j + 1], line2[2 * (j + 1)], line2[2 * (j + 1) + 1]];

        if (this.crashPartLinePartLine(partLine, partLine2)) {
          return true;
        }
      }

      return false;
    } // 两条线段是否相交

  }, {
    key: "crashPartLinePartLine",
    value: function crashPartLinePartLine(line1, line2) {
      var p0_x = line1[0];
      var p0_y = line1[1];
      var p1_x = line1[2];
      var p1_y = line1[3];
      var p2_x = line2[0];
      var p2_y = line2[1];
      var p3_x = line2[2];
      var p3_y = line2[3];
      var s02_x, s02_y, s10_x, s10_y, s32_x, s32_y, s_numer, t_numer, denom, t;
      s10_x = p1_x - p0_x;
      s10_y = p1_y - p0_y;
      s32_x = p3_x - p2_x;
      s32_y = p3_y - p2_y;
      denom = s10_x * s32_y - s32_x * s10_y;
      if (denom == 0 //平行或共线
      ) return 0; // Collinear

      var denomPositive = denom > 0;
      s02_x = p0_x - p2_x;
      s02_y = p0_y - p2_y;
      s_numer = s10_x * s02_y - s10_y * s02_x;
      if (s_numer < 0 == denomPositive //参数是大于等于0且小于等于1的，分子分母必须同号且分子小于等于分母
      ) return 0; // No collision

      t_numer = s32_x * s02_y - s32_y * s02_x;
      if (t_numer < 0 == denomPositive) return 0; // No collision

      if (s_numer > denom == denomPositive || t_numer > denom == denomPositive) return 0; // No collision

      return 1;
    } //避让

  }, {
    key: "defaultAvoid",
    value: function defaultAvoid(features, styleMap, isClient, hasImportant, ableWeight) {
      if (isClient) {
        this.grid = new avoid_GGridIndex(4096, 32, 0);
      } else {
        this.grid = new avoid_GGridIndex(512, 32, 32);
      }

      if (features == null || features.length < 1) return []; // console.time('计算box');
      // //设置box,如果有线编码或者线箭头，则会新增要素

      features = this.GLabelBox.setBox(features, styleMap, isClient); // console.timeEnd('计算box');
      // console.time('mergeFeatures');

      features = this.mergeFeatures(features); // console.timeEnd('mergeFeatures');
      // console.time('排序');

      if (ableWeight) {
        //权值排序
        Util["a" /* default */].sort(features, styleMap, hasImportant);
      } // console.timeEnd('排序');
      // console.time('避让');
      //将注记添加到单元格中，进行避让


      for (var i = 0; i < features.length; i++) {
        var feature = features[i];
        var style = styleMap[feature.styleId];
        this.avoidFeature(feature, style);
      } // console.timeEnd('避让');


      var newFeatures = this.GLabelBox.filterFeature(features); //注记去重

      this.removeRepeat(newFeatures, styleMap); // console.timeEnd('去重');

      newFeatures = this.filterFeature(newFeatures);
      this.prevFeatures = newFeatures;

      if (this.debug) {
        return features;
      }

      return newFeatures;
    }
    /**
     * 给要素设置避让的box和注记的绘制坐标
     * @param f
     */

  }, {
    key: "avoidFeature",
    value: function avoidFeature(f, style) {
      if (style.show == false || f.hidden == true) {
        f.hidden = true;
        return;
      }

      if (f.boxs) {
        if (f.type == 1) {
          //点注记跟其它注记避让
          this.avoidPoint(f, style);
        } else {
          if (f.isCollision) {
            f.hidden = true;
          } else {
            //线注记跟其它注记进行避让
            this.avoidLine(f, style);
          }
        }
      } else {
        f.hidden = true;
      }
    }
    /**
     * 将点注记加入到计算出的多个单元格中
     * @param feature
     */

  }, {
    key: "avoidPoint",
    value: function avoidPoint(feature, style) {
      //如果为重要的，则不避让
      if (style.isImportant == true) {
        // let box = feature.boxs[feature.direction];
        this.addBoxToCells(feature.primaryId, feature.box);
        return;
      } //如果前面有小图标，并且开启了四宫格避让


      if ((style.isFourDirections || style.isEightDirections) && style.texture) {
        this.addFourCollisionFeatureToCells(feature, style, 0);
      } else {
        //如果没有指定的方向
        if (feature.boxIndexs && !feature.boxIndexs[0]) {
          feature.hidden = true;
          return;
        }

        var isCollision = this.isCollision(feature.box);

        if (isCollision) {
          feature.hidden = true;
          return;
        }

        this.addBoxToCells(feature.primaryId, feature.box);
      }
    }
    /**
     * 将线注记加入到计算出的多个单元格中
     * @param feature
     */

  }, {
    key: "avoidLine",
    value: function avoidLine(feature, style) {
      //如果为重要的，则不避让
      if (style.isImportant == true) {
        for (var i = 0; i < feature.boxs.length; i++) {
          var box = feature.boxs[i];
          this.addBoxToCells(feature.primaryId + 'index_' + i, box);
        }

        return;
      } //线注记是否与其它注记相交


      var isCollision = false;

      for (var _i = 0; _i < feature.boxs.length; _i++) {
        var _box = feature.boxs[_i];

        if (this.isCollision(_box)) {
          isCollision = true;
          break;
        }
      }

      if (isCollision) {
        feature.hidden = true;
      } else {
        for (var _i2 = 0; _i2 < feature.boxs.length; _i2++) {
          var _box2 = feature.boxs[_i2];
          this.addBoxToCells(feature.primaryId + 'index_' + _i2, _box2);
        }
      }
    }
    /**
     * 将点注记添加到单元格中
     * @param feature 点注记
     * @param index 点注记四宫格的index
     */

  }, {
    key: "addFourCollisionFeatureToCells",
    value: function addFourCollisionFeatureToCells(feature, style, index) {
      var isCollision = true;
      var box = []; //如果有指定的方向

      if (!feature.boxIndexs || feature.boxIndexs && feature.boxIndexs[index]) {
        box = feature.boxs[index];
        isCollision = this.isCollision(box);
      } // 如果相交,进行四宫,八宫格避让


      if (isCollision) {
        index++;

        if (index == feature.boxs.length) {
          index = index - feature.boxs.length;
        } //所有方向全部避让完成，仍然相交


        if (index == 0) {
          feature.hidden = true;
          return;
        } else {
          //换个点注记方向的box，再进行递归避让检测
          this.addFourCollisionFeatureToCells(feature, style, index);
        }
      } else {
        feature.textPoint = feature.fourPoints[index];
        feature.box = box; // feature.direction = index;

        this.addBoxToCells(feature.primaryId, box);
      }
    }
    /**
     *  返回注记的box是否与其它注记相交
     * @param row
     * @param col
     * @param feature
     */

  }, {
    key: "isCollision",
    value: function isCollision(box) {
      var x1 = box[0];
      var y1 = box[1];
      var x2 = box[2];
      var y2 = box[3];
      var result = this.grid.query(x1, y1, x2, y2);
      return result.length > 0;
    }
    /**
     *  注记box所占的单元格标识为true
     */

  }, {
    key: "addBoxToCells",
    value: function addBoxToCells(key, box) {
      var x1 = box[0];
      var y1 = box[1];
      var x2 = box[2];
      var y2 = box[3];
      this.grid.insert(key, x1, y1, x2, y2);
    } //attributeId当相同时，点注记的四个方向合并。线注记有一个是和图元压盖时，其它的线注记也不显示

  }, {
    key: "mergeFeatures",
    value: function mergeFeatures(features) {
      var map = {};

      for (var i = 0; i < features.length; i++) {
        var feature = features[i];

        if (!map[feature.attributeId]) {
          map[feature.attributeId] = [];
        }

        map[feature.attributeId].push(feature);
      }

      for (var key in map) {
        var array = map[key];

        if (array.length > 1) {
          var fristFeature = array[0];

          if (!fristFeature.boxIndexs) {
            continue;
          } //点注记，合并四宫格方向


          if (fristFeature.type == '1') {
            var boxIndexs = fristFeature.boxIndexs;

            for (var j = 1; j < array.length; j++) {
              boxIndexs = this.getBothDirection(boxIndexs, array[j].boxIndexs);
            }

            var isEmpty = true;

            for (var dKey in boxIndexs) {
              isEmpty = false;
              break;
            }

            for (var k = 0; k < array.length; k++) {
              if (isEmpty) {
                array[k].hidden = true;
              } else {
                array[k].boxIndexs = boxIndexs;
              }
            }
          } //是线注记,如果一条线压盖，其它的线也不显示


          if (fristFeature.type == '2') {// let isCollision = false;
            // for (let n = 0; n < array.length; n++) {
            //     if (array[n].isCollision == true) {
            //         isCollision = true;
            //         break;
            //     }
            // }
            //
            // if (isCollision) {
            //     for (let m = 0; m < array.length; m++) {
            //         array[m].hidden = true
            //     }
            // }
          }
        }
      } //去掉隐藏的注记


      return this.GLabelBox.filterFeature(features);
    } //合并两个点注记的方向

  }, {
    key: "getBothDirection",
    value: function getBothDirection(boxIndexs1, boxIndexs2) {
      var boxIndexs = {};

      for (var key in boxIndexs1) {
        if (boxIndexs2 && boxIndexs2[key]) {
          boxIndexs[key] = true;
        }
      }

      return boxIndexs;
    }
    /**
     * 求两点之间的距离
     */

  }, {
    key: "getDistance",
    value: function getDistance(p1, p2) {
      var calX = p2[0] - p1[0];
      var calY = p2[1] - p1[1];
      return Math.pow(calX * calX + calY * calY, 0.5);
    } // 获取过滤后的要素.

  }, {
    key: "filterFeature",
    value: function filterFeature(features) {
      var returnFeatures = []; //剔除需避让的要素

      for (var i = 0; i < features.length; i++) {
        if (!features[i].hidden) {
          features[i].drawed = true;
          returnFeatures.push(features[i]);
        }
      }

      return returnFeatures;
    } //去掉重复的注记

  }, {
    key: "removeRepeat",
    value: function removeRepeat(features, styleMap) {
      var pointsFs = [];
      var lineTextFs = [];
      var lineCodeFs = [];
      var drawedPointFs = [];
      var drawedLineTextFs = [];
      var drawedLineCodeFs = [];

      for (var i = 0; i < features.length; i++) {
        var f = features[i];

        if (f.type == 1) {
          if (f.drawed == true) {
            drawedPointFs.push(f);
          } else {
            pointsFs.push(f);
          }
        } else if (f.type == 2) {
          if (f.lineType == 'text') {
            if (f.drawed == true) {
              drawedLineTextFs.push(f);
            } else {
              lineTextFs.push(f);
            }
          }

          if (f.lineType == 'code') {
            if (f.drawed == true) {
              drawedLineCodeFs.push(f);
            } else {
              lineCodeFs.push(f);
            }
          }
        }
      }

      for (var j = 0; j < pointsFs.length; j++) {
        var pf = pointsFs[j];
        this.getShowPointFeatrues(drawedPointFs, pf, styleMap);
      }

      for (var k = 0; k < lineTextFs.length; k++) {
        var ltf = lineTextFs[k];
        this.getShowLineTextFeatrues(drawedLineTextFs, ltf, styleMap);
      }

      for (var n = 0; n < lineCodeFs.length; n++) {
        var lcf = lineCodeFs[n];
        this.getShowLineCodeFeatrues(drawedLineCodeFs, lcf, styleMap);
      } //清除上一屏的注记的绘制状态


      if (this.prevFeatures) {
        for (var m = 0; m < this.prevFeatures.length; m++) {
          var _pf = this.prevFeatures[m];
          _pf.drawed = false;
        }
      }
    }
  }, {
    key: "getShowPointFeatrues",
    value: function getShowPointFeatrues(features, feature, styleMap) {
      var hidden = false;

      for (var i = 0; i < features.length; i++) {
        var f = features[i];
        var style = styleMap[f.styleId];

        if (f.label == feature.label && style.distance && styleMap[feature.styleId].distance) {
          //求两个点注记之间的距离
          var distance = this.getDistance(f.centerPoint, feature.centerPoint);

          if (distance < style.distance) {
            hidden = true;
            feature.hidden = true;
          }
        }
      }

      if (!hidden) {
        features.push(feature);
      }
    }
  }, {
    key: "getShowLineTextFeatrues",
    value: function getShowLineTextFeatrues(features, feature, styleMap) {
      var hidden = false;

      for (var i = 0; i < features.length; i++) {
        var f = features[i];
        var style = styleMap[f.styleId];

        if (f.label == feature.label && style.lineTextDistance && styleMap[feature.styleId].lineTextDistance) {
          //求两个点注记之间的距离
          var distance = this.getDistance(f.centerPoint, feature.centerPoint);

          if (distance < style.lineTextDistance) {
            hidden = true;
            feature.hidden = true;
          }
        }
      }

      if (!hidden) {
        features.push(feature);
      }
    }
  }, {
    key: "getShowLineCodeFeatrues",
    value: function getShowLineCodeFeatrues(features, feature, styleMap) {
      var hidden = false;

      for (var i = 0; i < features.length; i++) {
        var f = features[i];
        var style = styleMap[f.styleId];

        if (f.label == feature.label && style.lineCodeDistance && styleMap[feature.styleId].lineCodeDistance) {
          //求两个点注记之间的距离
          var distance = this.getDistance(f.centerPoint, feature.centerPoint);

          if (distance < style.lineCodeDistance) {
            hidden = true;
            feature.hidden = true;
          }
        }
      }

      if (!hidden) {
        features.push(feature);
      }
    }
  }]);

  return GAnnoAvoid;
}();

/* harmony default export */ var avoid_GAnnoAvoid = __webpack_exports__["a"] = (GAnnoAvoid_GAnnoAvoid);

/***/ }),
/* 31 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: external "L"
var external_L_ = __webpack_require__(0);
var external_L_default = /*#__PURE__*/__webpack_require__.n(external_L_);

// CONCATENATED MODULE: ./src/ext/LeafletExt.js

/**
 * 重写Attribution方法的options属性，去掉leaflet商标
 */

external_L_default.a.Control.Attribution.prototype.options = {
  position: 'bottomright'
};
/**
 * 重写手势缩放的bug
 */

external_L_default.a.Map.TouchZoom.prototype._onTouchMove = function () {
  return function (e) {
    if (!e.touches || e.touches.length !== 2 || !this._zooming) {
      return;
    }

    var map = this._map,
        p1 = map.mouseEventToContainerPoint(e.touches[0]),
        p2 = map.mouseEventToContainerPoint(e.touches[1]),
        scale = p1.distanceTo(p2) / this._startDist;

    this._zoom = map.getScaleZoom(scale, this._startZoom) + 1;

    if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {
      this._zoom = map._limitZoom(this._zoom);
    }

    if (map.options.touchZoom === 'center') {
      this._center = this._startLatLng;

      if (scale === 1) {
        return;
      }
    } else {
      // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
      var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);

      if (scale === 1 && delta.x === 0 && delta.y === 0) {
        return;
      }

      this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
    }

    if (!this._moved) {
      map._moveStart(true);

      this._moved = true;
    }

    external_L_default.a.Util.cancelAnimFrame(this._animRequest);
    var moveFn = external_L_default.a.bind(map._move, map, this._center, this._zoom, {
      pinch: true,
      round: false
    });
    this._animRequest = external_L_default.a.Util.requestAnimFrame(moveFn, this, true);
    external_L_default.a.DomEvent.preventDefault(e);
  };
}(external_L_default.a.Map.TouchZoom.prototype._onTouchMove);
/**
 * 重写flyTo函数，解决该函数产生的小数缩放级别的bug
 */


external_L_default.a.Map.prototype.flyTo = function () {
  return function (targetCenter, targetZoom, options) {
    options = options || {};

    if (options.animate === false || !external_L_default.a.Browser.any3d) {
      return this.setView(targetCenter, targetZoom, options);
    }

    this._stop();

    var from = this.project(this.getCenter()),
        to = this.project(targetCenter),
        size = this.getSize(),
        startZoom = this._zoom;
    targetCenter = external_L_default.a.latLng(targetCenter);
    targetZoom = targetZoom === undefined ? startZoom : targetZoom;
    var w0 = Math.max(size.x, size.y),
        w1 = w0 * this.getZoomScale(startZoom, targetZoom),
        u1 = to.distanceTo(from) || 1,
        rho = 1.42,
        rho2 = rho * rho;

    function r(i) {
      var s1 = i ? -1 : 1,
          s2 = i ? w1 : w0,
          t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
          b1 = 2 * s2 * rho2 * u1,
          b = t1 / b1,
          sq = Math.sqrt(b * b + 1) - b; // workaround for floating point precision bug when sq = 0, log = -Infinite,
      // thus triggering an infinite loop in flyTo

      var log = sq < 0.000000001 ? -18 : Math.log(sq);
      return log;
    }

    function sinh(n) {
      return (Math.exp(n) - Math.exp(-n)) / 2;
    }

    function cosh(n) {
      return (Math.exp(n) + Math.exp(-n)) / 2;
    }

    function tanh(n) {
      return sinh(n) / cosh(n);
    }

    var r0 = r(0);

    function w(s) {
      return w0 * (cosh(r0) / cosh(r0 + rho * s));
    }

    function u(s) {
      return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
    }

    function easeOut(t) {
      return 1 - Math.pow(1 - t, 1.5);
    }

    var start = Date.now(),
        S = (r(1) - r0) / rho,
        duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

    function frame() {
      var t = (Date.now() - start) / duration,
          s = easeOut(t) * S;

      if (t <= 1) {
        this._flyToFrame = external_L_default.a.Util.requestAnimFrame(frame, this);

        this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {
          flyTo: true
        });
      } else {
        //增加这行，保证flyto完成后，地图的层级为整数
        targetZoom = Math.round(targetZoom);

        this._move(targetCenter, targetZoom)._moveEnd(true);
      }
    }

    this._moveStart(true);

    frame.call(this);
    return this;
  };
}(external_L_default.a.Map.prototype.flyTo);
/**
 * 如果是ie浏览器，则增加startsWith和endsWith方法
 */


if (!!window.ActiveXObject || "ActiveXObject" in window) {
  String.prototype.startsWith = function (str) {
    if (str == null || str == "" || this.length == 0 || str.length > this.length) return false;

    if (this.substr(0, str.length) == str) {
      return true;
    } else {
      return false;
    }
  };

  String.prototype.endsWith = function (str) {
    if (!!window.ActiveXObject || "ActiveXObject" in window) {
      return this.indexOf(str, this.length - str.length) !== -1;
    } else {
      return this.endsWith(str);
    }
  };
}
// CONCATENATED MODULE: ./src/ext/CRS.CustomEPSG4326.js
/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 *
 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
 */


var CustomEPSG4326 = external_L_default.a.extend({}, external_L_default.a.CRS.Earth, {
  code: 'EPSG:4326',
  projection: external_L_default.a.Projection.LonLat,
  transformation: new external_L_default.a.Transformation(1 / 180, 1, -1 / 180, 0.5),
  scale: function scale(zoom) {
    return 256 * Math.pow(2, zoom - 1);
  }
});
external_L_default.a.CRS.CustomEPSG4326 = CustomEPSG4326;
/* harmony default export */ var CRS_CustomEPSG4326 = __webpack_exports__["a"] = (CustomEPSG4326);

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // ref: https://github.com/tc39/proposal-global

var getGlobal = function getGlobal() {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof self !== 'undefined') {
    return self;
  }

  if (typeof window !== 'undefined') {
    return window;
  }

  if (typeof global !== 'undefined') {
    return global;
  }

  throw new Error('unable to locate global object');
};

var global = getGlobal();
module.exports = exports = global.fetch; // Needed for TypeScript and Webpack.

if (global.fetch) {
  exports["default"] = global.fetch.bind(global);
}

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var _util_Cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/* harmony import */ var _avoid_GDrawGeomerty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _util_es6_promise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var _LabelDrawer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
/* harmony import */ var _LabelDrawer__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_LabelDrawer__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _avoid_GAnnoAvoid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30);
/* harmony import */ var _avoid_ParseLabelData__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12);
/* harmony import */ var _avoid_GridFilterLabel__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(24);
/* harmony import */ var _VarintReader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(36);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by kongjian on 2017/6/26.
 */









var CanvasLayer = /*#__PURE__*/function () {
  function CanvasLayer() {
    _classCallCheck(this, CanvasLayer);

    this.width = 0;
    this.height = 0; //当前屏幕的瓦片层行列号集合

    this.grid = [];
    this.cache = new _util_Cache__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](256); //注记图层对象

    this.gwvtAnno = null; //数据源集合

    this.dataSource = []; //如果dataSource是urldatasource,那么样式纹理是否加载完成。 如果只有localDataSource,则为true

    this.isReady = false; //地图的最大范围

    this.maxExtent = []; //地图的当前视口

    this.extent = []; //地图的当前分辨率

    this.res = 0; //瓦片大小

    this.tileSize = 256; //是否允许拾取

    this.hitDetection = false; //当前屏幕内的features

    this.features = []; //正在请求中的瓦片请求集合,还没返回的请求

    this.requestingTiles = {}; // 是否支持有isImportant属性

    this.hasImportant = true; //缩放比例

    this.ratio = 1;
    var canvas = document.createElement('CANVAS');
    this.ctx = canvas.getContext('2d', {
      isQuality: true
    }); // //是否已经设置过全局样式
    // this.isSetGlobalStyle = false;
    //全局是否开启避让

    this.ableAvoid = true; //全局是否开启权重排序

    this.ableWeight = true; //过滤格网大小

    this.cellsize = 4; //网格内保留点的个数

    this.maxPerCell = 1; //样式map

    this.styleMap = {}; //避让调试工具模式

    this.debug = false;
    this.GAnnoAvoid = new _avoid_GAnnoAvoid__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"](this.ctx, false, this.debug);
    this.highlightLabels = {};
  }

  _createClass(CanvasLayer, [{
    key: "setDebug",
    value: function setDebug(debug) {
      this.debug = debug;
      this.GAnnoAvoid = new _avoid_GAnnoAvoid__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"](this.ctx, false, this.debug);
    }
    /**
     * 初始化
     */

  }, {
    key: "init",
    value: function init(w, h, tileSize, gwvtAnno) {
      this.tileSize = tileSize;
      this.gwvtAnno = gwvtAnno;
      this.cellsize = gwvtAnno.cellsize;
      this.initCanvas(w, h);
      this.loadResources();
    }
  }, {
    key: "loadResources",

    /**
     * 加载dataSource的样式文件和纹理，所有dataSource的
     * 样式文件和纹理加载完成，则isReady设置为ture
     */
    value: function loadResources() {
      if (this.dataSource.length == 0) {
        this.isReady = false;
        return;
      }

      this.cache.clean();
      this.requestingTiles = {};
      var reqArr = [];

      for (var i = 0; i < this.dataSource.length; i++) {
        var ds = this.dataSource[i];

        if (ds.type == 'URLDataSource') {
          reqArr = reqArr.concat(ds.loadStyle());
        }

        if (ds.type == 'LocalDataSource') {
          reqArr = reqArr.concat(ds.loadTexture());
        }
      }

      if (reqArr.length > 0) {
        Promise.all(reqArr).then(function () {
          this.isReady = true; //重新请求注记数据

          if (this.grid.length > 0) {
            this.requestLabelTiles(this.grid);
          }
        }.bind(this));
      } else {
        this.isReady = true;
      }
    }
  }, {
    key: "initCanvas",

    /**
     * 初始化画布
     * Parameters :
     * w - 图层宽
     * h - 图层高
     */
    value: function initCanvas(w, h) {
      this.width = w;
      this.height = h;

      if (!this.root) {
        this.root = document.createElement("canvas");
      }

      this.root.style.width = this.width + "px";
      this.root.style.height = this.height + "px";
      this.root.width = this.width * this.ratio;
      this.root.height = this.height * this.ratio;
      this.root.id = 'labelCanvas';
      this.canvas = this.root.getContext("2d", {
        isQuality: true
      });

      if (this.hitDetection) {
        if (!this.hitCanvas) {
          this.hitCanvas = document.createElement("canvas");
        }

        this.hitCanvas.style.width = this.width + "px";
        this.hitCanvas.style.height = this.height + "px";
        this.hitCanvas.width = this.width;
        this.hitCanvas.height = this.height;
        this.hitContext = this.hitCanvas.getContext("2d", {
          isQuality: true
        });
      }
    }
  }, {
    key: "addDataSource",

    /**
     * 添加数据源
     * Parameters :
     * dataSource
     */
    value: function addDataSource(dataSource) {
      if (dataSource.type == 'URLDataSource') {
        dataSource.url = dataSource.url + '&tilesize=' + this.tileSize;
      }

      if (dataSource.type == 'URLDataSource' || dataSource.type == 'LocalDataSource') {
        this.dataSource.push(dataSource);
      }
    }
  }, {
    key: "removeDataSourceById",

    /**
     * 根据dataSoucceId移除数据源
     * Parameters :
     * dataSoucceId
     */
    value: function removeDataSourceById(dataSoucceId) {
      for (var i = 0; i < this.dataSource.length; i++) {
        if (this.dataSource[i].id == dataSoucceId) {
          this.dataSource.splice(i, 1);
          return;
        }
      }
    }
  }, {
    key: "getDataSourceById",

    /**
     * 根据dataSoucceId获取数据源
     * Parameters :
     * dataSoucceId
     */
    value: function getDataSourceById(dataSoucceId) {
      for (var i = 0; i < this.dataSource.length; i++) {
        if (this.dataSource[i].id == dataSoucceId) {
          return this.dataSource[i];
        }
      }
    }
  }, {
    key: "clean",

    /**
     * 清空画布
     */
    value: function clean() {
      this.canvas.clearRect(0, 0, this.width * this.ratio, this.height * this.ratio);

      if (this.hitContext) {
        this.hitContext.clearRect(0, 0, this.width, this.height);
      }
    }
  }, {
    key: "redraw",

    /**
     * 重新绘制注记要素，当动态更改DataSouce数据源后，需要调用redraw方法
     */
    value: function redraw() {
      if (this.grid.length == 0) {
        return;
      } //重置styleMap


      this.styleMap = {}; //重新加载样式，纹理文件

      this.loadResources();
    }
  }, {
    key: "requestLabelTiles",

    /**
     * 请求注记瓦片
     * Parameters :
     * grid - 当前视口内，瓦片的层行列号集合
     * zoomChanged - 是否进行了缩放操作
     */
    value: function requestLabelTiles(grid, zoomChanged) {
      this.grid = grid; //如果数据源没有准备好

      if (!this.isReady) {
        return;
      } //获取需要请求的url


      var requestTileUrls = this.getRequestTileUrls(grid);
      this.sendRequest(requestTileUrls);
    }
  }, {
    key: "getLocalLabelDatas",

    /**
     * 获取localDataSource中在当前屏幕范围内的注记要素
     */
    value: function getLocalLabelDatas() {
      var localFeatures = [];

      for (var i = 0; i < this.dataSource.length; i++) {
        var ds = this.dataSource[i];

        if (ds.type == 'LocalDataSource') {
          for (var j = 0; j < ds.features.length; j++) {
            var feature = ds.features[j]; //找出在当前视口内的要素

            if (feature.inBounds(this.extent)) {
              feature.attributeId = feature.attributes['attributeId'];
              feature.primaryId = feature.attributeId;

              if (feature.type == 1) {
                //转换要素的地理坐标为屏幕坐标
                feature.sourceAngleData = [[feature.sourceData, 0]];
                feature.transformData(this.extent, this.res);
                feature.label = feature.getFeatureLabel(); // feature.textures = ds.textures;

                feature.iconImg = ds.textures[feature.style.texture];
                localFeatures.push(feature);
              }

              if (feature.type == 2) {
                feature.label = feature.getFeatureLabel();
                feature.textures = ds.textures;
                localFeatures = localFeatures.concat(this.cutLineFeature(feature, true));
              }
            }
          }
        }
      }

      return localFeatures;
    }
  }, {
    key: "getRequestTileUrls",

    /**
     * 计算需要请求的瓦片的url
     * Parameters :
     * requestTiles - 需要请求的瓦片层行列号集合
     */
    value: function getRequestTileUrls(grid) {
      this.hitCacheUrls = [];
      this.currentTileDatas = [];
      this.defaultStyeTileDatas = []; //本次需要请求的url

      var requestTileUrls = {}; //请求队列中找到的url集合

      var findedRequestUrls = {};

      for (var i = 0; i < this.dataSource.length; i++) {
        var dataSource = this.dataSource[i]; //url数据源

        if (dataSource.type == 'URLDataSource') {
          var url = dataSource.url;

          for (var j = 0; j < grid.length; j++) {
            var item = grid[j];
            var tileUrl = url.replace('${x}', item.col).replace('{x}', item.col);
            tileUrl = tileUrl.replace('${y}', item.row).replace('{y}', item.row);
            tileUrl = tileUrl.replace('${z}', item.level).replace('{z}', item.level); //多域名url

            if (dataSource.urlArray.length > 0) {
              var len = dataSource.urlArray.length - 1;
              var index = Math.round(Math.random() * len);
              var domainUrl = dataSource.urlArray[index];
              var array = tileUrl.split('/mapserver');
              var partUrl = array[1];
              tileUrl = domainUrl + '/mapserver' + partUrl;
            } //判断缓存中有没有该注记


            var cacheItem = this.cache.getItem(tileUrl);

            if (cacheItem) {
              this.hitCacheUrls.push({
                url: tileUrl,
                isDefaultStyle: dataSource.styleId == '_default__'
              });
            } else {
              //已经发送的请求队列中找,队列中没找到的需要发送请求
              if (!this.requestingTiles[tileUrl]) {
                requestTileUrls[tileUrl] = {
                  url: tileUrl,
                  xyz: item,
                  dataSourceId: dataSource.id,
                  dataType: dataSource.newEngine ? 'arraybuffer' : "json"
                };
              } else {
                findedRequestUrls[tileUrl] = true;
              }
            }
          }
        }
      } // console.log('total count  ================='+ grid.length);
      //关闭上次不需要的请求


      this.cancelRequest(findedRequestUrls);
      return requestTileUrls;
    }
  }, {
    key: "cancelRequest",

    /**
     * 取消上次不需要的请求
     * Parameters :
     * findedRequestUrls - 请求队列中找到的url集合
     */
    value: function cancelRequest(findedRequestUrls) {
      for (var tileUrl in this.requestingTiles) {
        if (!findedRequestUrls[tileUrl]) {
          var requestTile = this.requestingTiles[tileUrl];
          delete this.requestingTiles[tileUrl];
          requestTile.xhr.abort();
          requestTile.requestItem.cancel = true;
        }
      }
    }
  }, {
    key: "sendRequest",

    /**
     * 发送请求，取注记瓦片数据
     * Parameters :
     * requestTileUrls - 需要请求的瓦片url集合
     */
    value: function sendRequest(requestTileUrls) {
      var count = 0;

      for (var url in requestTileUrls) {
        var item = requestTileUrls[url];
        var promise = null;

        if (item.dataType == "json") {
          promise = Object(_util_es6_promise__WEBPACK_IMPORTED_MODULE_2__[/* getParamJSON */ "d"])(item);
        } else if (item.dataType == "arraybuffer") {
          promise = Object(_util_es6_promise__WEBPACK_IMPORTED_MODULE_2__[/* getBufferData */ "b"])(item);
        }

        this.requestingTiles[item.url] = {
          xhr: promise.xhr,
          requestItem: item
        };
        promise.then(this.tileSuccessFunction.bind(this), this.tileFailFunction.bind(this));
        count++;
      } // console.log('sendRequest count ==============='+count);


      if (count == 0) {
        this.sendSuccess([], []);
      }
    }
  }, {
    key: "toBuffer",
    value: function toBuffer(ab) {
      var buf = new Buffer(ab.byteLength);
      var view = new Uint8Array(ab);

      for (var i = 0; i < buf.length; ++i) {
        buf[i] = view[i];
      }

      return buf;
    }
  }, {
    key: "Utf8ArrayToStr",
    value: function Utf8ArrayToStr(array) {
      var out, i, len, c;
      var char2, char3;
      out = "";
      len = array.length;
      i = 0;

      while (i < len) {
        c = array[i++];

        switch (c >> 4) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            // 0xxxxxxx
            out += String.fromCharCode(c);
            break;

          case 12:
          case 13:
            // 110x xxxx   10xx xxxx
            char2 = array[i++];
            out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
            break;

          case 14:
            // 1110 xxxx  10xx xxxx  10xx xxxx
            char2 = array[i++];
            char3 = array[i++];
            out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);
            break;
        }
      }

      return out;
    }
    /**
     * 单个瓦片注记请求成功的回调
     */

  }, {
    key: "tileSuccessFunction",
    value: function tileSuccessFunction(data) {
      if (data.param.cancel == true || this.isEmptyObject(this.requestingTiles)) {
        //请求取消失败的，直接返回
        return;
      } //var buf = Buffer.from(data.data);        
      // var buf = this.toBuffer(data.data);
      // if (buf.length > 0) {
      //     var vant = new VarintReader(buf, 4);
      //     var layerNameArr = vant.getAllLayerNames();
      // }
      // return;


      var url = data.param.url; //删除正在请求的url

      delete this.requestingTiles[url];
      var dataSourceId = data.param.dataSourceId;
      var dataSource = this.getDataSourceById(dataSourceId);
      var features = null;

      if (dataSource && dataSource.newEngine) {
        var buf = this.toBuffer(data.data);
        var dataObj = {
          param: data.param,
          tileData: {}
        };

        if (buf.length > 0) {
          var vant = new _VarintReader__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"](buf, 4);
          var layerNameArr = vant.getAllLayerNames();

          for (var i = 0; i < layerNameArr.length; i++) {
            dataObj.tileData[layerNameArr[i]] = {
              geometryType: vant.getGeometryType(layerNameArr[i]),
              props: JSON.parse(this.Utf8ArrayToStr(vant.getLayerPro(layerNameArr[i])))
            };
          }

          dataObj["vant"] = vant;
        }

        features = this.parseFeature(dataObj, dataSource);
      } else {
        features = this.parseFeature(data, dataSource);
      }

      var labelFeatures = [];

      if (features.styleId == null) {
        this.currentTileDatas.push({
          url: url,
          labelFeatures: [],
          avoidLineFeatures: features.avoidLineFeatures
        });
        return;
      }

      if (features.styleId == '_default__') {
        _avoid_ParseLabelData__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].updateFeatureAttr(features.pointFeatures, this.styleMap, this.ratio, {}, true, this.maxExtent, this.extent, this.res, this.tileSize);
        labelFeatures = labelFeatures.concat(features.lineFeatures);
        labelFeatures = labelFeatures.concat(features.pointFeatures);
        this.defaultStyeTileDatas.push({
          url: url,
          labelFeatures: labelFeatures,
          avoidLineFeatures: features.avoidLineFeatures
        });
      } else {
        //如果需要避让
        if (this.ableAvoid) {
          // console.time('fristFilter');
          //第一次格网过滤
          labelFeatures = _avoid_GridFilterLabel__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].fristFilter(features.pointFeatures, features.lineFeatures, this.styleMap, this.ableWeight, true, this.tileSize, this.cellsize, this.tileSize * 1.0, this.maxPerCell); //第一次过滤后的点注记，设置更多的属性

          _avoid_ParseLabelData__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].updateFeatureAttr(labelFeatures.pointFeatures, this.styleMap, this.ratio, dataSource.textures, true, this.maxExtent, this.extent, this.res, this.tileSize); // console.timeEnd('fristFilter');
          //第二次格网过滤
          // console.time('scendFilter');

          labelFeatures = _avoid_GridFilterLabel__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].scendFilter(labelFeatures.pointFeatures, labelFeatures.lineFeatures, this.styleMap, this.ableWeight, true, this.tileSize, this.cellsize, this.tileSize * 1.0); // console.timeEnd('scendFilter');
          //设置boxs

          labelFeatures = this.GAnnoAvoid.GLabelBox.setBox(labelFeatures, this.styleMap, false); //第三次过滤去重
          // labelFeatures = GridFilterLabel.threeFilter(labelFeatures,this.styleMap,this.tileSize);

          if (features.avoidLineFeatures.length > 0) {
            // //设置boxs
            // labelFeatures = this.GAnnoAvoid.GLabelBox.setBox(labelFeatures,this.styleMap,false);
            labelFeatures = this.GAnnoAvoid.avoid(labelFeatures, this.styleMap, features.avoidLineFeatures);
          } // ParseLabelData.updateFeatureAttr(features.pointImportantFeatures,this.styleMap,this.ratio,dataSource.textures,
          //     true,this.maxExtent,this.extent,this.res,this.tileSize);

        } else {
          _avoid_ParseLabelData__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].updateFeatureAttr(features.pointFeatures, this.styleMap, this.ratio, dataSource.textures, true, this.maxExtent, this.extent, this.res, this.tileSize); // ParseLabelData.updateFeatureAttr(features.pointImportantFeatures,this.styleMap,this.ratio,dataSource.textures,
          //     true,this.maxExtent,this.extent,this.res,this.tileSize);

          labelFeatures = features.pointFeatures.concat(features.lineFeatures);
        }

        this.currentTileDatas.push({
          url: url,
          labelFeatures: labelFeatures,
          avoidLineFeatures: features.avoidLineFeatures
        });
      } //如果所有的瓦片请求成功


      if (this.isEmptyObject(this.requestingTiles)) {
        this.sendSuccess(this.currentTileDatas, this.defaultStyeTileDatas);
      }
    }
  }, {
    key: "isEmptyObject",
    //判断map是否为空
    value: function isEmptyObject(e) {
      for (var t in e) {
        return !1;
      }

      return !0;
    }
  }, {
    key: "tileFailFunction",

    /**
     * 单个瓦片注记请求失败的回调
     */
    value: function tileFailFunction(data) {
      if (data.param.cancel == true || this.isEmptyObject(this.requestingTiles)) {
        //请求取消失败的，直接返回
        return;
      }

      var url = data.param.url;
      delete this.requestingTiles[url]; //如果所有的瓦片请求成功

      if (this.isEmptyObject(this.requestingTiles)) {
        this.sendSuccess(this.currentTileDatas, this.defaultStyeTileDatas);
      }
    }
  }, {
    key: "sendSuccess",

    /**
     * 请求成功的回调函数，没有请求url，也会执行该回调
     * Parameters :
     * results - 请求成功的结果
     */
    value: function sendSuccess(results, defaultStyleResult) {
      if (this.gwvtAnno.animating) {
        return;
      } //重置图层位置


      this.gwvtAnno.resetCanvasDiv();
      this.clean(); //保证当前屏幕内需要拾取的要素

      if (this.hitDetection) {
        this.features = [];
      }

      this.drawLabel(results);
      this.drawDefaultStyleLabel(defaultStyleResult);
    }
  }, {
    key: "drawDefaultStyleLabel",

    /**
     * 合并本地注记，绘制注记 (默认样式的注记)
     * Parameters :
     * results - 请求成功的结果
     */
    value: function drawDefaultStyleLabel(results) {
      //合并上次在当前视口范围内的注记要素(不包括本地要素)
      var mergeFeatures = this.mergeLabelData(results, this.hitCacheUrls, true);
      var labelFeatures = mergeFeatures.labelFeatures;

      for (var i = 0; i < results.length; i++) {
        var item = results[i];
        this.cache.push(item.url, item);
      } //保证当前屏幕内需要拾取的要素


      if (this.hitDetection) {
        for (var _i = 0; _i < labelFeatures.length; _i++) {
          var feature = labelFeatures[_i];
          this.features[feature.id] = feature;
        }
      } //绘制注记要素


      _avoid_GDrawGeomerty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].drawDefaultStyle(this.canvas, labelFeatures, this.styleMap, this.ratio, false, false, this.hitContext, this.hitDetection);
    }
    /**
     * 合并本地注记，注记避让，绘制注记
     * Parameters :
     * results - 请求成功的结果
     */

  }, {
    key: "drawLabel",
    value: function drawLabel(results) {
      //合并上次在当前视口范围内的注记要素(不包括本地要素)
      var mergeFeatures = this.mergeLabelData(results, this.hitCacheUrls, false);
      var labelFeatures = mergeFeatures.labelFeatures;

      for (var i = 0; i < results.length; i++) {
        var item = results[i];
        this.cache.push(item.url, item);
      } //获取localDataSource中在当前屏幕范围内的注记要素


      var localFeatures = this.getLocalLabelDatas();
      labelFeatures = labelFeatures.concat(localFeatures); //设置boxs

      labelFeatures = this.GAnnoAvoid.GLabelBox.setBox(labelFeatures, this.styleMap, true);
      var avoidlabelDatas = labelFeatures;

      if (this.ableAvoid) {
        avoidlabelDatas = this.GAnnoAvoid.defaultAvoid(labelFeatures, this.styleMap, true, this.hasImportant, this.ableWeight);
      } // this.drawAvoidLine(mergeFeatures.avoidLineFeatures);
      //保证当前屏幕内需要拾取的要素


      if (this.hitDetection) {
        for (var _i2 = 0; _i2 < avoidlabelDatas.length; _i2++) {
          var feature = avoidlabelDatas[_i2];
          this.features[feature.id] = feature;
        }
      } //绘制注记要素


      _avoid_GDrawGeomerty__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].draw(this.canvas, avoidlabelDatas, this.styleMap, this.ratio, false, false, this.hitContext, this.hitDetection, false, this.debug); //绘制道路线
      // GDrawGeomerty.drawLines(this.canvas,avoidlabelDatas,this.styleMap,this.ratio,false,false,this.hitContext, this.hitDetection,this);
    }
  }, {
    key: "drawAvoidLine",
    value: function drawAvoidLine(avoidLineFeatures) {
      this.canvas.save();
      this.canvas.beginPath();

      for (var i = 0; i < avoidLineFeatures.length; i++) {
        var avoidLineFeature = avoidLineFeatures[i];
        this.canvas.lineWidth = 1;
        this.canvas.strokeStyle = "#fff000"; //画线

        this.canvas.moveTo(avoidLineFeature.datas[0], avoidLineFeature.datas[1]);

        for (var j = 1; j < avoidLineFeature.datas.length / 2; j++) {
          this.canvas.lineTo(avoidLineFeature.datas[j * 2], avoidLineFeature.datas[j * 2 + 1]);
        }
      }

      this.canvas.stroke();
      this.canvas.restore();
    }
  }, {
    key: "parseFeature",

    /**
     * 解析返回的注记信息
     * Parameters:
     * tileData - 请求返回的注记数据
     * Returns:
     * labelDatas - 设置过样式,坐标由瓦片内坐标转为屏幕坐标的注记数据
     */
    value: function parseFeature(tileData, dataSource) {
      var layers = {};

      if (dataSource.newEngine) {
        var sTileDataObj = tileData.tileData;

        for (var key in sTileDataObj) {
          layers[key] = {
            features: [],
            fieldsConfig: dataSource.serverInfo[key].fieldsConfig,
            serverId: dataSource.servername,
            type: 1
          };

          if (sTileDataObj[key].geometryType.toLowerCase() == "point") {
            layers[key].type = 1;
          } else if (sTileDataObj[key].geometryType.toLowerCase() == "line" || sTileDataObj[key].geometryType.toLowerCase() == "linestring" || sTileDataObj[key].geometryType.toLowerCase() == "multilinestring") {
            layers[key].type = 2;
          }

          if (sTileDataObj[key].props && sTileDataObj[key].props.length > 0) {
            for (var k = 0; k < sTileDataObj[key].props.length; k++) {
              var tDataArr = [];
              tDataArr.push(sTileDataObj[key].geometryType);
              tDataArr.push(sTileDataObj[key].props[k]);
              tDataArr.push(tileData.vant.getCoordinatesByIndex(key, k, 10));
              layers[key].features.push(tDataArr);
            }
          }
        }
      } else {
        layers = tileData.data;
      }

      var xyz = {
        x: tileData.param.xyz.col,
        y: tileData.param.xyz.row,
        l: tileData.param.xyz.level
      };
      var count = 0;

      for (var _key in layers) {
        var layerData = layers[_key];
        count++;
      }

      var features = {
        pointFeatures: [],
        lineFeatures: [],
        pointImportantFeatures: [],
        lineImportantFeatures: []
      };

      if (count > 0 && dataSource && dataSource.styleFun) {
        //设置样式
        var itemDatas = [];
        var level = xyz.l;

        if (dataSource.newEngine) {
          var render = new _LabelDrawer__WEBPACK_IMPORTED_MODULE_3___default.a(layers, this.styleMap, level);
          dataSource.styleFun.call({}, render, level);
        } else {
          var drawer = new _LabelDrawer__WEBPACK_IMPORTED_MODULE_3___default.a(layers, this.styleMap, level);
          dataSource.styleFun.call({}, drawer, level);
        } //转换瓦片坐标为屏幕坐标,并构造label数据


        features = _avoid_ParseLabelData__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].parseLayerDatas(layers, this.styleMap, xyz, true, this.maxExtent, this.extent, this.res, this.tileSize);
      }

      var avoidLineFeatures = _avoid_ParseLabelData__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].parseAvoidLine(layers['_layerAvoids'], xyz, true, this.maxExtent, this.extent, this.res, this.tileSize);
      var pointFeatures = _avoid_GridFilterLabel__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].removeTileOutPointFeatures(features.pointFeatures, this.tileSize); // let lineFeatures = GridFilterLabel.removeTileOutLineFeatures(features.lineFeatures,this.tileSize);

      var lineFeatures = features.lineFeatures;
      var styleId = dataSource ? dataSource.styleId : null;
      return {
        styleId: styleId,
        pointFeatures: pointFeatures,
        lineFeatures: lineFeatures,
        avoidLineFeatures: avoidLineFeatures
      };
    }
  }, {
    key: "setGlobalStyle",
    value: function setGlobalStyle(globalStyle) {
      this.ableAvoid = !globalStyle.disableAvoid;
      this.ableWeight = !globalStyle.disableWeight;
      this.boxDistance = globalStyle.boxDistance;
    }
    /**
     * 将本次请求的注记数据和上次在本视口范围内的要素合并
     * Returns:
     * labelDatas - 合并后的注记数据，当前视口整个屏幕的数据
     */

  }, {
    key: "mergeLabelData",
    value: function mergeLabelData(results, hitCacheUrls, isDefaultStyle) {
      var labelFeatures = [];
      var avoidLineFeatures = [];

      for (var j = 0; j < results.length; j++) {
        var result = results[j];
        labelFeatures = labelFeatures.concat(result.labelFeatures);
        avoidLineFeatures = avoidLineFeatures.concat(result.avoidLineFeatures);
      }

      var urls = [];

      for (var m = 0; m < hitCacheUrls.length; m++) {
        var item = hitCacheUrls[m];

        if (item.isDefaultStyle == isDefaultStyle) {
          urls.push(item.url);
        }
      }

      for (var i = 0; i < urls.length; i++) {
        var cacheLabelFeatures = this.cache.getItem(urls[i]).labelFeatures;

        for (var _j = 0; _j < cacheLabelFeatures.length; _j++) {
          var labelFeature = cacheLabelFeatures[_j]; //重新计算当前屏幕坐标

          labelFeature.datas = _avoid_ParseLabelData__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].transformData(labelFeature.sourceAngleData, labelFeature.xyz, this.maxExtent, this.extent, this.res, this.tileSize);
        }

        labelFeatures = labelFeatures.concat(cacheLabelFeatures);
        var cacheAvoidLineFeatures = this.cache.getItem(urls[i]).avoidLineFeatures;

        for (var _j2 = 0; _j2 < cacheAvoidLineFeatures.length; _j2++) {
          var avoidLineFeature = cacheAvoidLineFeatures[_j2]; //重新计算当前屏幕坐标

          avoidLineFeature.datas = _avoid_ParseLabelData__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].transformAvoidLine(avoidLineFeature.sourceDatas, avoidLineFeature.xyz, this.maxExtent, this.extent, this.res, this.tileSize);
        }

        avoidLineFeatures = avoidLineFeatures.concat(cacheAvoidLineFeatures);
      }

      return {
        labelFeatures: labelFeatures,
        avoidLineFeatures: avoidLineFeatures
      };
    }
  }, {
    key: "getFeatureByXY",

    /**
     * 根据屏幕坐标获取feature
     * Parameters :
     * x
     * y
     */
    value: function getFeatureByXY(x, y) {
      var feature = null;

      if (this.hitDetection) {
        var featureId;
        var data = this.hitContext.getImageData(x, y, 1, 1).data;

        if (data[3] === 255) {
          // antialiased
          var id = data[2] + 256 * (data[1] + 256 * data[0]);

          if (id) {
            featureId = id - 1;

            try {
              feature = this.features[featureId];
            } catch (err) {
              console.log(err);
            }
          }
        }
      }

      return feature;
    }
    /**
     * 根据屏幕坐标获取feature, 可以拾取叠加的注记，效率比getFeatureByXY低
     * Parameters :
     * x
     * y
     */

  }, {
    key: "getFeaturesByXY",
    value: function getFeaturesByXY(x, y) {
      var pickFeatures = [];

      for (var key in this.features) {
        var feature = this.features[key];

        if (feature.type == 1) {
          if (this.isInBox(x, y, feature.box)) {
            pickFeatures.push(feature);
            continue;
          }
        }

        if (feature.type == 2) {
          for (var j = 0; j < feature.boxs.length; j++) {
            var box = feature.boxs[j];

            if (this.isInBox(x, y, box)) {
              pickFeatures.push(feature);
              break;
            }
          }
        }
      }

      return pickFeatures;
    }
    /**
     * 将线注记原始坐标带点和角度的格式，和切过的线的格式一致（针对默认样式的线主机）
     * Parameters:
     * line - 线注记原始数据
     * Returns:
     */

  }, {
    key: "lineToSourceAngleData",
    value: function lineToSourceAngleData(line) {
      var sourceAngleData = [];

      for (var i = 0; i < line.length; i++) {
        var x = line[i];
        var y = line[i + 1];
        sourceAngleData.push([[x, y], 0]);
        i++;
      }

      return sourceAngleData;
    }
  }, {
    key: "transformData",

    /**
     * 将瓦片内坐标转换为当前屏幕坐标
     * Parameters:
     * points - 瓦片内坐标数组,item示例：[[12,20],0] [12,20]为点坐标，0为旋转的角度
     * xyz - 瓦片的层行列号
     * Returns:
     * rdata - 本地屏幕内坐标数组
     */
    value: function transformData(points, xyz) {
      //取出当前视口左上角的地理坐标
      var left = this.extent[0];
      var top = this.extent[3]; //地图最大的范围

      var mLeft = this.maxExtent[0];
      var mTop = this.maxExtent[3]; //计算坐上角的屏幕坐标

      var x = (left - mLeft) / this.res;
      var y = (mTop - top) / this.res;
      var rPoint = [];

      for (var i = 0; i < points.length; i++) {
        var point = points[i][0];
        var gx = point[0] + xyz.x * this.tileSize;
        var gy = point[1] + xyz.y * this.tileSize;
        var p = [gx - x, gy - y];
        rPoint.push([p, points[i][1]]);
      }

      return rPoint;
    }
  }, {
    key: "isInBox",
    value: function isInBox(x, y, box) {
      if (x > box[0] && x < box[2] && y > box[1] && y < box[3]) {
        return true;
      }

      return false;
    }
  }, {
    key: "highlightLabel",

    /**
     * 高亮指定的注记
     * Parameters :
     * featrueIds 需要高亮的注记id数组
     * lightColor 注记高亮的填充色
     */
    value: function highlightLabel(featrueIds, lightColor) {
      for (var key in this.highlightLabels) {
        var feature = this.highlightLabels[key];
        delete feature['lightColor'];
      }

      this.highlightLabels = {};

      for (var i = 0; i < featrueIds.length; i++) {
        var id = featrueIds[i];
        var _feature = this.features[id];
        _feature.lightColor = lightColor;
        this.highlightLabels[id] = _feature;
      }
    }
  }]);

  return CanvasLayer;
}();

/* harmony default export */ __webpack_exports__["a"] = (CanvasLayer);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(26).Buffer))

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Created by kongjian on 2018/6/12.
 * 注记瓦片队列缓存工具类
 */
var Cache = /*#__PURE__*/function () {
  function Cache(size) {
    _classCallCheck(this, Cache);

    this.size = size;
    this.map = {};
    this.list = [];
  } //往缓存中加入数据


  _createClass(Cache, [{
    key: "push",
    value: function push(key, item) {
      if (this.list.length > this.size - 1) {
        var removeKey = this.list.shift();
        delete this.map[removeKey];
      }

      this.list.push(key);
      this.map[key] = item;
    } //获取缓存数据

  }, {
    key: "getItem",
    value: function getItem(key) {
      return this.map[key];
    } //清空缓存

  }, {
    key: "clean",
    value: function clean() {
      this.map = {};
      this.list = [];
    } //获取缓存的长度

  }, {
    key: "length",
    value: function length() {
      return this.list.length;
    }
  }]);

  return Cache;
}();

/* harmony default export */ __webpack_exports__["a"] = (Cache);

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var snappyjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var snappyjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(snappyjs__WEBPACK_IMPORTED_MODULE_0__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var VarintReader = /*#__PURE__*/function () {
  function VarintReader(vectorVarintBuffer, hd) {
    _classCallCheck(this, VarintReader);

    this.hd = hd;
    this.intLength = 4;
    this.vectorVarintBuffer = vectorVarintBuffer;
    this.geometyTypeMap = new Map();
    this.proMap = new Map();
    this.varintMap = new Map();
    this.layerMap = new Map();
    this.offsetMap = new Map();
    this.proMapOld = new Map();
    this.offsetMapOld = new Map();
    this.addVector(vectorVarintBuffer);
  }
  /**
   * 增加瓦片数据
   * @param vectorVarintBuffer 瓦片数据的varint编码Buffer
   */


  _createClass(VarintReader, [{
    key: "addVector",
    value: function addVector(vectorVarintBuffer) {
      //读取geometry类型的字节长度
      var offset = this.hd;
      var typeLength = vectorVarintBuffer.readInt32BE(offset);
      offset = offset + this.intLength; //读取数据类型。vector是多图层结构；其它geometry类型的为单图层结构

      var type = vectorVarintBuffer.toString('utf8', offset, offset + typeLength);
      offset = offset + typeLength;

      if (type != 'vector') {
        console.error('不是瓦片数据！');
        return;
      }

      this._readVector(vectorVarintBuffer, offset);
    }
    /**
     * 增加图层数据
     * @param layerName 图层名称
     * @param layerVarintBuffer 图层数据的varint编码Buffer
     */

  }, {
    key: "addLayer",
    value: function addLayer(layerName, layerVarintBuffer) {
      //读取geometry类型的字节长度
      var offset = this.hd;
      var typeLength = this.vectorVarintBuffer.readInt32BE(offset);
      offset = offset + this.intLength; //读取数据类型。vector是多图层结构；其它geometry类型的为单图层结构

      var type = this.vectorVarintBuffer.toString('utf8', offset, offset + typeLength);
      offset = offset + typeLength;

      if (type != 'vector') {
        this._readLayer(layerName, this.vectorVarintBuffer);
      } else {
        console.error('不是图层数据！');
      }
    }
    /**
     * 获得图层的varint编码Buffer
     */

  }, {
    key: "getBuffer",
    value: function getBuffer() {
      var data = [];
      var idx = [];
      var keyBytes;
      var layerBuf;

      var _iterator = _createForOfIteratorHelper(this.layerMap.keys()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var key = _step.value;
          layerBuf = this._getLayerBuffer(key);
          keyBytes = this._stringToByte(key);
          idx.push.apply(idx, _toConsumableArray(this._intToBytes(keyBytes.length)));
          idx.push.apply(idx, _toConsumableArray(keyBytes));
          idx.push.apply(idx, _toConsumableArray(this._intToBytes(layerBuf.length)));
          data.push(layerBuf);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var indexBuf = Buffer.from(idx);
      var dataBuf = Buffer.concat(data);
      var layerHeader = [];

      var typeByte = this._stringToByte('vector');

      layerHeader.push.apply(layerHeader, _toConsumableArray(this._getHeaderArray()));
      layerHeader.push.apply(layerHeader, _toConsumableArray(this._intToBytes(typeByte.length)));
      layerHeader.push.apply(layerHeader, _toConsumableArray(typeByte));
      layerHeader.push.apply(layerHeader, _toConsumableArray(this._intToBytes(indexBuf.length)));
      var layerHeaderBuf = Buffer.from(layerHeader);
      return Buffer.concat([layerHeaderBuf, indexBuf, dataBuf]);
    }
    /**
     * //生成随机头
     * @returns {[]}
     * @private
     */

  }, {
    key: "_getHeaderArray",
    value: function _getHeaderArray() {
      var harr = [];

      for (var i = 0; i < this.hd; i++) {
        harr[i] = this._getRandomNum();
      }

      return harr;
    }
    /**
     * 构建layer数据结构
     * @param layerName
     * @returns {Buffer}
     * @private
     */

  }, {
    key: "_getLayerBuffer",
    value: function _getLayerBuffer(layerName) {
      var layerBuffer = [];

      var gtype = this._stringToByte(this.geometyTypeMap.get(layerName));

      var gTypeLength = this._intToBytes(gtype.length);

      var json = this.proMapOld.get(layerName);

      var jsonLength = this._intToBytes(json.length);

      var offset = this.offsetMapOld.get(layerName);
      var offsetLength = Buffer.from(this._intToBytes(offset.length));
      var data = this.varintMap.get(layerName);
      layerBuffer.push.apply(layerBuffer, _toConsumableArray(this._getHeaderArray()));
      layerBuffer.push.apply(layerBuffer, _toConsumableArray(gTypeLength));
      layerBuffer.push.apply(layerBuffer, _toConsumableArray(gtype));
      layerBuffer.push.apply(layerBuffer, _toConsumableArray(jsonLength));
      return Buffer.concat([Buffer.from(layerBuffer), json, offsetLength, offset, data]);
    }
    /**
     * 生成随机数头
     * @returns {number}
     * @private
     */

  }, {
    key: "_getRandomNum",
    value: function _getRandomNum() {
      var Range = 80;
      var Rand = Math.random();
      return 50 + Math.round(Rand * Range);
    }
    /**
     * 字符串转byte数组
     * @param str
     * @returns {[]}
     * @private
     */

  }, {
    key: "_stringToByte",
    value: function _stringToByte(str) {
      var bytes = [];
      var buffer = Buffer.from(str, 'utf8');

      for (var i = 0; i < buffer.length; i++) {
        bytes.push(buffer[i]);
      }

      return bytes;
    }
    /**
     * byte数组转字符串
     * @param bytes
     * @returns {string}
     * @private
     */

  }, {
    key: "_byteToString",
    value: function _byteToString(bytes) {
      return Buffer.from(bytes).toString();
    }
    /**
     * 数字转byte数组
     * @param num
     * @returns {number[]}
     * @private
     */

  }, {
    key: "_intToBytes",
    value: function _intToBytes(num) {
      return [num >> 24 & 0x00ff, num >> 16 & 0x00ff, num >> 8 & 0x00ff, num & 0x00ff];
    }
    /**
     * byte数组转数字
     * @param bytes
     * @returns {number}
     * @private
     */

  }, {
    key: "_bytesToInt",
    value: function _bytesToInt(bytes) {
      return bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3];
    }
    /**
     * 获得图层名称数组
     * @returns {[图层名称1， 图层名称2， ...]}
     */

  }, {
    key: "getAllLayerNames",
    value: function getAllLayerNames() {
      var layerNames = [];

      var _iterator2 = _createForOfIteratorHelper(this.layerMap),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var value = _step2.value;
          layerNames.push(value[0]);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return layerNames;
    }
    /**
     * 图层的空间类型
     * @param layerName
     * @returns {any}
     */

  }, {
    key: "getGeometryType",
    value: function getGeometryType(layerName) {
      return this.geometyTypeMap.get(layerName);
    }
    /**
     * 图层的属性信息
     * @param layerName 图层名称
     * @returns {属性对象}
     */

  }, {
    key: "getLayerPro",
    value: function getLayerPro(layerName) {
      var jsonBuffer = this.proMap.get(layerName); // let obj = null;
      // if (Buffer.isBuffer(jsonBuffer)) {
      //     let jsonString = snappy.uncompress(jsonBuffer).toString();
      //     obj = JSON.parse(jsonString);
      //     this.proMap.set(layerName, obj);
      // } else {
      //     obj = this.proMap.get(layerName);
      // }
      //return obj;

      return snappyjs__WEBPACK_IMPORTED_MODULE_0___default.a.uncompress(jsonBuffer);
    }
    /**
     * 获得图层所有坐标数组的偏移量数组
     * @param layerName 图层名称
     * @returns {[属性1字节开始位置，属性1坐标字节长度 ,属性2字节开始位置，属性2坐标字节长度 ,....]}
     */

  }, {
    key: "getOffsetArray",
    value: function getOffsetArray(layerName) {
      return this.offsetMap.get(layerName);
    }
    /**
     * 获得图层某个属性的坐标偏移量数组
     * @param layerName 图层名称
     * @param proIndex 属性所在数组的位置
     * @returns {[属性字节开始位置，属性坐标字节长度]}
     */

  }, {
    key: "getOffsetByIndex",
    value: function getOffsetByIndex(layerName, proIndex) {
      var all = this.offsetMap.get(layerName);
      var arr = [];
      arr.push(all[proIndex * 2]);
      arr.push(all[proIndex * 2 + 1]);
      return arr;
    }
    /**
     * 获得图层的所有坐标字节
     * @param layerName 图层名称
     * @returns {Buffer}
     */

  }, {
    key: "getLayerCoordinate",
    value: function getLayerCoordinate(layerName) {
      return this.varintMap.get(layerName);
    }
    /**
     * 获得要素
     * @param layerName 图层名称
     * @returns {any[属性， 偏移量， 坐标varint数组]}
     */

  }, {
    key: "getLayerFeature",
    value: function getLayerFeature(layerName) {
      var allArr = ["", ""];
      var proArr = this.proMap.get(layerName);
      var offsetArr = this.offsetMap.get(layerName); //allArr[1] = offsetArr;

      var varintArr = this.varintMap.get(layerName);
      allArr[1] = varintArr;

      if (proArr.length > 0) {
        allArr[0] = snappyjs__WEBPACK_IMPORTED_MODULE_0___default.a.uncompress(proArr);
      }

      if (offsetArr.length > 0) {///allArr[1] = snappy.uncompress(offsetArr);
      }

      if (varintArr.length > 0) {//allArr[1] = snappy.uncompress(varintArr);
      }

      return allArr;
    }
    /**
     * 图层所有数字坐标
     * @param layerName 图层名称
     * @param precision 数字精度
     * @returns {[[要素1坐标],[要素2坐标],...]}
     */

  }, {
    key: "getAllCoordinates",
    value: function getAllCoordinates(layerName, precision) {
      var ofs = this.getOffsetArray(layerName);
      var buffer = this.varintMap.get(layerName);
      var coorArray = [];
      var offset;
      var length;
      var bf;

      for (var i = 0; i < ofs.length / 2; i++) {
        offset = ofs[i * 2];
        length = ofs[i * 2 + 1];
        bf = buffer.slice(offset, offset + length);
        coorArray.push(this._bufferToDoubleArray(bf, precision));
      }

      return coorArray;
    }
    /**
     * 图层某个要素的数字坐标
     * @param layerName 图层名称
     * @param proIndex 属性所在数组的位置
     * @param precision 数字精度
     * @returns {[要素坐标]}
     */

  }, {
    key: "getCoordinatesByIndex",
    value: function getCoordinatesByIndex(layerName, proIndex, precision) {
      var ofs = this.getOffsetByIndex(layerName, proIndex);
      var buffer = this.varintMap.get(layerName);
      var offset = ofs[0];
      var length = ofs[1];
      var bf = buffer.slice(offset, offset + length);
      return this._bufferToDoubleArray(bf, precision);
    }
    /**
     * 解析图层Buffer
     * @param layerName 图层名
     * @param buffer varint编码Buffer
     * @private
     */

  }, {
    key: "_readLayer",
    value: function _readLayer(layerName, buffer) {
      if (buffer.length == 0) {
        return;
      }

      var offset = this.hd; //读取空间类型

      var typeLength = buffer.readInt32BE(offset);
      offset = offset + this.intLength;
      var geometrytype = buffer.toString('utf8', offset, offset + typeLength);
      this.geometyTypeMap.set(layerName, geometrytype); //读取json

      offset = offset + typeLength;
      var jsonLength = buffer.readInt32BE(offset);
      offset = offset + this.intLength;
      var jsonBuffer = buffer.slice(offset, offset + jsonLength);
      this.proMap.set(layerName, jsonBuffer);
      this.proMapOld.set(layerName, jsonBuffer); //读取偏移量数组

      offset = offset + jsonLength;
      var offsetLength = buffer.readInt32BE(offset);
      offset = offset + this.intLength;
      var offsetBuffer = buffer.slice(offset, offset + offsetLength);

      var indexArray = this._varintToIntArray(offsetBuffer);

      this.offsetMap.set(layerName, indexArray);
      this.offsetMapOld.set(layerName, offsetBuffer); //读取坐标

      offset = offset + offsetLength;
      var varintBuf = buffer.slice(offset);
      this.varintMap.set(layerName, varintBuf);
    }
    /**
     * 解析瓦片数据
     * @param buffer varint编码Buffer
     * @param offset 坐标数据索引字节开始位置
     * @private
     */

  }, {
    key: "_readVector",
    value: function _readVector(buffer, offset) {
      //读取坐标数据索引字节开始位置
      var indexLength = buffer.readInt32BE(offset); //截取index表述字节

      offset = offset + this.intLength;
      var indexBuffer = buffer.slice(offset, offset + indexLength); //截取数字字节

      offset = offset + indexLength;
      var dataBuffer = buffer.slice(offset, this.vectorVarintBuffer.length);
      var layerNameLength = 0;
      var layerName;
      var dataLength;
      var dataBegin = 0;
      var begin = 0;
      var end = 0;
      var tmpBuffer;

      for (var i = 0; i < indexBuffer.length;) {
        begin = i;
        layerNameLength = indexBuffer.readInt32BE(begin);
        begin = begin + this.intLength;
        end = begin + layerNameLength;
        layerName = indexBuffer.toString('utf8', begin, end);
        begin = end;
        dataLength = indexBuffer.readInt32BE(begin);
        begin = begin + this.intLength; //截取每个layer的坐标字节段

        tmpBuffer = dataBuffer.slice(dataBegin, dataBegin + dataLength);
        dataBegin = dataBegin + dataLength;
        this.layerMap.set(layerName, tmpBuffer);

        this._readLayer(layerName, tmpBuffer);

        i = begin;
      }
    }
    /**
     * varint坐标转数字坐标
     * @param buffer varint字节数组
     * @param precision 数字精度
     * @returns {[数字坐标]}
     * @private
     */

  }, {
    key: "_bufferToDoubleArray",
    value: function _bufferToDoubleArray(buffer, precision) {
      var varintCode = [];
      var high;
      var bf_index = 0;
      var nums = [];
      var oldX = 0;
      var oldY = 0;
      var x;
      var y;
      var isX = true;

      for (var i = 0; i < buffer.length; i++) {
        //buffer.length
        high = 0x00000000 | buffer[i] >> 7 & 0x01;

        if (high == 0) {
          if (bf_index > 0 && bf_index <= 5) {
            if (isX) {
              x = this._varintToInt(varintCode) + oldX;
              nums.push(x / precision);
              isX = false;
              oldX = x;
            } else {
              y = this._varintToInt(varintCode) + oldY;
              nums.push(y / precision);
              isX = true;
              oldY = y;
            }

            bf_index = 0;
            varintCode = [];
          } else if (bf_index > 5) {
            //bf_index > 5为间隔符
            oldX = -99999;
            oldY = -99999;
            bf_index = 0;
            varintCode = [];
          }
        }

        varintCode.push(buffer[i]);
        bf_index++;
      }

      return nums;
    }
    /**
     * varint编码转数字数组
     * @param buffer
     * @returns {[]}
     * @private
     */

  }, {
    key: "_varintToIntArray",
    value: function _varintToIntArray(buffer) {
      var varintCode = [];
      var high;
      var bf_index = 0;
      var nums = [];

      for (var i = 0; i < buffer.length; i++) {
        high = 0x00000000 | buffer[i] >> 7 & 0x01;

        if (high == 0) {
          if (bf_index > 0 && bf_index <= 5) {
            nums.push(this._varintToInt(varintCode));
            varintCode = [];
            bf_index = 0;
          }
        }

        varintCode.push(buffer[i]);
        bf_index++;
      }

      nums.push(this._varintToInt(varintCode));
      return nums;
    }
    /**
     * varint转数字
     * @param buffer 单个数字的varint编码
     * @returns {number}
     * @private
     */

  }, {
    key: "_varintToInt",
    value: function _varintToInt(buffer) {
      var intBuffer = [];
      var highBuffer = [];
      var j = 3;
      var offset = 0;

      for (var i = buffer.length - 1; i >= 0; i--) {
        if (i - 1 >= 0) {
          highBuffer[0] = buffer[i - 1] << 7 - offset;
        } else {
          highBuffer[0] = 0;
        }

        if (j == -1) {
          break;
        }

        intBuffer[j] = (buffer[i] & 0x7f) >> offset | highBuffer[0];
        j--;
        offset++;
      }

      var t = intBuffer[0] << 24 & 0xff000000 | intBuffer[1] << 16 & 0x00ff0000 | intBuffer[2] << 8 & 0x0000ff00 | intBuffer[3] & 0x000000ff;
      t = t >> 1 ^ -(t & 1);
      return t;
    }
    /**
     * 数字转varint编码
     * @param num
     * @returns {[]|number[]}
     * @private
     */

  }, {
    key: "_intToVarint",
    value: function _intToVarint(num) {
      if (num == 0) {
        return [0];
      }

      num = this._zigZagEncoding(num);
      var buffer = [];
      var now;
      var high = 0;

      for (var i = 5; i > 0; i--) {
        now = num >> (i - 1) * 7 & 0x7f;

        if (high != 0) {
          now = now | 0x80;
        }

        if (now != 0) {
          buffer.push(now);
        }

        high = now;
      }

      return buffer;
    }
    /**
     * 负数转正数编码
     * @param num
     * @returns {number}
     * @private
     */

  }, {
    key: "_zigZagEncoding",
    value: function _zigZagEncoding(num) {
      return num >> 31 ^ num << 1;
    }
  }]);

  return VarintReader;
}();

/* harmony default export */ __webpack_exports__["a"] = (VarintReader);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(26).Buffer))

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(38);
module.exports = __webpack_require__(50);


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CRS", function() { return _core__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "crs", function() { return _core__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony import */ var _ext_CRS_CustomEPSG4326__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CustomEPSG4326", function() { return _ext_CRS_CustomEPSG4326__WEBPACK_IMPORTED_MODULE_1__["a"]; });

/* harmony import */ var _layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WMTSLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["q"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageMapLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["m"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SingleImageLayer", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["o"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataSource", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "URLDataSource", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["p"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LocalDataSource", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["n"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLabelGrid", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GWVTAnno", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["k"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Feature", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GStyleItem", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GDynamicMap", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GVMapGrid", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["i"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GXYZ", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["l"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GServiceGroup", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GVMapGridUtil", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["j"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GGroup", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLevels", function() { return _layer__WEBPACK_IMPORTED_MODULE_2__["f"]; });

/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(21);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FeatureManager", function() { return _util__WEBPACK_IMPORTED_MODULE_4__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TipPopup", function() { return _util__WEBPACK_IMPORTED_MODULE_4__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Geolocation", function() { return _util__WEBPACK_IMPORTED_MODULE_4__["b"]; });

/* harmony import */ var _control__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawPolyline", function() { return _control__WEBPACK_IMPORTED_MODULE_5__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawPolygon", function() { return _control__WEBPACK_IMPORTED_MODULE_5__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawRectangle", function() { return _control__WEBPACK_IMPORTED_MODULE_5__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawCircle", function() { return _control__WEBPACK_IMPORTED_MODULE_5__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawMarker", function() { return _control__WEBPACK_IMPORTED_MODULE_5__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DrawEdit", function() { return _control__WEBPACK_IMPORTED_MODULE_5__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeasurePath", function() { return _control__WEBPACK_IMPORTED_MODULE_5__["i"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MeasureArea", function() { return _control__WEBPACK_IMPORTED_MODULE_5__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ZoomBox", function() { return _control__WEBPACK_IMPORTED_MODULE_5__["k"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "History", function() { return _control__WEBPACK_IMPORTED_MODULE_5__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MousePosition", function() { return _control__WEBPACK_IMPORTED_MODULE_5__["j"]; });

/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(13);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WMTSCapabilities", function() { return _format__WEBPACK_IMPORTED_MODULE_6__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WMSCapabilities", function() { return _format__WEBPACK_IMPORTED_MODULE_6__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TRouteResultFormat", function() { return _format__WEBPACK_IMPORTED_MODULE_6__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TRouteResult", function() { return _format__WEBPACK_IMPORTED_MODULE_6__["a"]; });

/* harmony import */ var _service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(11);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PoiService", function() { return _service__WEBPACK_IMPORTED_MODULE_7__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TPoiService", function() { return _service__WEBPACK_IMPORTED_MODULE_7__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RouteService", function() { return _service__WEBPACK_IMPORTED_MODULE_7__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TRouteService", function() { return _service__WEBPACK_IMPORTED_MODULE_7__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GeocoderService", function() { return _service__WEBPACK_IMPORTED_MODULE_7__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TGeocoderService", function() { return _service__WEBPACK_IMPORTED_MODULE_7__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FeatureService", function() { return _service__WEBPACK_IMPORTED_MODULE_7__["a"]; });















var g = window || global;
g.Custom = g.Custom || {};
g.Custom.DataSource = _layer__WEBPACK_IMPORTED_MODULE_2__[/* DataSource */ "a"];
g.Custom.URLDataSource = _layer__WEBPACK_IMPORTED_MODULE_2__[/* URLDataSource */ "p"];
g.Custom.LocalDataSource = _layer__WEBPACK_IMPORTED_MODULE_2__[/* LocalDataSource */ "n"];
g.Custom.Feature = _layer__WEBPACK_IMPORTED_MODULE_2__[/* Feature */ "b"];
g.Custom.GGroup = _layer__WEBPACK_IMPORTED_MODULE_2__[/* GGroup */ "d"];
g.Custom.GLevels = _layer__WEBPACK_IMPORTED_MODULE_2__[/* GLevels */ "f"];
g.Custom.GStyleItem = _layer__WEBPACK_IMPORTED_MODULE_2__[/* GStyleItem */ "h"];
g.Custom.GServiceGroup = _layer__WEBPACK_IMPORTED_MODULE_2__[/* GServiceGroup */ "g"];
g.Custom.GVMapGridUtil = _layer__WEBPACK_IMPORTED_MODULE_2__[/* GVMapGridUtil */ "j"];
g.Custom.Filter = _filter__WEBPACK_IMPORTED_MODULE_3__[/* Filter */ "a"];
g.Custom.FilterLayer = _filter__WEBPACK_IMPORTED_MODULE_3__[/* FilterLayer */ "b"];
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate, global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function () {
  'use strict';
  /**
   * @this {Promise}
   */

  function finallyConstructor(callback) {
    var constructor = this.constructor;
    return this.then(function (value) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function () {
        return value;
      });
    }, function (reason) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function () {
        // @ts-ignore
        return constructor.reject(reason);
      });
    });
  }

  function allSettled(arr) {
    var P = this;
    return new P(function (resolve, reject) {
      if (!(arr && typeof arr.length !== 'undefined')) {
        return reject(new TypeError(_typeof(arr) + ' ' + arr + ' is not iterable(cannot read property Symbol(Symbol.iterator))'));
      }

      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        if (val && (_typeof(val) === 'object' || typeof val === 'function')) {
          var then = val.then;

          if (typeof then === 'function') {
            then.call(val, function (val) {
              res(i, val);
            }, function (e) {
              args[i] = {
                status: 'rejected',
                reason: e
              };

              if (--remaining === 0) {
                resolve(args);
              }
            });
            return;
          }
        }

        args[i] = {
          status: 'fulfilled',
          value: val
        };

        if (--remaining === 0) {
          resolve(args);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  } // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())


  var setTimeoutFunc = setTimeout;

  function isArray(x) {
    return Boolean(x && typeof x.length !== 'undefined');
  }

  function noop() {} // Polyfill for Function.prototype.bind


  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }
  /**
   * @constructor
   * @param {Function} fn
   */


  function Promise(fn) {
    if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    /** @type {!number} */

    this._state = 0;
    /** @type {!boolean} */

    this._handled = false;
    /** @type {Promise|undefined} */

    this._value = undefined;
    /** @type {!Array<!Function>} */

    this._deferreds = [];
    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }

    if (self._state === 0) {
      self._deferreds.push(deferred);

      return;
    }

    self._handled = true;

    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;

      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }

      var ret;

      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }

      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');

      if (newValue && (_typeof(newValue) === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;

        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }

      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function () {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }

    self._deferreds = null;
  }
  /**
   * @constructor
   */


  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }
  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */


  function doResolve(fn, self) {
    var done = false;

    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    // @ts-ignore
    var prom = new this.constructor(noop);
    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.prototype['finally'] = finallyConstructor;

  Promise.all = function (arr) {
    return new Promise(function (resolve, reject) {
      if (!isArray(arr)) {
        return reject(new TypeError('Promise.all accepts an array'));
      }

      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (_typeof(val) === 'object' || typeof val === 'function')) {
            var then = val.then;

            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }

          args[i] = val;

          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.allSettled = allSettled;

  Promise.resolve = function (value) {
    if (value && _typeof(value) === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (arr) {
    return new Promise(function (resolve, reject) {
      if (!isArray(arr)) {
        return reject(new TypeError('Promise.race accepts an array'));
      }

      for (var i = 0, len = arr.length; i < len; i++) {
        Promise.resolve(arr[i]).then(resolve, reject);
      }
    });
  }; // Use polyfill for setImmediate for performance gains


  Promise._immediateFn = // @ts-ignore
  typeof setImmediate === 'function' && function (fn) {
    // @ts-ignore
    setImmediate(fn);
  } || function (fn) {
    setTimeoutFunc(fn, 0);
  };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };
  /** @suppress {undefinedVars} */


  var globalNS = function () {
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== 'undefined') {
      return self;
    }

    if (typeof window !== 'undefined') {
      return window;
    }

    if (typeof global !== 'undefined') {
      return global;
    }

    throw new Error('unable to locate global object');
  }(); // Expose the polyfill if Promise is undefined or set to a
  // non-function value. The latter can be due to a named HTMLElement
  // being exposed by browsers for legacy reasons.
  // https://github.com/taylorhakes/promise-polyfill/issues/114


  if (typeof globalNS['Promise'] !== 'function') {
    globalNS['Promise'] = Promise;
  } else if (!globalNS.Promise.prototype['finally']) {
    globalNS.Promise.prototype['finally'] = finallyConstructor;
  } else if (!globalNS.Promise.allSettled) {
    globalNS.Promise.allSettled = allSettled;
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(40).setImmediate, __webpack_require__(18)))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(41); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18)))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(18), __webpack_require__(31)))

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

(function (self) {
  'use strict'; // if __disableNativeFetch is set to true, the it will always polyfill fetch
  // with Ajax.

  if (!self.__disableNativeFetch && self.fetch) {
    return;
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }

    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name');
    }

    return name.toLowerCase();
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }

    return value;
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function (value, name) {
        this.append(name, value);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function (name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function (name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var list = this.map[name];

    if (!list) {
      list = [];
      this.map[name] = list;
    }

    list.push(value);
  };

  Headers.prototype['delete'] = function (name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function (name) {
    var values = this.map[normalizeName(name)];
    return values ? values[0] : null;
  };

  Headers.prototype.getAll = function (name) {
    return this.map[normalizeName(name)] || [];
  };

  Headers.prototype.has = function (name) {
    return this.map.hasOwnProperty(normalizeName(name));
  };

  Headers.prototype.set = function (name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)];
  };

  Headers.prototype.forEach = function (callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function (name) {
      this.map[name].forEach(function (value) {
        callback.call(thisArg, value, name, this);
      }, this);
    }, this);
  };

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'));
    }

    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function (resolve, reject) {
      reader.onload = function () {
        resolve(reader.result);
      };

      reader.onerror = function () {
        reject(reader.error);
      };
    });
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    reader.readAsArrayBuffer(blob);
    return fileReaderReady(reader);
  }

  function readBlobAsText(blob, options) {
    var reader = new FileReader();
    var contentType = options.headers.map['content-type'] ? options.headers.map['content-type'].toString() : '';
    var regex = /charset\=[0-9a-zA-Z\-\_]*;?/;

    var _charset = blob.type.match(regex) || contentType.match(regex);

    var args = [blob];

    if (_charset) {
      args.push(_charset[0].replace(/^charset\=/, '').replace(/;$/, ''));
    }

    reader.readAsText.apply(reader, args);
    return fileReaderReady(reader);
  }

  var support = {
    blob: 'FileReader' in self && 'Blob' in self && function () {
      try {
        new Blob();
        return true;
      } catch (e) {
        return false;
      }
    }(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function Body() {
    this.bodyUsed = false;

    this._initBody = function (body, options) {
      this._bodyInit = body;

      if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
        this._options = options;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (!body) {
        this._bodyText = '';
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {// Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type');
      }
    };

    if (support.blob) {
      this.blob = function () {
        var rejected = consumed(this);

        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob);
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob');
        } else {
          return Promise.resolve(new Blob([this._bodyText]));
        }
      };

      this.arrayBuffer = function () {
        return this.blob().then(readBlobAsArrayBuffer);
      };

      this.text = function () {
        var rejected = consumed(this);

        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob, this._options);
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text');
        } else {
          return Promise.resolve(this._bodyText);
        }
      };
    } else {
      this.text = function () {
        var rejected = consumed(this);
        return rejected ? rejected : Promise.resolve(this._bodyText);
      };
    }

    if (support.formData) {
      this.formData = function () {
        return this.text().then(decode);
      };
    }

    this.json = function () {
      return this.text().then(JSON.parse);
    };

    return this;
  } // HTTP methods whose capitalization should be normalized


  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method;
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read');
      }

      this.url = input.url;
      this.credentials = input.credentials;

      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }

      this.method = input.method;
      this.mode = input.mode;

      if (!body) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = input;
    }

    this.credentials = options.credentials || this.credentials || 'omit';

    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }

    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests');
    }

    this._initBody(body, options);
  }

  Request.prototype.clone = function () {
    return new Request(this);
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function (bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form;
  }

  function headers(xhr) {
    var head = new Headers();
    var pairs = xhr.getAllResponseHeaders().trim().split('\n');
    pairs.forEach(function (header) {
      var split = header.trim().split(':');
      var key = split.shift().trim();
      var value = split.join(':').trim();
      head.append(key, value);
    });
    return head;
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this._initBody(bodyInit, options);

    this.type = 'default';
    this.status = options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options.statusText;
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers);
    this.url = options.url || '';
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function () {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    });
  };

  Response.error = function () {
    var response = new Response(null, {
      status: 0,
      statusText: ''
    });
    response.type = 'error';
    return response;
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function (url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code');
    }

    return new Response(null, {
      status: status,
      headers: {
        location: url
      }
    });
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function (input, init) {
    return new Promise(function (resolve, reject) {
      var request;

      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input;
      } else {
        request = new Request(input, init);
      }

      var xhr = new XMLHttpRequest();

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL;
        } // Avoid security warnings on getResponseHeader when not allowed by CORS


        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL');
        }

        return;
      }

      var __onLoadHandled = false;

      function onload() {
        if (xhr.readyState !== 4) {
          return;
        }

        var status = xhr.status === 1223 ? 204 : xhr.status;

        if (status < 100 || status > 599) {
          if (__onLoadHandled) {
            return;
          } else {
            __onLoadHandled = true;
          }

          reject(new TypeError('Network request failed'));
          return;
        }

        var options = {
          status: status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        };
        var body = 'response' in xhr ? xhr.response : xhr.responseText;

        if (__onLoadHandled) {
          return;
        } else {
          __onLoadHandled = true;
        }

        resolve(new Response(body, options));
      }

      xhr.onreadystatechange = onload;
      xhr.onload = onload;

      xhr.onerror = function () {
        if (__onLoadHandled) {
          return;
        } else {
          __onLoadHandled = true;
        }

        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true); // `withCredentials` should be setted after calling `.open` in IE10
      // http://stackoverflow.com/a/19667959/1219343

      try {
        if (request.credentials === 'include') {
          if ('withCredentials' in xhr) {
            xhr.withCredentials = true;
          } else {
            console && console.warn && console.warn('withCredentials is not supported, you can ignore this warning');
          }
        }
      } catch (e) {
        console && console.warn && console.warn('set withCredentials error:' + e);
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function (value, name) {
        xhr.setRequestHeader(name, value);
      });
      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    });
  };

  self.fetch.polyfill = true; // Support CommonJS

  if ( true && module.exports) {
    module.exports = self.fetch;
  }
})(typeof self !== 'undefined' ? self : this);

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "post", function() { return post; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "patch", function() { return patch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "json", function() { return json; });
function toString(obj) {
  return Object.prototype.toString.call(obj);
}

function set(request, header, value) {
  request.setRequestHeader(header, value);
}

function noop() {}

;
var isRequested = false;
var isIE9 = false;

function req(url, type, json, data, buf) {
  var methods = {
    success: noop,
    error: noop
  };
  var request;

  if (!isRequested) {
    var b_version = navigator.appVersion;
    var version = b_version.split(";");

    if (version[1]) {
      var trim_Version = version[1].replace(/[ ]/g, "");
      isIE9 = trim_Version == 'MSIE9.0';
    }

    isRequested = true;
  }

  if (isIE9) {
    request = new window.XDomainRequest();
  } else {
    request = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");
  }

  if (buf) {
    request.responseType = "arraybuffer";
  }

  var hasPayload = type === 'POST' || type === 'PATCH' || type === 'DELETE';
  request.open(type, url, true);

  if (!isIE9) {
    if (json) {
      set(request, 'Content-Type', 'application/json');
      set(request, 'Accept', 'application/json');
    } else {
      if (!buf) {
        set(request, 'Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
      }
    }
  }

  if (hasPayload) {
    if (json) data = JSON.stringify(data); // set(request, 'X-CSRFToken', csrf());
  } // set(request, 'X-Requested-With', 'XMLHttpRequest');


  request.onreadystatechange = function () {
    if (request.readyState === 4) {
      if (request.status >= 200 && request.status < 300) {
        if (buf) {
          methods.success.call(request, request.response, request);
        } else {
          methods.success.call(request, request.responseText, request);
        }
      } else {
        methods.error.call(request, request.responseText, request);
      }
    }
  };

  request.onerror = function () {
    if (buf) {
      methods.error.call(request, request.statusText, request);
    } else {
      methods.error.call(request, request.responseText, request);
    }
  };

  request.onload = function () {
    if (buf) {
      methods.success.call(request, request.response, request);
    } else {
      methods.success.call(request, request.responseText, request);
    }
  };

  hasPayload ? request.send(data) : request.send();
  var returned = {
    success: function success(callback) {
      methods.success = callback;
      return returned;
    },
    error: function error(callback) {
      methods.error = callback;
      return returned;
    },
    request: request
  };
  return returned;
}

var get = function get(url, buf) {
  return req(url, 'GET', false, null, buf);
};

var post = function post(url, data) {
  return req(url, 'POST', false, data);
};

var patch = function patch(url, data) {
  return req(url, 'PATCH', false, data);
};

var json = {
  get: function get(url) {
    return req(url, 'GET', true, null);
  },
  post: function post(url, data) {
    return req(url, 'POST', true, data);
  },
  patch: function patch(url, data) {
    return req(url, 'PATCH', true, data);
  }
}; //   const delete = function(url) {
//       return req(url, 'DELETE', false, null);
//   }



/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),
/* 45 */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 46 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2016 Zhipeng Jia
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


var WORD_MASK = [0, 0xff, 0xffff, 0xffffff, 0xffffffff];

function copyBytes(fromArray, fromPos, toArray, toPos, length) {
  var i;

  for (i = 0; i < length; i++) {
    toArray[toPos + i] = fromArray[fromPos + i];
  }
}

function selfCopyBytes(array, pos, offset, length) {
  var i;

  for (i = 0; i < length; i++) {
    array[pos + i] = array[pos - offset + i];
  }
}

function SnappyDecompressor(compressed) {
  this.array = compressed;
  this.pos = 0;
}

SnappyDecompressor.prototype.readUncompressedLength = function () {
  var result = 0;
  var shift = 0;
  var c, val;

  while (shift < 32 && this.pos < this.array.length) {
    c = this.array[this.pos];
    this.pos += 1;
    val = c & 0x7f;

    if (val << shift >>> shift !== val) {
      return -1;
    }

    result |= val << shift;

    if (c < 128) {
      return result;
    }

    shift += 7;
  }

  return -1;
};

SnappyDecompressor.prototype.uncompressToBuffer = function (outBuffer) {
  var array = this.array;
  var arrayLength = array.length;
  var pos = this.pos;
  var outPos = 0;
  var c, len, smallLen;
  var offset;

  while (pos < array.length) {
    c = array[pos];
    pos += 1;

    if ((c & 0x3) === 0) {
      // Literal
      len = (c >>> 2) + 1;

      if (len > 60) {
        if (pos + 3 >= arrayLength) {
          return false;
        }

        smallLen = len - 60;
        len = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
        len = (len & WORD_MASK[smallLen]) + 1;
        pos += smallLen;
      }

      if (pos + len > arrayLength) {
        return false;
      }

      copyBytes(array, pos, outBuffer, outPos, len);
      pos += len;
      outPos += len;
    } else {
      switch (c & 0x3) {
        case 1:
          len = (c >>> 2 & 0x7) + 4;
          offset = array[pos] + (c >>> 5 << 8);
          pos += 1;
          break;

        case 2:
          if (pos + 1 >= arrayLength) {
            return false;
          }

          len = (c >>> 2) + 1;
          offset = array[pos] + (array[pos + 1] << 8);
          pos += 2;
          break;

        case 3:
          if (pos + 3 >= arrayLength) {
            return false;
          }

          len = (c >>> 2) + 1;
          offset = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
          pos += 4;
          break;

        default:
          break;
      }

      if (offset === 0 || offset > outPos) {
        return false;
      }

      selfCopyBytes(outBuffer, outPos, offset, len);
      outPos += len;
    }
  }

  return true;
};

exports.SnappyDecompressor = SnappyDecompressor;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// The MIT License (MIT)
//
// Copyright (c) 2016 Zhipeng Jia
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


var BLOCK_LOG = 16;
var BLOCK_SIZE = 1 << BLOCK_LOG;
var MAX_HASH_TABLE_BITS = 14;
var globalHashTables = new Array(MAX_HASH_TABLE_BITS + 1);

function hashFunc(key, hashFuncShift) {
  return key * 0x1e35a7bd >>> hashFuncShift;
}

function load32(array, pos) {
  return array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
}

function equals32(array, pos1, pos2) {
  return array[pos1] === array[pos2] && array[pos1 + 1] === array[pos2 + 1] && array[pos1 + 2] === array[pos2 + 2] && array[pos1 + 3] === array[pos2 + 3];
}

function copyBytes(fromArray, fromPos, toArray, toPos, length) {
  var i;

  for (i = 0; i < length; i++) {
    toArray[toPos + i] = fromArray[fromPos + i];
  }
}

function emitLiteral(input, ip, len, output, op) {
  if (len <= 60) {
    output[op] = len - 1 << 2;
    op += 1;
  } else if (len < 256) {
    output[op] = 60 << 2;
    output[op + 1] = len - 1;
    op += 2;
  } else {
    output[op] = 61 << 2;
    output[op + 1] = len - 1 & 0xff;
    output[op + 2] = len - 1 >>> 8;
    op += 3;
  }

  copyBytes(input, ip, output, op, len);
  return op + len;
}

function emitCopyLessThan64(output, op, offset, len) {
  if (len < 12 && offset < 2048) {
    output[op] = 1 + (len - 4 << 2) + (offset >>> 8 << 5);
    output[op + 1] = offset & 0xff;
    return op + 2;
  } else {
    output[op] = 2 + (len - 1 << 2);
    output[op + 1] = offset & 0xff;
    output[op + 2] = offset >>> 8;
    return op + 3;
  }
}

function emitCopy(output, op, offset, len) {
  while (len >= 68) {
    op = emitCopyLessThan64(output, op, offset, 64);
    len -= 64;
  }

  if (len > 64) {
    op = emitCopyLessThan64(output, op, offset, 60);
    len -= 60;
  }

  return emitCopyLessThan64(output, op, offset, len);
}

function compressFragment(input, ip, inputSize, output, op) {
  var hashTableBits = 1;

  while (1 << hashTableBits <= inputSize && hashTableBits <= MAX_HASH_TABLE_BITS) {
    hashTableBits += 1;
  }

  hashTableBits -= 1;
  var hashFuncShift = 32 - hashTableBits;

  if (typeof globalHashTables[hashTableBits] === 'undefined') {
    globalHashTables[hashTableBits] = new Uint16Array(1 << hashTableBits);
  }

  var hashTable = globalHashTables[hashTableBits];
  var i;

  for (i = 0; i < hashTable.length; i++) {
    hashTable[i] = 0;
  }

  var ipEnd = ip + inputSize;
  var ipLimit;
  var baseIp = ip;
  var nextEmit = ip;
  var hash, nextHash;
  var nextIp, candidate, skip;
  var bytesBetweenHashLookups;
  var base, matched, offset;
  var prevHash, curHash;
  var flag = true;
  var INPUT_MARGIN = 15;

  if (inputSize >= INPUT_MARGIN) {
    ipLimit = ipEnd - INPUT_MARGIN;
    ip += 1;
    nextHash = hashFunc(load32(input, ip), hashFuncShift);

    while (flag) {
      skip = 32;
      nextIp = ip;

      do {
        ip = nextIp;
        hash = nextHash;
        bytesBetweenHashLookups = skip >>> 5;
        skip += 1;
        nextIp = ip + bytesBetweenHashLookups;

        if (ip > ipLimit) {
          flag = false;
          break;
        }

        nextHash = hashFunc(load32(input, nextIp), hashFuncShift);
        candidate = baseIp + hashTable[hash];
        hashTable[hash] = ip - baseIp;
      } while (!equals32(input, ip, candidate));

      if (!flag) {
        break;
      }

      op = emitLiteral(input, nextEmit, ip - nextEmit, output, op);

      do {
        base = ip;
        matched = 4;

        while (ip + matched < ipEnd && input[ip + matched] === input[candidate + matched]) {
          matched += 1;
        }

        ip += matched;
        offset = base - candidate;
        op = emitCopy(output, op, offset, matched);
        nextEmit = ip;

        if (ip >= ipLimit) {
          flag = false;
          break;
        }

        prevHash = hashFunc(load32(input, ip - 1), hashFuncShift);
        hashTable[prevHash] = ip - 1 - baseIp;
        curHash = hashFunc(load32(input, ip), hashFuncShift);
        candidate = baseIp + hashTable[curHash];
        hashTable[curHash] = ip - baseIp;
      } while (equals32(input, ip, candidate));

      if (!flag) {
        break;
      }

      ip += 1;
      nextHash = hashFunc(load32(input, ip), hashFuncShift);
    }
  }

  if (nextEmit < ipEnd) {
    op = emitLiteral(input, nextEmit, ipEnd - nextEmit, output, op);
  }

  return op;
}

function putVarint(value, output, op) {
  do {
    output[op] = value & 0x7f;
    value = value >>> 7;

    if (value > 0) {
      output[op] += 0x80;
    }

    op += 1;
  } while (value > 0);

  return op;
}

function SnappyCompressor(uncompressed) {
  this.array = uncompressed;
}

SnappyCompressor.prototype.maxCompressedLength = function () {
  var sourceLen = this.array.length;
  return 32 + sourceLen + Math.floor(sourceLen / 6);
};

SnappyCompressor.prototype.compressToBuffer = function (outBuffer) {
  var array = this.array;
  var length = array.length;
  var pos = 0;
  var outPos = 0;
  var fragmentSize;
  outPos = putVarint(length, outBuffer, outPos);

  while (pos < length) {
    fragmentSize = Math.min(length - pos, BLOCK_SIZE);
    outPos = compressFragment(array, pos, fragmentSize, outBuffer, outPos);
    pos += fragmentSize;
  }

  return outPos;
};

exports.SnappyCompressor = SnappyCompressor;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** @license
 *
 *  Copyright (C) 2012 K. Arthur Endsley (kaendsle@mtu.edu)
 *  Michigan Tech Research Institute (MTRI)
 *  3600 Green Court, Suite 100, Ann Arbor, MI, 48105
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
(function (root, factory) {
  if (true) {
    // AMD (+ global for extensions)
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return factory();
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function () {
  var beginsWith, endsWith, root, _Wkt; // Establish the root object, window in the browser, or exports on the server


  root = this;
  /**
   * @desc The Wkt namespace.
   * @property    {String}    delimiter   - The default delimiter for separating components of atomic geometry (coordinates)
   * @namespace
   * @global
   */

  _Wkt = function Wkt(obj) {
    if (obj instanceof _Wkt) return obj;
    if (!(this instanceof _Wkt)) return new _Wkt(obj);
    this._wrapped = obj;
  };
  /**
   * Returns true if the substring is found at the beginning of the string.
   * @param   str {String}    The String to search
   * @param   sub {String}    The substring of interest
   * @return      {Boolean}
   * @private
   */


  beginsWith = function beginsWith(str, sub) {
    return str.substring(0, sub.length) === sub;
  };
  /**
   * Returns true if the substring is found at the end of the string.
   * @param   str {String}    The String to search
   * @param   sub {String}    The substring of interest
   * @return      {Boolean}
   * @private
   */


  endsWith = function endsWith(str, sub) {
    return str.substring(str.length - sub.length) === sub;
  };
  /**
   * The default delimiter for separating components of atomic geometry (coordinates)
   * @ignore
   */


  _Wkt.delimiter = ' ';
  /**
   * Determines whether or not the passed Object is an Array.
   * @param   obj {Object}    The Object in question
   * @return      {Boolean}
   * @member Wkt.isArray
   * @method
   */

  _Wkt.isArray = function (obj) {
    return !!(obj && obj.constructor === Array);
  };
  /**
   * Removes given character String(s) from a String.
   * @param   str {String}    The String to search
   * @param   sub {String}    The String character(s) to trim
   * @return      {String}    The trimmed string
   * @member Wkt.trim
   * @method
   */


  _Wkt.trim = function (str, sub) {
    sub = sub || ' '; // Defaults to trimming spaces
    // Trim beginning spaces

    while (beginsWith(str, sub)) {
      str = str.substring(1);
    } // Trim ending spaces


    while (endsWith(str, sub)) {
      str = str.substring(0, str.length - 1);
    }

    return str;
  };
  /**
   * An object for reading WKT strings and writing geographic features
   * @constructor this.Wkt.Wkt
   * @param   initializer {String}    An optional WKT string for immediate read
   * @property            {Array}     components      - Holder for atomic geometry objects (internal representation of geometric components)
   * @property            {String}    delimiter       - The default delimiter for separating components of atomic geometry (coordinates)
   * @property            {Object}    regExes         - Some regular expressions copied from OpenLayers.Format.WKT.js
   * @property            {String}    type            - The Well-Known Text name (e.g. 'point') of the geometry
   * @property            {Boolean}   wrapVerticies   - True to wrap vertices in MULTIPOINT geometries; If true: MULTIPOINT((30 10),(10 30),(40 40)); If false: MULTIPOINT(30 10,10 30,40 40)
   * @return              {this.Wkt.Wkt}
   * @memberof Wkt
   */


  _Wkt.Wkt = function (initializer) {
    /**
     * The default delimiter between X and Y coordinates.
     * @ignore
     */
    this.delimiter = _Wkt.delimiter || ' ';
    /**
     * Configuration parameter for controlling how Wicket seralizes
     * MULTIPOINT strings. Examples; both are valid WKT:
     * If true: MULTIPOINT((30 10),(10 30),(40 40))
     * If false: MULTIPOINT(30 10,10 30,40 40)
     * @ignore
     */

    this.wrapVertices = true;
    /**
     * Some regular expressions copied from OpenLayers.Format.WKT.js
     * @ignore
     */

    this.regExes = {
      'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
      'spaces': /\s+|\+/,
      // Matches the '+' or the empty space
      'numeric': /-*\d+(\.*\d+)?/,
      'comma': /\s*,\s*/,
      'parenComma': /\)\s*,\s*\(/,
      'coord': /-*\d+\.*\d+ -*\d+\.*\d+/,
      // e.g. "24 -14"
      'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/,
      'ogcTypes': /^(multi)?(point|line|polygon|box)?(string)?$/i,
      // Captures e.g. "Multi","Line","String"
      'crudeJson': /^{.*"(type|coordinates|geometries|features)":.*}$/ // Attempts to recognize JSON strings

    };
    /**
     * Strip any whitespace and parens from front and back.
     * This is the equivalent of s/^\s*\(?(.*)\)?\s*$/$1/ but without the risk of catastrophic backtracking.
     * @param   str {String}
     */

    this._stripWhitespaceAndParens = function (fullStr) {
      var trimmed = fullStr.trim();
      var noParens = trimmed.replace(/^\(?(.*?)\)?$/, '$1');
      return noParens;
    };
    /**
     * The internal representation of geometry--the "components" of geometry.
     * @ignore
     */


    this.components = undefined; // An initial WKT string may be provided

    if (initializer && typeof initializer === 'string') {
      this.read(initializer);
    } else if (initializer && _typeof(initializer) !== undefined) {
      this.fromObject(initializer);
    }
  };
  /**
   * Returns true if the internal geometry is a collection of geometries.
   * @return  {Boolean}   Returns true when it is a collection
   * @memberof this.Wkt.Wkt
   * @method
   */


  _Wkt.Wkt.prototype.isCollection = function () {
    switch (this.type.slice(0, 5)) {
      case 'multi':
        // Trivial; any multi-geometry is a collection
        return true;

      case 'polyg':
        // Polygons with holes are "collections" of rings
        return true;

      default:
        // Any other geometry is not a collection
        return false;
    }
  };
  /**
   * Compares two x,y coordinates for equality.
   * @param   a   {Object}    An object with x and y properties
   * @param   b   {Object}    An object with x and y properties
   * @return      {Boolean}
   * @memberof this.Wkt.Wkt
   * @method
   */


  _Wkt.Wkt.prototype.sameCoords = function (a, b) {
    return a.x === b.x && a.y === b.y;
  };
  /**
   * Sets internal geometry (components) from framework geometry (e.g.
   * Google Polygon objects or google.maps.Polygon).
   * @param   obj {Object}    The framework-dependent geometry representation
   * @return      {this.Wkt.Wkt}   The object itself
   * @memberof this.Wkt.Wkt
   * @method
   */


  _Wkt.Wkt.prototype.fromObject = function (obj) {
    var result;

    if (obj.hasOwnProperty('type') && obj.hasOwnProperty('coordinates')) {
      result = this.fromJson(obj);
    } else {
      result = this.deconstruct.call(this, obj);
    }

    this.components = result.components;
    this.isRectangle = result.isRectangle || false;
    this.type = result.type;
    return this;
  };
  /**
   * Creates external geometry objects based on a plug-in framework's
   * construction methods and available geometry classes.
   * @param   config  {Object}    An optional framework-dependent properties specification
   * @return          {Object}    The framework-dependent geometry representation
   * @memberof this.Wkt.Wkt
   * @method
   */


  _Wkt.Wkt.prototype.toObject = function (config) {
    var obj = this.construct[this.type].call(this, config); // Don't assign the "properties" property to an Array

    if (_typeof(obj) === 'object' && !_Wkt.isArray(obj)) {
      obj.properties = this.properties;
    }

    return obj;
  };
  /**
   * Returns the WKT string representation; the same as the write() method.
   * @memberof this.Wkt.Wkt
   * @method
   */


  _Wkt.Wkt.prototype.toString = function (config) {
    return this.write();
  };
  /**
   * Parses a JSON representation as an Object.
   * @param	obj	{Object}	An Object with the GeoJSON schema
   * @return	{this.Wkt.Wkt}	The object itself
   * @memberof this.Wkt.Wkt
   * @method
   */


  _Wkt.Wkt.prototype.fromJson = function (obj) {
    var i, j, k, coords, iring, oring;
    this.type = obj.type.toLowerCase();
    this.components = [];

    if (obj.hasOwnProperty('geometry')) {
      //Feature
      this.fromJson(obj.geometry);
      this.properties = obj.properties;
      return this;
    }

    coords = obj.coordinates;

    if (!_Wkt.isArray(coords[0])) {
      // Point
      this.components.push({
        x: coords[0],
        y: coords[1]
      });
    } else {
      for (i in coords) {
        if (coords.hasOwnProperty(i)) {
          if (!_Wkt.isArray(coords[i][0])) {
            // LineString
            if (this.type === 'multipoint') {
              // MultiPoint
              this.components.push([{
                x: coords[i][0],
                y: coords[i][1]
              }]);
            } else {
              this.components.push({
                x: coords[i][0],
                y: coords[i][1]
              });
            }
          } else {
            oring = [];

            for (j in coords[i]) {
              if (coords[i].hasOwnProperty(j)) {
                if (!_Wkt.isArray(coords[i][j][0])) {
                  oring.push({
                    x: coords[i][j][0],
                    y: coords[i][j][1]
                  });
                } else {
                  iring = [];

                  for (k in coords[i][j]) {
                    if (coords[i][j].hasOwnProperty(k)) {
                      iring.push({
                        x: coords[i][j][k][0],
                        y: coords[i][j][k][1]
                      });
                    }
                  }

                  oring.push(iring);
                }
              }
            }

            this.components.push(oring);
          }
        }
      }
    }

    return this;
  };
  /**
   * Creates a JSON representation, with the GeoJSON schema, of the geometry.
   * @return    {Object}    The corresponding GeoJSON representation
   * @memberof this.Wkt.Wkt
   * @method
   */


  _Wkt.Wkt.prototype.toJson = function () {
    var cs, json, i, j, k, ring, rings;
    cs = this.components;
    json = {
      coordinates: [],
      type: function () {
        var i, type, s;
        type = this.regExes.ogcTypes.exec(this.type).slice(1);
        s = [];

        for (i in type) {
          if (type.hasOwnProperty(i)) {
            if (type[i] !== undefined) {
              s.push(type[i].toLowerCase().slice(0, 1).toUpperCase() + type[i].toLowerCase().slice(1));
            }
          }
        }

        return s;
      }.call(this).join('')
    }; // Wkt BOX type gets a special bbox property in GeoJSON

    if (this.type.toLowerCase() === 'box') {
      json.type = 'Polygon';
      json.bbox = [];

      for (i in cs) {
        if (cs.hasOwnProperty(i)) {
          json.bbox = json.bbox.concat([cs[i].x, cs[i].y]);
        }
      }

      json.coordinates = [[[cs[0].x, cs[0].y], [cs[0].x, cs[1].y], [cs[1].x, cs[1].y], [cs[1].x, cs[0].y], [cs[0].x, cs[0].y]]];
      return json;
    } // For the coordinates of most simple features


    for (i in cs) {
      if (cs.hasOwnProperty(i)) {
        // For those nested structures
        if (_Wkt.isArray(cs[i])) {
          rings = [];

          for (j in cs[i]) {
            if (cs[i].hasOwnProperty(j)) {
              if (_Wkt.isArray(cs[i][j])) {
                // MULTIPOLYGONS
                ring = [];

                for (k in cs[i][j]) {
                  if (cs[i][j].hasOwnProperty(k)) {
                    ring.push([cs[i][j][k].x, cs[i][j][k].y]);
                  }
                }

                rings.push(ring);
              } else {
                // POLYGONS and MULTILINESTRINGS
                if (cs[i].length > 1) {
                  rings.push([cs[i][j].x, cs[i][j].y]);
                } else {
                  // MULTIPOINTS
                  rings = rings.concat([cs[i][j].x, cs[i][j].y]);
                }
              }
            }
          }

          json.coordinates.push(rings);
        } else {
          if (cs.length > 1) {
            // For LINESTRING type
            json.coordinates.push([cs[i].x, cs[i].y]);
          } else {
            // For POINT type
            json.coordinates = json.coordinates.concat([cs[i].x, cs[i].y]);
          }
        }
      }
    }

    return json;
  };
  /**
   * Absorbs the geometry of another this.Wkt.Wkt instance, merging it with its own,
   * creating a collection (MULTI-geometry) based on their types, which must agree.
   * For example, creates a MULTIPOLYGON from a POLYGON type merged with another
   * POLYGON type, or adds a POLYGON instance to a MULTIPOLYGON instance.
   * @param   wkt {String}    A Wkt.Wkt object
   * @return	{this.Wkt.Wkt}	The object itself
   * @memberof this.Wkt.Wkt
   * @method
   */


  _Wkt.Wkt.prototype.merge = function (wkt) {
    var prefix = this.type.slice(0, 5);

    if (this.type !== wkt.type) {
      if (this.type.slice(5, this.type.length) !== wkt.type) {
        throw TypeError('The input geometry types must agree or the calling this.Wkt.Wkt instance must be a multigeometry of the other');
      }
    }

    switch (prefix) {
      case 'point':
        this.components = [this.components.concat(wkt.components)];
        break;

      case 'multi':
        this.components = this.components.concat(wkt.type.slice(0, 5) === 'multi' ? wkt.components : [wkt.components]);
        break;

      default:
        this.components = [this.components, wkt.components];
        break;
    }

    if (prefix !== 'multi') {
      this.type = 'multi' + this.type;
    }

    return this;
  };
  /**
   * Reads a WKT string, validating and incorporating it.
   * @param   str {String}    A WKT or GeoJSON string
   * @return	{this.Wkt.Wkt}	The object itself
   * @memberof this.Wkt.Wkt
   * @method
   */


  _Wkt.Wkt.prototype.read = function (str) {
    var matches;
    matches = this.regExes.typeStr.exec(str);

    if (matches) {
      this.type = matches[1].toLowerCase();
      this.base = matches[2];

      if (this.ingest[this.type]) {
        this.components = this.ingest[this.type].apply(this, [this.base]);
      }
    } else {
      if (this.regExes.crudeJson.test(str)) {
        if ((typeof JSON === "undefined" ? "undefined" : _typeof(JSON)) === 'object' && typeof JSON.parse === 'function') {
          this.fromJson(JSON.parse(str));
        } else {
          console.log('JSON.parse() is not available; cannot parse GeoJSON strings');
          throw {
            name: 'JSONError',
            message: 'JSON.parse() is not available; cannot parse GeoJSON strings'
          };
        }
      } else {
        console.log('Invalid WKT string provided to read()');
        throw {
          name: 'WKTError',
          message: 'Invalid WKT string provided to read()'
        };
      }
    }

    return this;
  }; // eo readWkt

  /**
   * Writes a WKT string.
   * @param   components  {Array}     An Array of internal geometry objects
   * @return              {String}    The corresponding WKT representation
   * @memberof this.Wkt.Wkt
   * @method
   */


  _Wkt.Wkt.prototype.write = function (components) {
    var i, pieces, data;
    components = components || this.components;
    pieces = [];
    pieces.push(this.type.toUpperCase() + '(');

    for (i = 0; i < components.length; i += 1) {
      if (this.isCollection() && i > 0) {
        pieces.push(',');
      } // There should be an extract function for the named type


      if (!this.extract[this.type]) {
        return null;
      }

      data = this.extract[this.type].apply(this, [components[i]]);

      if (this.isCollection() && this.type !== 'multipoint') {
        pieces.push('(' + data + ')');
      } else {
        pieces.push(data); // If not at the end of the components, add a comma

        if (i !== components.length - 1 && this.type !== 'multipoint') {
          pieces.push(',');
        }
      }
    }

    pieces.push(')');
    return pieces.join('');
  };
  /**
   * This object contains functions as property names that extract WKT
   * strings from the internal representation.
   * @memberof this.Wkt.Wkt
   * @namespace this.Wkt.Wkt.extract
   * @instance
   */


  _Wkt.Wkt.prototype.extract = {
    /**
     * Return a WKT string representing atomic (point) geometry
     * @param   point   {Object}    An object with x and y properties
     * @return          {String}    The WKT representation
     * @memberof this.Wkt.Wkt.extract
     * @instance
     */
    point: function point(_point) {
      return String(_point.x) + this.delimiter + String(_point.y);
    },

    /**
     * Return a WKT string representing multiple atoms (points)
     * @param   multipoint  {Array}     Multiple x-and-y objects
     * @return              {String}    The WKT representation
     * @memberof this.Wkt.Wkt.extract
     * @instance
     */
    multipoint: function multipoint(_multipoint) {
      var i,
          parts = [],
          s;

      for (i = 0; i < _multipoint.length; i += 1) {
        s = this.extract.point.apply(this, [_multipoint[i]]);

        if (this.wrapVertices) {
          s = '(' + s + ')';
        }

        parts.push(s);
      }

      return parts.join(',');
    },

    /**
     * Return a WKT string representing a chain (linestring) of atoms
     * @param   linestring  {Array}     Multiple x-and-y objects
     * @return              {String}    The WKT representation
     * @memberof this.Wkt.Wkt.extract
     * @instance
     */
    linestring: function linestring(_linestring) {
      // Extraction of linestrings is the same as for points
      return this.extract.point.apply(this, [_linestring]);
    },

    /**
     * Return a WKT string representing multiple chains (multilinestring) of atoms
     * @param   multilinestring {Array}     Multiple of multiple x-and-y objects
     * @return                  {String}    The WKT representation
     * @memberof this.Wkt.Wkt.extract
     * @instance
     */
    multilinestring: function multilinestring(_multilinestring) {
      var i,
          parts = [];

      if (_multilinestring.length) {
        for (i = 0; i < _multilinestring.length; i += 1) {
          parts.push(this.extract.linestring.apply(this, [_multilinestring[i]]));
        }
      } else {
        parts.push(this.extract.point.apply(this, [_multilinestring]));
      }

      return parts.join(',');
    },

    /**
     * Return a WKT string representing multiple atoms in closed series (polygon)
     * @param   polygon {Array}     Collection of ordered x-and-y objects
     * @return          {String}    The WKT representation
     * @memberof this.Wkt.Wkt.extract
     * @instance
     */
    polygon: function polygon(_polygon) {
      // Extraction of polygons is the same as for multilinestrings
      return this.extract.multilinestring.apply(this, [_polygon]);
    },

    /**
     * Return a WKT string representing multiple closed series (multipolygons) of multiple atoms
     * @param   multipolygon    {Array}     Collection of ordered x-and-y objects
     * @return                  {String}    The WKT representation
     * @memberof this.Wkt.Wkt.extract
     * @instance
     */
    multipolygon: function multipolygon(_multipolygon) {
      var i,
          parts = [];

      for (i = 0; i < _multipolygon.length; i += 1) {
        parts.push('(' + this.extract.polygon.apply(this, [_multipolygon[i]]) + ')');
      }

      return parts.join(',');
    },

    /**
     * Return a WKT string representing a 2DBox
     * @param   multipolygon    {Array}     Collection of ordered x-and-y objects
     * @return                  {String}    The WKT representation
     * @memberof this.Wkt.Wkt.extract
     * @instance
     */
    box: function box(_box) {
      return this.extract.linestring.apply(this, [_box]);
    },
    geometrycollection: function geometrycollection(str) {
      console.log('The geometrycollection WKT type is not yet supported.');
    }
  };
  /**
   * This object contains functions as property names that ingest WKT
   * strings into the internal representation.
   * @memberof this.Wkt.Wkt
   * @namespace this.Wkt.Wkt.ingest
   * @instance
   */

  _Wkt.Wkt.prototype.ingest = {
    /**
     * Return point feature given a point WKT fragment.
     * @param   str {String}    A WKT fragment representing the point
     * @memberof this.Wkt.Wkt.ingest
     * @instance
     */
    point: function point(str) {
      var coords = _Wkt.trim(str).split(this.regExes.spaces); // In case a parenthetical group of coordinates is passed...


      return [{
        // ...Search for numeric substrings
        x: parseFloat(this.regExes.numeric.exec(coords[0])[0]),
        y: parseFloat(this.regExes.numeric.exec(coords[1])[0])
      }];
    },

    /**
     * Return a multipoint feature given a multipoint WKT fragment.
     * @param   str {String}    A WKT fragment representing the multipoint
     * @memberof this.Wkt.Wkt.ingest
     * @instance
     */
    multipoint: function multipoint(str) {
      var i, components, points;
      components = [];
      points = _Wkt.trim(str).split(this.regExes.comma);

      for (i = 0; i < points.length; i += 1) {
        components.push(this.ingest.point.apply(this, [points[i]]));
      }

      return components;
    },

    /**
     * Return a linestring feature given a linestring WKT fragment.
     * @param   str {String}    A WKT fragment representing the linestring
     * @memberof this.Wkt.Wkt.ingest
     * @instance
     */
    linestring: function linestring(str) {
      var i, multipoints, components; // In our x-and-y representation of components, parsing
      //  multipoints is the same as parsing linestrings

      multipoints = this.ingest.multipoint.apply(this, [str]); // However, the points need to be joined

      components = [];

      for (i = 0; i < multipoints.length; i += 1) {
        components = components.concat(multipoints[i]);
      }

      return components;
    },

    /**
     * Return a multilinestring feature given a multilinestring WKT fragment.
     * @param   str {String}    A WKT fragment representing the multilinestring
     * @memberof this.Wkt.Wkt.ingest
     * @instance
     */
    multilinestring: function multilinestring(str) {
      var i, components, line, lines;
      components = [];
      lines = _Wkt.trim(str).split(this.regExes.doubleParenComma);

      if (lines.length === 1) {
        // If that didn't work...
        lines = _Wkt.trim(str).split(this.regExes.parenComma);
      }

      for (i = 0; i < lines.length; i += 1) {
        line = this._stripWhitespaceAndParens(lines[i]);
        components.push(this.ingest.linestring.apply(this, [line]));
      }

      return components;
    },

    /**
     * Return a polygon feature given a polygon WKT fragment.
     * @param   str {String}    A WKT fragment representing the polygon
     * @memberof this.Wkt.Wkt.ingest
     * @instance
     */
    polygon: function polygon(str) {
      var i, j, components, subcomponents, ring, rings;
      rings = _Wkt.trim(str).split(this.regExes.parenComma);
      components = []; // Holds one or more rings

      for (i = 0; i < rings.length; i += 1) {
        ring = this._stripWhitespaceAndParens(rings[i]).split(this.regExes.comma);
        subcomponents = []; // Holds the outer ring and any inner rings (holes)

        for (j = 0; j < ring.length; j += 1) {
          // Split on the empty space or '+' character (between coordinates)
          var split = ring[j].split(this.regExes.spaces);

          if (split.length > 2) {
            //remove the elements which are blanks
            split = split.filter(function (n) {
              return n != "";
            });
          }

          if (split.length === 2) {
            var x_cord = split[0];
            var y_cord = split[1]; //now push

            subcomponents.push({
              x: parseFloat(x_cord),
              y: parseFloat(y_cord)
            });
          }
        }

        components.push(subcomponents);
      }

      return components;
    },

    /**
     * Return box vertices (which would become the Rectangle bounds) given a Box WKT fragment.
     * @param   str {String}    A WKT fragment representing the box
     * @memberof this.Wkt.Wkt.ingest
     * @instance
     */
    box: function box(str) {
      var i, multipoints, components; // In our x-and-y representation of components, parsing
      //  multipoints is the same as parsing linestrings

      multipoints = this.ingest.multipoint.apply(this, [str]); // However, the points need to be joined

      components = [];

      for (i = 0; i < multipoints.length; i += 1) {
        components = components.concat(multipoints[i]);
      }

      return components;
    },

    /**
     * Return a multipolygon feature given a multipolygon WKT fragment.
     * @param   str {String}    A WKT fragment representing the multipolygon
     * @memberof this.Wkt.Wkt.ingest
     * @instance
     */
    multipolygon: function multipolygon(str) {
      var i, components, polygon, polygons;
      components = [];
      polygons = _Wkt.trim(str).split(this.regExes.doubleParenComma);

      for (i = 0; i < polygons.length; i += 1) {
        polygon = this._stripWhitespaceAndParens(polygons[i]);
        components.push(this.ingest.polygon.apply(this, [polygon]));
      }

      return components;
    },

    /**
     * Return an array of features given a geometrycollection WKT fragment.
     * @param   str {String}    A WKT fragment representing the geometry collection
     * @memberof this.Wkt.Wkt.ingest
     * @instance
     */
    geometrycollection: function geometrycollection(str) {
      console.log('The geometrycollection WKT type is not yet supported.');
    }
  }; // eo ingest

  return _Wkt;
});

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _draw_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
/* harmony import */ var _draw_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_draw_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _measurecontrol_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53);
/* harmony import */ var _measurecontrol_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_measurecontrol_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _zoombox_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _zoombox_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_zoombox_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _featureAttr_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58);
/* harmony import */ var _featureAttr_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_featureAttr_css__WEBPACK_IMPORTED_MODULE_3__);





/***/ }),
/* 51 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 52 */,
/* 53 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 58 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ })
/******/ ]);